
MyProject.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005f70  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000002c  20000000  00005f70  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000280c  2000002c  00005f9c  0002002c  2**2
                  ALLOC
  3 .stack        00002000  20002838  000087a8  0002002c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0002002c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020054  2**0
                  CONTENTS, READONLY
  6 .debug_info   00021818  00000000  00000000  000200ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000033be  00000000  00000000  000418c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000966b  00000000  00000000  00044c83  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001858  00000000  00000000  0004e2ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000016b8  00000000  00000000  0004fb46  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0002025e  00000000  00000000  000511fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00014e1e  00000000  00000000  0007145c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a65cb  00000000  00000000  0008627a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000059b0  00000000  00000000  0012c848  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	38 48 00 20 31 01 00 00 b5 01 00 00 b5 01 00 00     8H. 1...........
	...
      2c:	15 3a 00 00 00 00 00 00 00 00 00 00 41 3b 00 00     .:..........A;..
      3c:	89 3b 00 00 b5 01 00 00 b5 01 00 00 b5 01 00 00     .;..............
      4c:	b5 01 00 00 b5 01 00 00 b5 01 00 00 b5 01 00 00     ................
      5c:	b5 01 00 00 b5 01 00 00 b5 01 00 00 b5 01 00 00     ................
      6c:	b5 01 00 00 b5 01 00 00 b5 01 00 00 b5 01 00 00     ................
      7c:	b5 01 00 00 b5 01 00 00 b5 01 00 00 b5 01 00 00     ................
      8c:	b5 01 00 00 59 2d 00 00 b5 01 00 00 b5 01 00 00     ....Y-..........
      9c:	b5 01 00 00 b5 01 00 00 b5 01 00 00 b5 01 00 00     ................
      ac:	b5 01 00 00 b5 01 00 00 b5 01 00 00 b5 01 00 00     ................

000000bc <__do_global_dtors_aux>:
      bc:	b510      	push	{r4, lr}
      be:	4c06      	ldr	r4, [pc, #24]	; (d8 <__do_global_dtors_aux+0x1c>)
      c0:	7823      	ldrb	r3, [r4, #0]
      c2:	2b00      	cmp	r3, #0
      c4:	d107      	bne.n	d6 <__do_global_dtors_aux+0x1a>
      c6:	4b05      	ldr	r3, [pc, #20]	; (dc <__do_global_dtors_aux+0x20>)
      c8:	2b00      	cmp	r3, #0
      ca:	d002      	beq.n	d2 <__do_global_dtors_aux+0x16>
      cc:	4804      	ldr	r0, [pc, #16]	; (e0 <__do_global_dtors_aux+0x24>)
      ce:	e000      	b.n	d2 <__do_global_dtors_aux+0x16>
      d0:	bf00      	nop
      d2:	2301      	movs	r3, #1
      d4:	7023      	strb	r3, [r4, #0]
      d6:	bd10      	pop	{r4, pc}
      d8:	2000002c 	.word	0x2000002c
      dc:	00000000 	.word	0x00000000
      e0:	00005f70 	.word	0x00005f70

000000e4 <frame_dummy>:
      e4:	4b08      	ldr	r3, [pc, #32]	; (108 <frame_dummy+0x24>)
      e6:	b510      	push	{r4, lr}
      e8:	2b00      	cmp	r3, #0
      ea:	d003      	beq.n	f4 <frame_dummy+0x10>
      ec:	4907      	ldr	r1, [pc, #28]	; (10c <frame_dummy+0x28>)
      ee:	4808      	ldr	r0, [pc, #32]	; (110 <frame_dummy+0x2c>)
      f0:	e000      	b.n	f4 <frame_dummy+0x10>
      f2:	bf00      	nop
      f4:	4807      	ldr	r0, [pc, #28]	; (114 <frame_dummy+0x30>)
      f6:	6803      	ldr	r3, [r0, #0]
      f8:	2b00      	cmp	r3, #0
      fa:	d100      	bne.n	fe <frame_dummy+0x1a>
      fc:	bd10      	pop	{r4, pc}
      fe:	4b06      	ldr	r3, [pc, #24]	; (118 <frame_dummy+0x34>)
     100:	2b00      	cmp	r3, #0
     102:	d0fb      	beq.n	fc <frame_dummy+0x18>
     104:	4798      	blx	r3
     106:	e7f9      	b.n	fc <frame_dummy+0x18>
     108:	00000000 	.word	0x00000000
     10c:	20000030 	.word	0x20000030
     110:	00005f70 	.word	0x00005f70
     114:	00005f70 	.word	0x00005f70
     118:	00000000 	.word	0x00000000

0000011c <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     11c:	b580      	push	{r7, lr}
     11e:	af00      	add	r7, sp, #0
	system_init();
     120:	4b02      	ldr	r3, [pc, #8]	; (12c <atmel_start_init+0x10>)
     122:	4798      	blx	r3
}
     124:	46c0      	nop			; (mov r8, r8)
     126:	46bd      	mov	sp, r7
     128:	bd80      	pop	{r7, pc}
     12a:	46c0      	nop			; (mov r8, r8)
     12c:	00000b29 	.word	0x00000b29

00000130 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
     130:	b580      	push	{r7, lr}
     132:	b082      	sub	sp, #8
     134:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
     136:	4b16      	ldr	r3, [pc, #88]	; (190 <Reset_Handler+0x60>)
     138:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
     13a:	4b16      	ldr	r3, [pc, #88]	; (194 <Reset_Handler+0x64>)
     13c:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
     13e:	687a      	ldr	r2, [r7, #4]
     140:	683b      	ldr	r3, [r7, #0]
     142:	429a      	cmp	r2, r3
     144:	d00c      	beq.n	160 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
     146:	e007      	b.n	158 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
     148:	683b      	ldr	r3, [r7, #0]
     14a:	1d1a      	adds	r2, r3, #4
     14c:	603a      	str	r2, [r7, #0]
     14e:	687a      	ldr	r2, [r7, #4]
     150:	1d11      	adds	r1, r2, #4
     152:	6079      	str	r1, [r7, #4]
     154:	6812      	ldr	r2, [r2, #0]
     156:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
     158:	683a      	ldr	r2, [r7, #0]
     15a:	4b0f      	ldr	r3, [pc, #60]	; (198 <Reset_Handler+0x68>)
     15c:	429a      	cmp	r2, r3
     15e:	d3f3      	bcc.n	148 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
     160:	4b0e      	ldr	r3, [pc, #56]	; (19c <Reset_Handler+0x6c>)
     162:	603b      	str	r3, [r7, #0]
     164:	e004      	b.n	170 <Reset_Handler+0x40>
                *pDest++ = 0;
     166:	683b      	ldr	r3, [r7, #0]
     168:	1d1a      	adds	r2, r3, #4
     16a:	603a      	str	r2, [r7, #0]
     16c:	2200      	movs	r2, #0
     16e:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
     170:	683a      	ldr	r2, [r7, #0]
     172:	4b0b      	ldr	r3, [pc, #44]	; (1a0 <Reset_Handler+0x70>)
     174:	429a      	cmp	r2, r3
     176:	d3f6      	bcc.n	166 <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
     178:	4b0a      	ldr	r3, [pc, #40]	; (1a4 <Reset_Handler+0x74>)
     17a:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     17c:	4b0a      	ldr	r3, [pc, #40]	; (1a8 <Reset_Handler+0x78>)
     17e:	687a      	ldr	r2, [r7, #4]
     180:	21ff      	movs	r1, #255	; 0xff
     182:	438a      	bics	r2, r1
     184:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
        __libc_init_array();
     186:	4b09      	ldr	r3, [pc, #36]	; (1ac <Reset_Handler+0x7c>)
     188:	4798      	blx	r3

        /* Branch to main function */
        main();
     18a:	4b09      	ldr	r3, [pc, #36]	; (1b0 <Reset_Handler+0x80>)
     18c:	4798      	blx	r3

        /* Infinite loop */
        while (1);
     18e:	e7fe      	b.n	18e <Reset_Handler+0x5e>
     190:	00005f70 	.word	0x00005f70
     194:	20000000 	.word	0x20000000
     198:	2000002c 	.word	0x2000002c
     19c:	2000002c 	.word	0x2000002c
     1a0:	20002838 	.word	0x20002838
     1a4:	00000000 	.word	0x00000000
     1a8:	e000ed00 	.word	0xe000ed00
     1ac:	00005d71 	.word	0x00005d71
     1b0:	00002e59 	.word	0x00002e59

000001b4 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     1b4:	b580      	push	{r7, lr}
     1b6:	af00      	add	r7, sp, #0
        while (1) {
     1b8:	e7fe      	b.n	1b8 <Dummy_Handler+0x4>

000001ba <hri_gclk_write_PCHCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
     1ba:	b580      	push	{r7, lr}
     1bc:	b084      	sub	sp, #16
     1be:	af00      	add	r7, sp, #0
     1c0:	60f8      	str	r0, [r7, #12]
     1c2:	607a      	str	r2, [r7, #4]
     1c4:	230b      	movs	r3, #11
     1c6:	18fb      	adds	r3, r7, r3
     1c8:	1c0a      	adds	r2, r1, #0
     1ca:	701a      	strb	r2, [r3, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     1cc:	230b      	movs	r3, #11
     1ce:	18fb      	adds	r3, r7, r3
     1d0:	781a      	ldrb	r2, [r3, #0]
     1d2:	68fb      	ldr	r3, [r7, #12]
     1d4:	3220      	adds	r2, #32
     1d6:	0092      	lsls	r2, r2, #2
     1d8:	6879      	ldr	r1, [r7, #4]
     1da:	50d1      	str	r1, [r2, r3]
	GCLK_CRITICAL_SECTION_LEAVE();
}
     1dc:	46c0      	nop			; (mov r8, r8)
     1de:	46bd      	mov	sp, r7
     1e0:	b004      	add	sp, #16
     1e2:	bd80      	pop	{r7, pc}

000001e4 <hri_mclk_set_APBCMASK_SERCOM3_bit>:
	((Mclk *)hw)->APBCMASK.reg ^= MCLK_APBCMASK_SERCOM2;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBCMASK_SERCOM3_bit(const void *const hw)
{
     1e4:	b580      	push	{r7, lr}
     1e6:	b082      	sub	sp, #8
     1e8:	af00      	add	r7, sp, #0
     1ea:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM3;
     1ec:	687b      	ldr	r3, [r7, #4]
     1ee:	69db      	ldr	r3, [r3, #28]
     1f0:	2210      	movs	r2, #16
     1f2:	431a      	orrs	r2, r3
     1f4:	687b      	ldr	r3, [r7, #4]
     1f6:	61da      	str	r2, [r3, #28]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     1f8:	46c0      	nop			; (mov r8, r8)
     1fa:	46bd      	mov	sp, r7
     1fc:	b002      	add	sp, #8
     1fe:	bd80      	pop	{r7, pc}

00000200 <hri_mclk_set_APBCMASK_TC0_bit>:
	((Mclk *)hw)->APBCMASK.reg ^= MCLK_APBCMASK_TCC2;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBCMASK_TC0_bit(const void *const hw)
{
     200:	b580      	push	{r7, lr}
     202:	b082      	sub	sp, #8
     204:	af00      	add	r7, sp, #0
     206:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TC0;
     208:	687b      	ldr	r3, [r7, #4]
     20a:	69db      	ldr	r3, [r3, #28]
     20c:	2280      	movs	r2, #128	; 0x80
     20e:	0152      	lsls	r2, r2, #5
     210:	431a      	orrs	r2, r3
     212:	687b      	ldr	r3, [r7, #4]
     214:	61da      	str	r2, [r3, #28]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     216:	46c0      	nop			; (mov r8, r8)
     218:	46bd      	mov	sp, r7
     21a:	b002      	add	sp, #8
     21c:	bd80      	pop	{r7, pc}

0000021e <hri_mclk_set_APBCMASK_ADC0_bit>:
	((Mclk *)hw)->APBCMASK.reg ^= MCLK_APBCMASK_TC4;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBCMASK_ADC0_bit(const void *const hw)
{
     21e:	b580      	push	{r7, lr}
     220:	b082      	sub	sp, #8
     222:	af00      	add	r7, sp, #0
     224:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_ADC0;
     226:	687b      	ldr	r3, [r7, #4]
     228:	69db      	ldr	r3, [r3, #28]
     22a:	2280      	movs	r2, #128	; 0x80
     22c:	0292      	lsls	r2, r2, #10
     22e:	431a      	orrs	r2, r3
     230:	687b      	ldr	r3, [r7, #4]
     232:	61da      	str	r2, [r3, #28]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     234:	46c0      	nop			; (mov r8, r8)
     236:	46bd      	mov	sp, r7
     238:	b002      	add	sp, #8
     23a:	bd80      	pop	{r7, pc}

0000023c <hri_port_set_DIR_reg>:
	((PortGroup *)hw)->WRCONFIG.reg = data;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_set_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
     23c:	b580      	push	{r7, lr}
     23e:	b084      	sub	sp, #16
     240:	af00      	add	r7, sp, #0
     242:	60f8      	str	r0, [r7, #12]
     244:	607a      	str	r2, [r7, #4]
     246:	230b      	movs	r3, #11
     248:	18fb      	adds	r3, r7, r3
     24a:	1c0a      	adds	r2, r1, #0
     24c:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     24e:	230b      	movs	r3, #11
     250:	18fb      	adds	r3, r7, r3
     252:	781b      	ldrb	r3, [r3, #0]
     254:	68fa      	ldr	r2, [r7, #12]
     256:	01db      	lsls	r3, r3, #7
     258:	18d3      	adds	r3, r2, r3
     25a:	3308      	adds	r3, #8
     25c:	687a      	ldr	r2, [r7, #4]
     25e:	601a      	str	r2, [r3, #0]
}
     260:	46c0      	nop			; (mov r8, r8)
     262:	46bd      	mov	sp, r7
     264:	b004      	add	sp, #16
     266:	bd80      	pop	{r7, pc}

00000268 <hri_port_clear_DIR_reg>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = data;
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
     268:	b580      	push	{r7, lr}
     26a:	b084      	sub	sp, #16
     26c:	af00      	add	r7, sp, #0
     26e:	60f8      	str	r0, [r7, #12]
     270:	607a      	str	r2, [r7, #4]
     272:	230b      	movs	r3, #11
     274:	18fb      	adds	r3, r7, r3
     276:	1c0a      	adds	r2, r1, #0
     278:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     27a:	230b      	movs	r3, #11
     27c:	18fb      	adds	r3, r7, r3
     27e:	781b      	ldrb	r3, [r3, #0]
     280:	68fa      	ldr	r2, [r7, #12]
     282:	01db      	lsls	r3, r3, #7
     284:	18d3      	adds	r3, r2, r3
     286:	3304      	adds	r3, #4
     288:	687a      	ldr	r2, [r7, #4]
     28a:	601a      	str	r2, [r3, #0]
}
     28c:	46c0      	nop			; (mov r8, r8)
     28e:	46bd      	mov	sp, r7
     290:	b004      	add	sp, #16
     292:	bd80      	pop	{r7, pc}

00000294 <hri_port_set_OUT_reg>:
{
	((Port *)hw)->Group[submodule_index].DIRTGL.reg = mask;
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
     294:	b580      	push	{r7, lr}
     296:	b084      	sub	sp, #16
     298:	af00      	add	r7, sp, #0
     29a:	60f8      	str	r0, [r7, #12]
     29c:	607a      	str	r2, [r7, #4]
     29e:	230b      	movs	r3, #11
     2a0:	18fb      	adds	r3, r7, r3
     2a2:	1c0a      	adds	r2, r1, #0
     2a4:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     2a6:	230b      	movs	r3, #11
     2a8:	18fb      	adds	r3, r7, r3
     2aa:	781b      	ldrb	r3, [r3, #0]
     2ac:	68fa      	ldr	r2, [r7, #12]
     2ae:	01db      	lsls	r3, r3, #7
     2b0:	18d3      	adds	r3, r2, r3
     2b2:	3318      	adds	r3, #24
     2b4:	687a      	ldr	r2, [r7, #4]
     2b6:	601a      	str	r2, [r3, #0]
}
     2b8:	46c0      	nop			; (mov r8, r8)
     2ba:	46bd      	mov	sp, r7
     2bc:	b004      	add	sp, #16
     2be:	bd80      	pop	{r7, pc}

000002c0 <hri_port_clear_OUT_reg>:
	((Port *)hw)->Group[submodule_index].OUTSET.reg = data;
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
     2c0:	b580      	push	{r7, lr}
     2c2:	b084      	sub	sp, #16
     2c4:	af00      	add	r7, sp, #0
     2c6:	60f8      	str	r0, [r7, #12]
     2c8:	607a      	str	r2, [r7, #4]
     2ca:	230b      	movs	r3, #11
     2cc:	18fb      	adds	r3, r7, r3
     2ce:	1c0a      	adds	r2, r1, #0
     2d0:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     2d2:	230b      	movs	r3, #11
     2d4:	18fb      	adds	r3, r7, r3
     2d6:	781b      	ldrb	r3, [r3, #0]
     2d8:	68fa      	ldr	r2, [r7, #12]
     2da:	01db      	lsls	r3, r3, #7
     2dc:	18d3      	adds	r3, r2, r3
     2de:	3314      	adds	r3, #20
     2e0:	687a      	ldr	r2, [r7, #4]
     2e2:	601a      	str	r2, [r3, #0]
}
     2e4:	46c0      	nop			; (mov r8, r8)
     2e6:	46bd      	mov	sp, r7
     2e8:	b004      	add	sp, #16
     2ea:	bd80      	pop	{r7, pc}

000002ec <hri_port_write_PMUX_PMUXE_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXE_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
     2ec:	b590      	push	{r4, r7, lr}
     2ee:	b085      	sub	sp, #20
     2f0:	af00      	add	r7, sp, #0
     2f2:	6078      	str	r0, [r7, #4]
     2f4:	000c      	movs	r4, r1
     2f6:	0010      	movs	r0, r2
     2f8:	0019      	movs	r1, r3
     2fa:	1cfb      	adds	r3, r7, #3
     2fc:	1c22      	adds	r2, r4, #0
     2fe:	701a      	strb	r2, [r3, #0]
     300:	1cbb      	adds	r3, r7, #2
     302:	1c02      	adds	r2, r0, #0
     304:	701a      	strb	r2, [r3, #0]
     306:	1c7b      	adds	r3, r7, #1
     308:	1c0a      	adds	r2, r1, #0
     30a:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     30c:	1cfb      	adds	r3, r7, #3
     30e:	7819      	ldrb	r1, [r3, #0]
     310:	1cbb      	adds	r3, r7, #2
     312:	781a      	ldrb	r2, [r3, #0]
     314:	230f      	movs	r3, #15
     316:	18fb      	adds	r3, r7, r3
     318:	6878      	ldr	r0, [r7, #4]
     31a:	2430      	movs	r4, #48	; 0x30
     31c:	01c9      	lsls	r1, r1, #7
     31e:	1841      	adds	r1, r0, r1
     320:	188a      	adds	r2, r1, r2
     322:	1912      	adds	r2, r2, r4
     324:	7812      	ldrb	r2, [r2, #0]
     326:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     328:	230f      	movs	r3, #15
     32a:	18fb      	adds	r3, r7, r3
     32c:	220f      	movs	r2, #15
     32e:	18ba      	adds	r2, r7, r2
     330:	7812      	ldrb	r2, [r2, #0]
     332:	210f      	movs	r1, #15
     334:	438a      	bics	r2, r1
     336:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXE(data);
     338:	1c7b      	adds	r3, r7, #1
     33a:	781b      	ldrb	r3, [r3, #0]
     33c:	220f      	movs	r2, #15
     33e:	4013      	ands	r3, r2
     340:	b2d9      	uxtb	r1, r3
     342:	230f      	movs	r3, #15
     344:	18fb      	adds	r3, r7, r3
     346:	220f      	movs	r2, #15
     348:	18ba      	adds	r2, r7, r2
     34a:	7812      	ldrb	r2, [r2, #0]
     34c:	430a      	orrs	r2, r1
     34e:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     350:	1cfb      	adds	r3, r7, #3
     352:	781a      	ldrb	r2, [r3, #0]
     354:	1cbb      	adds	r3, r7, #2
     356:	781b      	ldrb	r3, [r3, #0]
     358:	6879      	ldr	r1, [r7, #4]
     35a:	2030      	movs	r0, #48	; 0x30
     35c:	01d2      	lsls	r2, r2, #7
     35e:	188a      	adds	r2, r1, r2
     360:	18d3      	adds	r3, r2, r3
     362:	181b      	adds	r3, r3, r0
     364:	220f      	movs	r2, #15
     366:	18ba      	adds	r2, r7, r2
     368:	7812      	ldrb	r2, [r2, #0]
     36a:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     36c:	46c0      	nop			; (mov r8, r8)
     36e:	46bd      	mov	sp, r7
     370:	b005      	add	sp, #20
     372:	bd90      	pop	{r4, r7, pc}

00000374 <hri_port_write_PMUX_PMUXO_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXO_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
     374:	b590      	push	{r4, r7, lr}
     376:	b085      	sub	sp, #20
     378:	af00      	add	r7, sp, #0
     37a:	6078      	str	r0, [r7, #4]
     37c:	000c      	movs	r4, r1
     37e:	0010      	movs	r0, r2
     380:	0019      	movs	r1, r3
     382:	1cfb      	adds	r3, r7, #3
     384:	1c22      	adds	r2, r4, #0
     386:	701a      	strb	r2, [r3, #0]
     388:	1cbb      	adds	r3, r7, #2
     38a:	1c02      	adds	r2, r0, #0
     38c:	701a      	strb	r2, [r3, #0]
     38e:	1c7b      	adds	r3, r7, #1
     390:	1c0a      	adds	r2, r1, #0
     392:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     394:	1cfb      	adds	r3, r7, #3
     396:	7819      	ldrb	r1, [r3, #0]
     398:	1cbb      	adds	r3, r7, #2
     39a:	781a      	ldrb	r2, [r3, #0]
     39c:	230f      	movs	r3, #15
     39e:	18fb      	adds	r3, r7, r3
     3a0:	6878      	ldr	r0, [r7, #4]
     3a2:	2430      	movs	r4, #48	; 0x30
     3a4:	01c9      	lsls	r1, r1, #7
     3a6:	1841      	adds	r1, r0, r1
     3a8:	188a      	adds	r2, r1, r2
     3aa:	1912      	adds	r2, r2, r4
     3ac:	7812      	ldrb	r2, [r2, #0]
     3ae:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     3b0:	230f      	movs	r3, #15
     3b2:	18fb      	adds	r3, r7, r3
     3b4:	220f      	movs	r2, #15
     3b6:	18ba      	adds	r2, r7, r2
     3b8:	7812      	ldrb	r2, [r2, #0]
     3ba:	210f      	movs	r1, #15
     3bc:	400a      	ands	r2, r1
     3be:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXO(data);
     3c0:	1c7b      	adds	r3, r7, #1
     3c2:	781b      	ldrb	r3, [r3, #0]
     3c4:	011b      	lsls	r3, r3, #4
     3c6:	b2d9      	uxtb	r1, r3
     3c8:	230f      	movs	r3, #15
     3ca:	18fb      	adds	r3, r7, r3
     3cc:	220f      	movs	r2, #15
     3ce:	18ba      	adds	r2, r7, r2
     3d0:	7812      	ldrb	r2, [r2, #0]
     3d2:	430a      	orrs	r2, r1
     3d4:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3d6:	1cfb      	adds	r3, r7, #3
     3d8:	781a      	ldrb	r2, [r3, #0]
     3da:	1cbb      	adds	r3, r7, #2
     3dc:	781b      	ldrb	r3, [r3, #0]
     3de:	6879      	ldr	r1, [r7, #4]
     3e0:	2030      	movs	r0, #48	; 0x30
     3e2:	01d2      	lsls	r2, r2, #7
     3e4:	188a      	adds	r2, r1, r2
     3e6:	18d3      	adds	r3, r2, r3
     3e8:	181b      	adds	r3, r3, r0
     3ea:	220f      	movs	r2, #15
     3ec:	18ba      	adds	r2, r7, r2
     3ee:	7812      	ldrb	r2, [r2, #0]
     3f0:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     3f2:	46c0      	nop			; (mov r8, r8)
     3f4:	46bd      	mov	sp, r7
     3f6:	b005      	add	sp, #20
     3f8:	bd90      	pop	{r4, r7, pc}

000003fa <hri_port_write_PINCFG_PMUXEN_bit>:
	return (bool)tmp;
}

static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
     3fa:	b590      	push	{r4, r7, lr}
     3fc:	b085      	sub	sp, #20
     3fe:	af00      	add	r7, sp, #0
     400:	6078      	str	r0, [r7, #4]
     402:	000c      	movs	r4, r1
     404:	0010      	movs	r0, r2
     406:	0019      	movs	r1, r3
     408:	1cfb      	adds	r3, r7, #3
     40a:	1c22      	adds	r2, r4, #0
     40c:	701a      	strb	r2, [r3, #0]
     40e:	1cbb      	adds	r3, r7, #2
     410:	1c02      	adds	r2, r0, #0
     412:	701a      	strb	r2, [r3, #0]
     414:	1c7b      	adds	r3, r7, #1
     416:	1c0a      	adds	r2, r1, #0
     418:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     41a:	1cfb      	adds	r3, r7, #3
     41c:	7819      	ldrb	r1, [r3, #0]
     41e:	1cbb      	adds	r3, r7, #2
     420:	781a      	ldrb	r2, [r3, #0]
     422:	230f      	movs	r3, #15
     424:	18fb      	adds	r3, r7, r3
     426:	6878      	ldr	r0, [r7, #4]
     428:	2440      	movs	r4, #64	; 0x40
     42a:	01c9      	lsls	r1, r1, #7
     42c:	1841      	adds	r1, r0, r1
     42e:	188a      	adds	r2, r1, r2
     430:	1912      	adds	r2, r2, r4
     432:	7812      	ldrb	r2, [r2, #0]
     434:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     436:	230f      	movs	r3, #15
     438:	18fb      	adds	r3, r7, r3
     43a:	220f      	movs	r2, #15
     43c:	18ba      	adds	r2, r7, r2
     43e:	7812      	ldrb	r2, [r2, #0]
     440:	2101      	movs	r1, #1
     442:	438a      	bics	r2, r1
     444:	701a      	strb	r2, [r3, #0]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     446:	1c7b      	adds	r3, r7, #1
     448:	7819      	ldrb	r1, [r3, #0]
     44a:	230f      	movs	r3, #15
     44c:	18fb      	adds	r3, r7, r3
     44e:	220f      	movs	r2, #15
     450:	18ba      	adds	r2, r7, r2
     452:	7812      	ldrb	r2, [r2, #0]
     454:	430a      	orrs	r2, r1
     456:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     458:	1cfb      	adds	r3, r7, #3
     45a:	781a      	ldrb	r2, [r3, #0]
     45c:	1cbb      	adds	r3, r7, #2
     45e:	781b      	ldrb	r3, [r3, #0]
     460:	6879      	ldr	r1, [r7, #4]
     462:	2040      	movs	r0, #64	; 0x40
     464:	01d2      	lsls	r2, r2, #7
     466:	188a      	adds	r2, r1, r2
     468:	18d3      	adds	r3, r2, r3
     46a:	181b      	adds	r3, r3, r0
     46c:	220f      	movs	r2, #15
     46e:	18ba      	adds	r2, r7, r2
     470:	7812      	ldrb	r2, [r2, #0]
     472:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     474:	46c0      	nop			; (mov r8, r8)
     476:	46bd      	mov	sp, r7
     478:	b005      	add	sp, #20
     47a:	bd90      	pop	{r4, r7, pc}

0000047c <hri_port_set_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg ^= PORT_PINCFG_INEN;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_set_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
     47c:	b5b0      	push	{r4, r5, r7, lr}
     47e:	b082      	sub	sp, #8
     480:	af00      	add	r7, sp, #0
     482:	6078      	str	r0, [r7, #4]
     484:	0008      	movs	r0, r1
     486:	0011      	movs	r1, r2
     488:	1cfb      	adds	r3, r7, #3
     48a:	1c02      	adds	r2, r0, #0
     48c:	701a      	strb	r2, [r3, #0]
     48e:	1cbb      	adds	r3, r7, #2
     490:	1c0a      	adds	r2, r1, #0
     492:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     494:	1cfb      	adds	r3, r7, #3
     496:	781a      	ldrb	r2, [r3, #0]
     498:	1cbb      	adds	r3, r7, #2
     49a:	781b      	ldrb	r3, [r3, #0]
     49c:	1cf9      	adds	r1, r7, #3
     49e:	7808      	ldrb	r0, [r1, #0]
     4a0:	1cb9      	adds	r1, r7, #2
     4a2:	7809      	ldrb	r1, [r1, #0]
     4a4:	687c      	ldr	r4, [r7, #4]
     4a6:	2540      	movs	r5, #64	; 0x40
     4a8:	01c0      	lsls	r0, r0, #7
     4aa:	1820      	adds	r0, r4, r0
     4ac:	1841      	adds	r1, r0, r1
     4ae:	1949      	adds	r1, r1, r5
     4b0:	7809      	ldrb	r1, [r1, #0]
     4b2:	b2c9      	uxtb	r1, r1
     4b4:	2004      	movs	r0, #4
     4b6:	4301      	orrs	r1, r0
     4b8:	b2cc      	uxtb	r4, r1
     4ba:	6879      	ldr	r1, [r7, #4]
     4bc:	2040      	movs	r0, #64	; 0x40
     4be:	01d2      	lsls	r2, r2, #7
     4c0:	188a      	adds	r2, r1, r2
     4c2:	18d3      	adds	r3, r2, r3
     4c4:	181b      	adds	r3, r3, r0
     4c6:	1c22      	adds	r2, r4, #0
     4c8:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     4ca:	46c0      	nop			; (mov r8, r8)
     4cc:	46bd      	mov	sp, r7
     4ce:	b002      	add	sp, #8
     4d0:	bdb0      	pop	{r4, r5, r7, pc}

000004d2 <hri_port_clear_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
     4d2:	b5b0      	push	{r4, r5, r7, lr}
     4d4:	b082      	sub	sp, #8
     4d6:	af00      	add	r7, sp, #0
     4d8:	6078      	str	r0, [r7, #4]
     4da:	0008      	movs	r0, r1
     4dc:	0011      	movs	r1, r2
     4de:	1cfb      	adds	r3, r7, #3
     4e0:	1c02      	adds	r2, r0, #0
     4e2:	701a      	strb	r2, [r3, #0]
     4e4:	1cbb      	adds	r3, r7, #2
     4e6:	1c0a      	adds	r2, r1, #0
     4e8:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     4ea:	1cfb      	adds	r3, r7, #3
     4ec:	781a      	ldrb	r2, [r3, #0]
     4ee:	1cbb      	adds	r3, r7, #2
     4f0:	781b      	ldrb	r3, [r3, #0]
     4f2:	1cf9      	adds	r1, r7, #3
     4f4:	7808      	ldrb	r0, [r1, #0]
     4f6:	1cb9      	adds	r1, r7, #2
     4f8:	7809      	ldrb	r1, [r1, #0]
     4fa:	687c      	ldr	r4, [r7, #4]
     4fc:	2540      	movs	r5, #64	; 0x40
     4fe:	01c0      	lsls	r0, r0, #7
     500:	1820      	adds	r0, r4, r0
     502:	1841      	adds	r1, r0, r1
     504:	1949      	adds	r1, r1, r5
     506:	7809      	ldrb	r1, [r1, #0]
     508:	b2c9      	uxtb	r1, r1
     50a:	2004      	movs	r0, #4
     50c:	4381      	bics	r1, r0
     50e:	b2cc      	uxtb	r4, r1
     510:	6879      	ldr	r1, [r7, #4]
     512:	2040      	movs	r0, #64	; 0x40
     514:	01d2      	lsls	r2, r2, #7
     516:	188a      	adds	r2, r1, r2
     518:	18d3      	adds	r3, r2, r3
     51a:	181b      	adds	r3, r3, r0
     51c:	1c22      	adds	r2, r4, #0
     51e:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     520:	46c0      	nop			; (mov r8, r8)
     522:	46bd      	mov	sp, r7
     524:	b002      	add	sp, #8
     526:	bdb0      	pop	{r4, r5, r7, pc}

00000528 <hri_port_write_WRCONFIG_reg>:
	return ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
}

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
     528:	b580      	push	{r7, lr}
     52a:	b084      	sub	sp, #16
     52c:	af00      	add	r7, sp, #0
     52e:	60f8      	str	r0, [r7, #12]
     530:	607a      	str	r2, [r7, #4]
     532:	230b      	movs	r3, #11
     534:	18fb      	adds	r3, r7, r3
     536:	1c0a      	adds	r2, r1, #0
     538:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     53a:	230b      	movs	r3, #11
     53c:	18fb      	adds	r3, r7, r3
     53e:	781b      	ldrb	r3, [r3, #0]
     540:	68fa      	ldr	r2, [r7, #12]
     542:	01db      	lsls	r3, r3, #7
     544:	18d3      	adds	r3, r2, r3
     546:	3328      	adds	r3, #40	; 0x28
     548:	687a      	ldr	r2, [r7, #4]
     54a:	601a      	str	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     54c:	46c0      	nop			; (mov r8, r8)
     54e:	46bd      	mov	sp, r7
     550:	b004      	add	sp, #16
     552:	bd80      	pop	{r7, pc}

00000554 <_gpio_set_direction>:
/**
 * \brief Set direction on port with mask
 */
static inline void _gpio_set_direction(const enum gpio_port port, const uint32_t mask,
                                       const enum gpio_direction direction)
{
     554:	b580      	push	{r7, lr}
     556:	b082      	sub	sp, #8
     558:	af00      	add	r7, sp, #0
     55a:	6039      	str	r1, [r7, #0]
     55c:	0011      	movs	r1, r2
     55e:	1dfb      	adds	r3, r7, #7
     560:	1c02      	adds	r2, r0, #0
     562:	701a      	strb	r2, [r3, #0]
     564:	1dbb      	adds	r3, r7, #6
     566:	1c0a      	adds	r2, r1, #0
     568:	701a      	strb	r2, [r3, #0]
	switch (direction) {
     56a:	1dbb      	adds	r3, r7, #6
     56c:	781b      	ldrb	r3, [r3, #0]
     56e:	2b01      	cmp	r3, #1
     570:	d025      	beq.n	5be <_gpio_set_direction+0x6a>
     572:	2b02      	cmp	r3, #2
     574:	d043      	beq.n	5fe <_gpio_set_direction+0xaa>
     576:	2b00      	cmp	r3, #0
     578:	d163      	bne.n	642 <_gpio_set_direction+0xee>
	case GPIO_DIRECTION_OFF:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
     57a:	683a      	ldr	r2, [r7, #0]
     57c:	1dfb      	adds	r3, r7, #7
     57e:	7819      	ldrb	r1, [r3, #0]
     580:	23c0      	movs	r3, #192	; 0xc0
     582:	05db      	lsls	r3, r3, #23
     584:	0018      	movs	r0, r3
     586:	4b34      	ldr	r3, [pc, #208]	; (658 <_gpio_set_direction+0x104>)
     588:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
     58a:	683b      	ldr	r3, [r7, #0]
     58c:	041b      	lsls	r3, r3, #16
     58e:	0c1b      	lsrs	r3, r3, #16
     590:	2280      	movs	r2, #128	; 0x80
     592:	05d2      	lsls	r2, r2, #23
     594:	431a      	orrs	r2, r3
     596:	1dfb      	adds	r3, r7, #7
     598:	7819      	ldrb	r1, [r3, #0]
     59a:	2382      	movs	r3, #130	; 0x82
     59c:	05db      	lsls	r3, r3, #23
     59e:	0018      	movs	r0, r3
     5a0:	4b2e      	ldr	r3, [pc, #184]	; (65c <_gpio_set_direction+0x108>)
     5a2:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
     5a4:	683b      	ldr	r3, [r7, #0]
     5a6:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
     5a8:	22c0      	movs	r2, #192	; 0xc0
     5aa:	0612      	lsls	r2, r2, #24
     5ac:	431a      	orrs	r2, r3
     5ae:	1dfb      	adds	r3, r7, #7
     5b0:	7819      	ldrb	r1, [r3, #0]
     5b2:	2382      	movs	r3, #130	; 0x82
     5b4:	05db      	lsls	r3, r3, #23
     5b6:	0018      	movs	r0, r3
     5b8:	4b28      	ldr	r3, [pc, #160]	; (65c <_gpio_set_direction+0x108>)
     5ba:	4798      	blx	r3
		break;
     5bc:	e047      	b.n	64e <_gpio_set_direction+0xfa>

	case GPIO_DIRECTION_IN:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
     5be:	683a      	ldr	r2, [r7, #0]
     5c0:	1dfb      	adds	r3, r7, #7
     5c2:	7819      	ldrb	r1, [r3, #0]
     5c4:	23c0      	movs	r3, #192	; 0xc0
     5c6:	05db      	lsls	r3, r3, #23
     5c8:	0018      	movs	r0, r3
     5ca:	4b23      	ldr	r3, [pc, #140]	; (658 <_gpio_set_direction+0x104>)
     5cc:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
     5ce:	683b      	ldr	r3, [r7, #0]
     5d0:	041b      	lsls	r3, r3, #16
     5d2:	0c1b      	lsrs	r3, r3, #16
     5d4:	4a22      	ldr	r2, [pc, #136]	; (660 <_gpio_set_direction+0x10c>)
     5d6:	431a      	orrs	r2, r3
     5d8:	1dfb      	adds	r3, r7, #7
     5da:	7819      	ldrb	r1, [r3, #0]
     5dc:	2382      	movs	r3, #130	; 0x82
     5de:	05db      	lsls	r3, r3, #23
     5e0:	0018      	movs	r0, r3
     5e2:	4b1e      	ldr	r3, [pc, #120]	; (65c <_gpio_set_direction+0x108>)
     5e4:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT,
		                            port,
		                            PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN
		                                | ((mask & 0xffff0000) >> 16));
     5e6:	683b      	ldr	r3, [r7, #0]
     5e8:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
     5ea:	4a1e      	ldr	r2, [pc, #120]	; (664 <_gpio_set_direction+0x110>)
     5ec:	431a      	orrs	r2, r3
     5ee:	1dfb      	adds	r3, r7, #7
     5f0:	7819      	ldrb	r1, [r3, #0]
     5f2:	2382      	movs	r3, #130	; 0x82
     5f4:	05db      	lsls	r3, r3, #23
     5f6:	0018      	movs	r0, r3
     5f8:	4b18      	ldr	r3, [pc, #96]	; (65c <_gpio_set_direction+0x108>)
     5fa:	4798      	blx	r3
		break;
     5fc:	e027      	b.n	64e <_gpio_set_direction+0xfa>

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT_IOBUS, port, mask);
     5fe:	683a      	ldr	r2, [r7, #0]
     600:	1dfb      	adds	r3, r7, #7
     602:	7819      	ldrb	r1, [r3, #0]
     604:	23c0      	movs	r3, #192	; 0xc0
     606:	05db      	lsls	r3, r3, #23
     608:	0018      	movs	r0, r3
     60a:	4b17      	ldr	r3, [pc, #92]	; (668 <_gpio_set_direction+0x114>)
     60c:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
     60e:	683b      	ldr	r3, [r7, #0]
     610:	041b      	lsls	r3, r3, #16
     612:	0c1b      	lsrs	r3, r3, #16
     614:	2280      	movs	r2, #128	; 0x80
     616:	05d2      	lsls	r2, r2, #23
     618:	431a      	orrs	r2, r3
     61a:	1dfb      	adds	r3, r7, #7
     61c:	7819      	ldrb	r1, [r3, #0]
     61e:	2382      	movs	r3, #130	; 0x82
     620:	05db      	lsls	r3, r3, #23
     622:	0018      	movs	r0, r3
     624:	4b0d      	ldr	r3, [pc, #52]	; (65c <_gpio_set_direction+0x108>)
     626:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
     628:	683b      	ldr	r3, [r7, #0]
     62a:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
     62c:	22c0      	movs	r2, #192	; 0xc0
     62e:	0612      	lsls	r2, r2, #24
     630:	431a      	orrs	r2, r3
     632:	1dfb      	adds	r3, r7, #7
     634:	7819      	ldrb	r1, [r3, #0]
     636:	2382      	movs	r3, #130	; 0x82
     638:	05db      	lsls	r3, r3, #23
     63a:	0018      	movs	r0, r3
     63c:	4b07      	ldr	r3, [pc, #28]	; (65c <_gpio_set_direction+0x108>)
     63e:	4798      	blx	r3
		break;
     640:	e005      	b.n	64e <_gpio_set_direction+0xfa>

	default:
		ASSERT(false);
     642:	4b0a      	ldr	r3, [pc, #40]	; (66c <_gpio_set_direction+0x118>)
     644:	2246      	movs	r2, #70	; 0x46
     646:	0019      	movs	r1, r3
     648:	2000      	movs	r0, #0
     64a:	4b09      	ldr	r3, [pc, #36]	; (670 <_gpio_set_direction+0x11c>)
     64c:	4798      	blx	r3
	}
}
     64e:	46c0      	nop			; (mov r8, r8)
     650:	46bd      	mov	sp, r7
     652:	b002      	add	sp, #8
     654:	bd80      	pop	{r7, pc}
     656:	46c0      	nop			; (mov r8, r8)
     658:	00000269 	.word	0x00000269
     65c:	00000529 	.word	0x00000529
     660:	40020000 	.word	0x40020000
     664:	c0020000 	.word	0xc0020000
     668:	0000023d 	.word	0x0000023d
     66c:	00005ddc 	.word	0x00005ddc
     670:	00001331 	.word	0x00001331

00000674 <_gpio_set_level>:

/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
     674:	b580      	push	{r7, lr}
     676:	b082      	sub	sp, #8
     678:	af00      	add	r7, sp, #0
     67a:	6039      	str	r1, [r7, #0]
     67c:	0011      	movs	r1, r2
     67e:	1dfb      	adds	r3, r7, #7
     680:	1c02      	adds	r2, r0, #0
     682:	701a      	strb	r2, [r3, #0]
     684:	1dbb      	adds	r3, r7, #6
     686:	1c0a      	adds	r2, r1, #0
     688:	701a      	strb	r2, [r3, #0]
	if (level) {
     68a:	1dbb      	adds	r3, r7, #6
     68c:	781b      	ldrb	r3, [r3, #0]
     68e:	2b00      	cmp	r3, #0
     690:	d008      	beq.n	6a4 <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
     692:	683a      	ldr	r2, [r7, #0]
     694:	1dfb      	adds	r3, r7, #7
     696:	7819      	ldrb	r1, [r3, #0]
     698:	23c0      	movs	r3, #192	; 0xc0
     69a:	05db      	lsls	r3, r3, #23
     69c:	0018      	movs	r0, r3
     69e:	4b07      	ldr	r3, [pc, #28]	; (6bc <_gpio_set_level+0x48>)
     6a0:	4798      	blx	r3
	} else {
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
	}
}
     6a2:	e007      	b.n	6b4 <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
     6a4:	683a      	ldr	r2, [r7, #0]
     6a6:	1dfb      	adds	r3, r7, #7
     6a8:	7819      	ldrb	r1, [r3, #0]
     6aa:	23c0      	movs	r3, #192	; 0xc0
     6ac:	05db      	lsls	r3, r3, #23
     6ae:	0018      	movs	r0, r3
     6b0:	4b03      	ldr	r3, [pc, #12]	; (6c0 <_gpio_set_level+0x4c>)
     6b2:	4798      	blx	r3
}
     6b4:	46c0      	nop			; (mov r8, r8)
     6b6:	46bd      	mov	sp, r7
     6b8:	b002      	add	sp, #8
     6ba:	bd80      	pop	{r7, pc}
     6bc:	00000295 	.word	0x00000295
     6c0:	000002c1 	.word	0x000002c1

000006c4 <_gpio_set_pin_pull_mode>:
/**
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
     6c4:	b590      	push	{r4, r7, lr}
     6c6:	b083      	sub	sp, #12
     6c8:	af00      	add	r7, sp, #0
     6ca:	0004      	movs	r4, r0
     6cc:	0008      	movs	r0, r1
     6ce:	0011      	movs	r1, r2
     6d0:	1dfb      	adds	r3, r7, #7
     6d2:	1c22      	adds	r2, r4, #0
     6d4:	701a      	strb	r2, [r3, #0]
     6d6:	1dbb      	adds	r3, r7, #6
     6d8:	1c02      	adds	r2, r0, #0
     6da:	701a      	strb	r2, [r3, #0]
     6dc:	1d7b      	adds	r3, r7, #5
     6de:	1c0a      	adds	r2, r1, #0
     6e0:	701a      	strb	r2, [r3, #0]
	switch (pull_mode) {
     6e2:	1d7b      	adds	r3, r7, #5
     6e4:	781b      	ldrb	r3, [r3, #0]
     6e6:	2b01      	cmp	r3, #1
     6e8:	d00d      	beq.n	706 <_gpio_set_pin_pull_mode+0x42>
     6ea:	2b02      	cmp	r3, #2
     6ec:	d02b      	beq.n	746 <_gpio_set_pin_pull_mode+0x82>
     6ee:	2b00      	cmp	r3, #0
     6f0:	d149      	bne.n	786 <_gpio_set_pin_pull_mode+0xc2>
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
     6f2:	1dbb      	adds	r3, r7, #6
     6f4:	781a      	ldrb	r2, [r3, #0]
     6f6:	1dfb      	adds	r3, r7, #7
     6f8:	7819      	ldrb	r1, [r3, #0]
     6fa:	2382      	movs	r3, #130	; 0x82
     6fc:	05db      	lsls	r3, r3, #23
     6fe:	0018      	movs	r0, r3
     700:	4b26      	ldr	r3, [pc, #152]	; (79c <_gpio_set_pin_pull_mode+0xd8>)
     702:	4798      	blx	r3
		break;
     704:	e046      	b.n	794 <_gpio_set_pin_pull_mode+0xd0>

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
     706:	1dbb      	adds	r3, r7, #6
     708:	781b      	ldrb	r3, [r3, #0]
     70a:	2201      	movs	r2, #1
     70c:	409a      	lsls	r2, r3
     70e:	1dfb      	adds	r3, r7, #7
     710:	7819      	ldrb	r1, [r3, #0]
     712:	23c0      	movs	r3, #192	; 0xc0
     714:	05db      	lsls	r3, r3, #23
     716:	0018      	movs	r0, r3
     718:	4b21      	ldr	r3, [pc, #132]	; (7a0 <_gpio_set_pin_pull_mode+0xdc>)
     71a:	4798      	blx	r3
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
     71c:	1dbb      	adds	r3, r7, #6
     71e:	781a      	ldrb	r2, [r3, #0]
     720:	1dfb      	adds	r3, r7, #7
     722:	7819      	ldrb	r1, [r3, #0]
     724:	2382      	movs	r3, #130	; 0x82
     726:	05db      	lsls	r3, r3, #23
     728:	0018      	movs	r0, r3
     72a:	4b1e      	ldr	r3, [pc, #120]	; (7a4 <_gpio_set_pin_pull_mode+0xe0>)
     72c:	4798      	blx	r3
		hri_port_set_OUT_reg(PORT_IOBUS, port, 1U << pin);
     72e:	1dbb      	adds	r3, r7, #6
     730:	781b      	ldrb	r3, [r3, #0]
     732:	2201      	movs	r2, #1
     734:	409a      	lsls	r2, r3
     736:	1dfb      	adds	r3, r7, #7
     738:	7819      	ldrb	r1, [r3, #0]
     73a:	23c0      	movs	r3, #192	; 0xc0
     73c:	05db      	lsls	r3, r3, #23
     73e:	0018      	movs	r0, r3
     740:	4b19      	ldr	r3, [pc, #100]	; (7a8 <_gpio_set_pin_pull_mode+0xe4>)
     742:	4798      	blx	r3
		break;
     744:	e026      	b.n	794 <_gpio_set_pin_pull_mode+0xd0>

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
     746:	1dbb      	adds	r3, r7, #6
     748:	781b      	ldrb	r3, [r3, #0]
     74a:	2201      	movs	r2, #1
     74c:	409a      	lsls	r2, r3
     74e:	1dfb      	adds	r3, r7, #7
     750:	7819      	ldrb	r1, [r3, #0]
     752:	23c0      	movs	r3, #192	; 0xc0
     754:	05db      	lsls	r3, r3, #23
     756:	0018      	movs	r0, r3
     758:	4b11      	ldr	r3, [pc, #68]	; (7a0 <_gpio_set_pin_pull_mode+0xdc>)
     75a:	4798      	blx	r3
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
     75c:	1dbb      	adds	r3, r7, #6
     75e:	781a      	ldrb	r2, [r3, #0]
     760:	1dfb      	adds	r3, r7, #7
     762:	7819      	ldrb	r1, [r3, #0]
     764:	2382      	movs	r3, #130	; 0x82
     766:	05db      	lsls	r3, r3, #23
     768:	0018      	movs	r0, r3
     76a:	4b0e      	ldr	r3, [pc, #56]	; (7a4 <_gpio_set_pin_pull_mode+0xe0>)
     76c:	4798      	blx	r3
		hri_port_clear_OUT_reg(PORT_IOBUS, port, 1U << pin);
     76e:	1dbb      	adds	r3, r7, #6
     770:	781b      	ldrb	r3, [r3, #0]
     772:	2201      	movs	r2, #1
     774:	409a      	lsls	r2, r3
     776:	1dfb      	adds	r3, r7, #7
     778:	7819      	ldrb	r1, [r3, #0]
     77a:	23c0      	movs	r3, #192	; 0xc0
     77c:	05db      	lsls	r3, r3, #23
     77e:	0018      	movs	r0, r3
     780:	4b0a      	ldr	r3, [pc, #40]	; (7ac <_gpio_set_pin_pull_mode+0xe8>)
     782:	4798      	blx	r3
		break;
     784:	e006      	b.n	794 <_gpio_set_pin_pull_mode+0xd0>

	default:
		ASSERT(false);
     786:	4b0a      	ldr	r3, [pc, #40]	; (7b0 <_gpio_set_pin_pull_mode+0xec>)
     788:	2289      	movs	r2, #137	; 0x89
     78a:	0019      	movs	r1, r3
     78c:	2000      	movs	r0, #0
     78e:	4b09      	ldr	r3, [pc, #36]	; (7b4 <_gpio_set_pin_pull_mode+0xf0>)
     790:	4798      	blx	r3
		break;
     792:	46c0      	nop			; (mov r8, r8)
	}
}
     794:	46c0      	nop			; (mov r8, r8)
     796:	46bd      	mov	sp, r7
     798:	b003      	add	sp, #12
     79a:	bd90      	pop	{r4, r7, pc}
     79c:	000004d3 	.word	0x000004d3
     7a0:	00000269 	.word	0x00000269
     7a4:	0000047d 	.word	0x0000047d
     7a8:	00000295 	.word	0x00000295
     7ac:	000002c1 	.word	0x000002c1
     7b0:	00005ddc 	.word	0x00005ddc
     7b4:	00001331 	.word	0x00001331

000007b8 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
     7b8:	b590      	push	{r4, r7, lr}
     7ba:	b085      	sub	sp, #20
     7bc:	af00      	add	r7, sp, #0
     7be:	6078      	str	r0, [r7, #4]
     7c0:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
     7c2:	687b      	ldr	r3, [r7, #4]
     7c4:	095a      	lsrs	r2, r3, #5
     7c6:	230f      	movs	r3, #15
     7c8:	18fb      	adds	r3, r7, r3
     7ca:	701a      	strb	r2, [r3, #0]
	uint8_t pin  = GPIO_PIN(gpio);
     7cc:	687b      	ldr	r3, [r7, #4]
     7ce:	b2da      	uxtb	r2, r3
     7d0:	230e      	movs	r3, #14
     7d2:	18fb      	adds	r3, r7, r3
     7d4:	211f      	movs	r1, #31
     7d6:	400a      	ands	r2, r1
     7d8:	701a      	strb	r2, [r3, #0]

	if (function == GPIO_PIN_FUNCTION_OFF) {
     7da:	683b      	ldr	r3, [r7, #0]
     7dc:	3301      	adds	r3, #1
     7de:	d10b      	bne.n	7f8 <_gpio_set_pin_function+0x40>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
     7e0:	230e      	movs	r3, #14
     7e2:	18fb      	adds	r3, r7, r3
     7e4:	781a      	ldrb	r2, [r3, #0]
     7e6:	230f      	movs	r3, #15
     7e8:	18fb      	adds	r3, r7, r3
     7ea:	7819      	ldrb	r1, [r3, #0]
     7ec:	2382      	movs	r3, #130	; 0x82
     7ee:	05d8      	lsls	r0, r3, #23
     7f0:	2300      	movs	r3, #0
     7f2:	4c1b      	ldr	r4, [pc, #108]	; (860 <_gpio_set_pin_function+0xa8>)
     7f4:	47a0      	blx	r4
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
     7f6:	e02f      	b.n	858 <_gpio_set_pin_function+0xa0>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
     7f8:	230e      	movs	r3, #14
     7fa:	18fb      	adds	r3, r7, r3
     7fc:	781a      	ldrb	r2, [r3, #0]
     7fe:	230f      	movs	r3, #15
     800:	18fb      	adds	r3, r7, r3
     802:	7819      	ldrb	r1, [r3, #0]
     804:	2382      	movs	r3, #130	; 0x82
     806:	05d8      	lsls	r0, r3, #23
     808:	2301      	movs	r3, #1
     80a:	4c15      	ldr	r4, [pc, #84]	; (860 <_gpio_set_pin_function+0xa8>)
     80c:	47a0      	blx	r4
		if (pin & 1) {
     80e:	230e      	movs	r3, #14
     810:	18fb      	adds	r3, r7, r3
     812:	781b      	ldrb	r3, [r3, #0]
     814:	2201      	movs	r2, #1
     816:	4013      	ands	r3, r2
     818:	d00f      	beq.n	83a <_gpio_set_pin_function+0x82>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
     81a:	230e      	movs	r3, #14
     81c:	18fb      	adds	r3, r7, r3
     81e:	781b      	ldrb	r3, [r3, #0]
     820:	085b      	lsrs	r3, r3, #1
     822:	b2da      	uxtb	r2, r3
     824:	683b      	ldr	r3, [r7, #0]
     826:	b2dc      	uxtb	r4, r3
     828:	230f      	movs	r3, #15
     82a:	18fb      	adds	r3, r7, r3
     82c:	7819      	ldrb	r1, [r3, #0]
     82e:	2382      	movs	r3, #130	; 0x82
     830:	05d8      	lsls	r0, r3, #23
     832:	0023      	movs	r3, r4
     834:	4c0b      	ldr	r4, [pc, #44]	; (864 <_gpio_set_pin_function+0xac>)
     836:	47a0      	blx	r4
}
     838:	e00e      	b.n	858 <_gpio_set_pin_function+0xa0>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
     83a:	230e      	movs	r3, #14
     83c:	18fb      	adds	r3, r7, r3
     83e:	781b      	ldrb	r3, [r3, #0]
     840:	085b      	lsrs	r3, r3, #1
     842:	b2da      	uxtb	r2, r3
     844:	683b      	ldr	r3, [r7, #0]
     846:	b2dc      	uxtb	r4, r3
     848:	230f      	movs	r3, #15
     84a:	18fb      	adds	r3, r7, r3
     84c:	7819      	ldrb	r1, [r3, #0]
     84e:	2382      	movs	r3, #130	; 0x82
     850:	05d8      	lsls	r0, r3, #23
     852:	0023      	movs	r3, r4
     854:	4c04      	ldr	r4, [pc, #16]	; (868 <_gpio_set_pin_function+0xb0>)
     856:	47a0      	blx	r4
}
     858:	46c0      	nop			; (mov r8, r8)
     85a:	46bd      	mov	sp, r7
     85c:	b005      	add	sp, #20
     85e:	bd90      	pop	{r4, r7, pc}
     860:	000003fb 	.word	0x000003fb
     864:	00000375 	.word	0x00000375
     868:	000002ed 	.word	0x000002ed

0000086c <gpio_set_pin_pull_mode>:
 * \param[in] pull_mode GPIO_PULL_DOWN = Pull pin low with internal resistor
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
     86c:	b580      	push	{r7, lr}
     86e:	b082      	sub	sp, #8
     870:	af00      	add	r7, sp, #0
     872:	0002      	movs	r2, r0
     874:	1dfb      	adds	r3, r7, #7
     876:	701a      	strb	r2, [r3, #0]
     878:	1dbb      	adds	r3, r7, #6
     87a:	1c0a      	adds	r2, r1, #0
     87c:	701a      	strb	r2, [r3, #0]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
     87e:	1dfb      	adds	r3, r7, #7
     880:	781b      	ldrb	r3, [r3, #0]
     882:	095b      	lsrs	r3, r3, #5
     884:	b2d8      	uxtb	r0, r3
     886:	1dfb      	adds	r3, r7, #7
     888:	781b      	ldrb	r3, [r3, #0]
     88a:	221f      	movs	r2, #31
     88c:	4013      	ands	r3, r2
     88e:	b2d9      	uxtb	r1, r3
     890:	1dbb      	adds	r3, r7, #6
     892:	781b      	ldrb	r3, [r3, #0]
     894:	001a      	movs	r2, r3
     896:	4b03      	ldr	r3, [pc, #12]	; (8a4 <gpio_set_pin_pull_mode+0x38>)
     898:	4798      	blx	r3
}
     89a:	46c0      	nop			; (mov r8, r8)
     89c:	46bd      	mov	sp, r7
     89e:	b002      	add	sp, #8
     8a0:	bd80      	pop	{r7, pc}
     8a2:	46c0      	nop			; (mov r8, r8)
     8a4:	000006c5 	.word	0x000006c5

000008a8 <gpio_set_pin_function>:
 * \param[in] function  The pin function is given by a 32-bit wide bitfield
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
     8a8:	b580      	push	{r7, lr}
     8aa:	b082      	sub	sp, #8
     8ac:	af00      	add	r7, sp, #0
     8ae:	6078      	str	r0, [r7, #4]
     8b0:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
     8b2:	683a      	ldr	r2, [r7, #0]
     8b4:	687b      	ldr	r3, [r7, #4]
     8b6:	0011      	movs	r1, r2
     8b8:	0018      	movs	r0, r3
     8ba:	4b03      	ldr	r3, [pc, #12]	; (8c8 <gpio_set_pin_function+0x20>)
     8bc:	4798      	blx	r3
}
     8be:	46c0      	nop			; (mov r8, r8)
     8c0:	46bd      	mov	sp, r7
     8c2:	b002      	add	sp, #8
     8c4:	bd80      	pop	{r7, pc}
     8c6:	46c0      	nop			; (mov r8, r8)
     8c8:	000007b9 	.word	0x000007b9

000008cc <gpio_set_pin_direction>:
 *                      GPIO_DIRECTION_OUT = Data direction out
 *                      GPIO_DIRECTION_OFF = Disables the pin
 *                      (low power state)
 */
static inline void gpio_set_pin_direction(const uint8_t pin, const enum gpio_direction direction)
{
     8cc:	b580      	push	{r7, lr}
     8ce:	b082      	sub	sp, #8
     8d0:	af00      	add	r7, sp, #0
     8d2:	0002      	movs	r2, r0
     8d4:	1dfb      	adds	r3, r7, #7
     8d6:	701a      	strb	r2, [r3, #0]
     8d8:	1dbb      	adds	r3, r7, #6
     8da:	1c0a      	adds	r2, r1, #0
     8dc:	701a      	strb	r2, [r3, #0]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
     8de:	1dfb      	adds	r3, r7, #7
     8e0:	781b      	ldrb	r3, [r3, #0]
     8e2:	095b      	lsrs	r3, r3, #5
     8e4:	b2d8      	uxtb	r0, r3
     8e6:	1dfb      	adds	r3, r7, #7
     8e8:	781b      	ldrb	r3, [r3, #0]
     8ea:	221f      	movs	r2, #31
     8ec:	4013      	ands	r3, r2
     8ee:	2201      	movs	r2, #1
     8f0:	409a      	lsls	r2, r3
     8f2:	0011      	movs	r1, r2
     8f4:	1dbb      	adds	r3, r7, #6
     8f6:	781b      	ldrb	r3, [r3, #0]
     8f8:	001a      	movs	r2, r3
     8fa:	4b03      	ldr	r3, [pc, #12]	; (908 <gpio_set_pin_direction+0x3c>)
     8fc:	4798      	blx	r3
}
     8fe:	46c0      	nop			; (mov r8, r8)
     900:	46bd      	mov	sp, r7
     902:	b002      	add	sp, #8
     904:	bd80      	pop	{r7, pc}
     906:	46c0      	nop			; (mov r8, r8)
     908:	00000555 	.word	0x00000555

0000090c <gpio_set_pin_level>:
 * \param[in] pin       The pin number for device
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
     90c:	b580      	push	{r7, lr}
     90e:	b082      	sub	sp, #8
     910:	af00      	add	r7, sp, #0
     912:	0002      	movs	r2, r0
     914:	1dfb      	adds	r3, r7, #7
     916:	701a      	strb	r2, [r3, #0]
     918:	1dbb      	adds	r3, r7, #6
     91a:	1c0a      	adds	r2, r1, #0
     91c:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
     91e:	1dfb      	adds	r3, r7, #7
     920:	781b      	ldrb	r3, [r3, #0]
     922:	095b      	lsrs	r3, r3, #5
     924:	b2d8      	uxtb	r0, r3
     926:	1dfb      	adds	r3, r7, #7
     928:	781b      	ldrb	r3, [r3, #0]
     92a:	221f      	movs	r2, #31
     92c:	4013      	ands	r3, r2
     92e:	2201      	movs	r2, #1
     930:	409a      	lsls	r2, r3
     932:	0011      	movs	r1, r2
     934:	1dbb      	adds	r3, r7, #6
     936:	781b      	ldrb	r3, [r3, #0]
     938:	001a      	movs	r2, r3
     93a:	4b03      	ldr	r3, [pc, #12]	; (948 <gpio_set_pin_level+0x3c>)
     93c:	4798      	blx	r3
}
     93e:	46c0      	nop			; (mov r8, r8)
     940:	46bd      	mov	sp, r7
     942:	b002      	add	sp, #8
     944:	bd80      	pop	{r7, pc}
     946:	46c0      	nop			; (mov r8, r8)
     948:	00000675 	.word	0x00000675

0000094c <init_mcu>:
 * This function calls the various initialization functions.
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
     94c:	b580      	push	{r7, lr}
     94e:	af00      	add	r7, sp, #0
	_init_chip();
     950:	4b02      	ldr	r3, [pc, #8]	; (95c <init_mcu+0x10>)
     952:	4798      	blx	r3
}
     954:	46c0      	nop			; (mov r8, r8)
     956:	46bd      	mov	sp, r7
     958:	bd80      	pop	{r7, pc}
     95a:	46c0      	nop			; (mov r8, r8)
     95c:	00001b91 	.word	0x00001b91

00000960 <Battery_lvl_PORT_init>:
struct usart_sync_descriptor UART;

struct pwm_descriptor StepperDriver;

void Battery_lvl_PORT_init(void)
{
     960:	b580      	push	{r7, lr}
     962:	af00      	add	r7, sp, #0

	// Disable digital pin circuitry
	gpio_set_pin_direction(PB09, GPIO_DIRECTION_OFF);
     964:	2100      	movs	r1, #0
     966:	2029      	movs	r0, #41	; 0x29
     968:	4b04      	ldr	r3, [pc, #16]	; (97c <Battery_lvl_PORT_init+0x1c>)
     96a:	4798      	blx	r3

	gpio_set_pin_function(PB09, PINMUX_PB09B_ADC0_AIN3);
     96c:	4b04      	ldr	r3, [pc, #16]	; (980 <Battery_lvl_PORT_init+0x20>)
     96e:	0019      	movs	r1, r3
     970:	2029      	movs	r0, #41	; 0x29
     972:	4b04      	ldr	r3, [pc, #16]	; (984 <Battery_lvl_PORT_init+0x24>)
     974:	4798      	blx	r3
}
     976:	46c0      	nop			; (mov r8, r8)
     978:	46bd      	mov	sp, r7
     97a:	bd80      	pop	{r7, pc}
     97c:	000008cd 	.word	0x000008cd
     980:	00290001 	.word	0x00290001
     984:	000008a9 	.word	0x000008a9

00000988 <Battery_lvl_CLOCK_init>:

void Battery_lvl_CLOCK_init(void)
{
     988:	b580      	push	{r7, lr}
     98a:	af00      	add	r7, sp, #0
	hri_mclk_set_APBCMASK_ADC0_bit(MCLK);
     98c:	4b06      	ldr	r3, [pc, #24]	; (9a8 <Battery_lvl_CLOCK_init+0x20>)
     98e:	0018      	movs	r0, r3
     990:	4b06      	ldr	r3, [pc, #24]	; (9ac <Battery_lvl_CLOCK_init+0x24>)
     992:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC0_GCLK_ID, CONF_GCLK_ADC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     994:	4b06      	ldr	r3, [pc, #24]	; (9b0 <Battery_lvl_CLOCK_init+0x28>)
     996:	2240      	movs	r2, #64	; 0x40
     998:	2121      	movs	r1, #33	; 0x21
     99a:	0018      	movs	r0, r3
     99c:	4b05      	ldr	r3, [pc, #20]	; (9b4 <Battery_lvl_CLOCK_init+0x2c>)
     99e:	4798      	blx	r3
}
     9a0:	46c0      	nop			; (mov r8, r8)
     9a2:	46bd      	mov	sp, r7
     9a4:	bd80      	pop	{r7, pc}
     9a6:	46c0      	nop			; (mov r8, r8)
     9a8:	40000800 	.word	0x40000800
     9ac:	0000021f 	.word	0x0000021f
     9b0:	40001c00 	.word	0x40001c00
     9b4:	000001bb 	.word	0x000001bb

000009b8 <Battery_lvl_init>:

void Battery_lvl_init(void)
{
     9b8:	b580      	push	{r7, lr}
     9ba:	af00      	add	r7, sp, #0
	Battery_lvl_CLOCK_init();
     9bc:	4b07      	ldr	r3, [pc, #28]	; (9dc <Battery_lvl_init+0x24>)
     9be:	4798      	blx	r3
	Battery_lvl_PORT_init();
     9c0:	4b07      	ldr	r3, [pc, #28]	; (9e0 <Battery_lvl_init+0x28>)
     9c2:	4798      	blx	r3
	adc_sync_init(&Battery_lvl, ADC0, _adc_get_adc_sync());
     9c4:	4b07      	ldr	r3, [pc, #28]	; (9e4 <Battery_lvl_init+0x2c>)
     9c6:	4798      	blx	r3
     9c8:	0002      	movs	r2, r0
     9ca:	4907      	ldr	r1, [pc, #28]	; (9e8 <Battery_lvl_init+0x30>)
     9cc:	4b07      	ldr	r3, [pc, #28]	; (9ec <Battery_lvl_init+0x34>)
     9ce:	0018      	movs	r0, r3
     9d0:	4b07      	ldr	r3, [pc, #28]	; (9f0 <Battery_lvl_init+0x38>)
     9d2:	4798      	blx	r3
}
     9d4:	46c0      	nop			; (mov r8, r8)
     9d6:	46bd      	mov	sp, r7
     9d8:	bd80      	pop	{r7, pc}
     9da:	46c0      	nop			; (mov r8, r8)
     9dc:	00000989 	.word	0x00000989
     9e0:	00000961 	.word	0x00000961
     9e4:	00001b61 	.word	0x00001b61
     9e8:	42004400 	.word	0x42004400
     9ec:	2000274c 	.word	0x2000274c
     9f0:	00000bd5 	.word	0x00000bd5

000009f4 <UART_PORT_init>:

void UART_PORT_init(void)
{
     9f4:	b580      	push	{r7, lr}
     9f6:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PA22, PINMUX_PA22C_SERCOM3_PAD0);
     9f8:	4b06      	ldr	r3, [pc, #24]	; (a14 <UART_PORT_init+0x20>)
     9fa:	0019      	movs	r1, r3
     9fc:	2016      	movs	r0, #22
     9fe:	4b06      	ldr	r3, [pc, #24]	; (a18 <UART_PORT_init+0x24>)
     a00:	4798      	blx	r3

	gpio_set_pin_function(PA23, PINMUX_PA23C_SERCOM3_PAD1);
     a02:	4b06      	ldr	r3, [pc, #24]	; (a1c <UART_PORT_init+0x28>)
     a04:	0019      	movs	r1, r3
     a06:	2017      	movs	r0, #23
     a08:	4b03      	ldr	r3, [pc, #12]	; (a18 <UART_PORT_init+0x24>)
     a0a:	4798      	blx	r3
}
     a0c:	46c0      	nop			; (mov r8, r8)
     a0e:	46bd      	mov	sp, r7
     a10:	bd80      	pop	{r7, pc}
     a12:	46c0      	nop			; (mov r8, r8)
     a14:	00160002 	.word	0x00160002
     a18:	000008a9 	.word	0x000008a9
     a1c:	00170002 	.word	0x00170002

00000a20 <UART_CLOCK_init>:

void UART_CLOCK_init(void)
{
     a20:	b580      	push	{r7, lr}
     a22:	af00      	add	r7, sp, #0
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     a24:	4b09      	ldr	r3, [pc, #36]	; (a4c <UART_CLOCK_init+0x2c>)
     a26:	2240      	movs	r2, #64	; 0x40
     a28:	2116      	movs	r1, #22
     a2a:	0018      	movs	r0, r3
     a2c:	4b08      	ldr	r3, [pc, #32]	; (a50 <UART_CLOCK_init+0x30>)
     a2e:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     a30:	4b06      	ldr	r3, [pc, #24]	; (a4c <UART_CLOCK_init+0x2c>)
     a32:	2242      	movs	r2, #66	; 0x42
     a34:	2112      	movs	r1, #18
     a36:	0018      	movs	r0, r3
     a38:	4b05      	ldr	r3, [pc, #20]	; (a50 <UART_CLOCK_init+0x30>)
     a3a:	4798      	blx	r3
	hri_mclk_set_APBCMASK_SERCOM3_bit(MCLK);
     a3c:	4b05      	ldr	r3, [pc, #20]	; (a54 <UART_CLOCK_init+0x34>)
     a3e:	0018      	movs	r0, r3
     a40:	4b05      	ldr	r3, [pc, #20]	; (a58 <UART_CLOCK_init+0x38>)
     a42:	4798      	blx	r3
}
     a44:	46c0      	nop			; (mov r8, r8)
     a46:	46bd      	mov	sp, r7
     a48:	bd80      	pop	{r7, pc}
     a4a:	46c0      	nop			; (mov r8, r8)
     a4c:	40001c00 	.word	0x40001c00
     a50:	000001bb 	.word	0x000001bb
     a54:	40000800 	.word	0x40000800
     a58:	000001e5 	.word	0x000001e5

00000a5c <UART_init>:

void UART_init(void)
{
     a5c:	b580      	push	{r7, lr}
     a5e:	af00      	add	r7, sp, #0
	UART_CLOCK_init();
     a60:	4b06      	ldr	r3, [pc, #24]	; (a7c <UART_init+0x20>)
     a62:	4798      	blx	r3
	usart_sync_init(&UART, SERCOM3, (void *)NULL);
     a64:	4906      	ldr	r1, [pc, #24]	; (a80 <UART_init+0x24>)
     a66:	4b07      	ldr	r3, [pc, #28]	; (a84 <UART_init+0x28>)
     a68:	2200      	movs	r2, #0
     a6a:	0018      	movs	r0, r3
     a6c:	4b06      	ldr	r3, [pc, #24]	; (a88 <UART_init+0x2c>)
     a6e:	4798      	blx	r3
	UART_PORT_init();
     a70:	4b06      	ldr	r3, [pc, #24]	; (a8c <UART_init+0x30>)
     a72:	4798      	blx	r3
}
     a74:	46c0      	nop			; (mov r8, r8)
     a76:	46bd      	mov	sp, r7
     a78:	bd80      	pop	{r7, pc}
     a7a:	46c0      	nop			; (mov r8, r8)
     a7c:	00000a21 	.word	0x00000a21
     a80:	42001000 	.word	0x42001000
     a84:	20002740 	.word	0x20002740
     a88:	00001089 	.word	0x00001089
     a8c:	000009f5 	.word	0x000009f5

00000a90 <StepperDriver_PORT_init>:

void StepperDriver_PORT_init(void)
{
     a90:	b580      	push	{r7, lr}
     a92:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PB12, PINMUX_PB12E_TC0_WO0);
     a94:	4b06      	ldr	r3, [pc, #24]	; (ab0 <StepperDriver_PORT_init+0x20>)
     a96:	0019      	movs	r1, r3
     a98:	202c      	movs	r0, #44	; 0x2c
     a9a:	4b06      	ldr	r3, [pc, #24]	; (ab4 <StepperDriver_PORT_init+0x24>)
     a9c:	4798      	blx	r3

	gpio_set_pin_function(PB13, PINMUX_PB13E_TC0_WO1);
     a9e:	4b06      	ldr	r3, [pc, #24]	; (ab8 <StepperDriver_PORT_init+0x28>)
     aa0:	0019      	movs	r1, r3
     aa2:	202d      	movs	r0, #45	; 0x2d
     aa4:	4b03      	ldr	r3, [pc, #12]	; (ab4 <StepperDriver_PORT_init+0x24>)
     aa6:	4798      	blx	r3
}
     aa8:	46c0      	nop			; (mov r8, r8)
     aaa:	46bd      	mov	sp, r7
     aac:	bd80      	pop	{r7, pc}
     aae:	46c0      	nop			; (mov r8, r8)
     ab0:	002c0004 	.word	0x002c0004
     ab4:	000008a9 	.word	0x000008a9
     ab8:	002d0004 	.word	0x002d0004

00000abc <StepperDriver_CLOCK_init>:

void StepperDriver_CLOCK_init(void)
{
     abc:	b580      	push	{r7, lr}
     abe:	af00      	add	r7, sp, #0
	hri_mclk_set_APBCMASK_TC0_bit(MCLK);
     ac0:	4b06      	ldr	r3, [pc, #24]	; (adc <StepperDriver_CLOCK_init+0x20>)
     ac2:	0018      	movs	r0, r3
     ac4:	4b06      	ldr	r3, [pc, #24]	; (ae0 <StepperDriver_CLOCK_init+0x24>)
     ac6:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, TC0_GCLK_ID, CONF_GCLK_TC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     ac8:	4b06      	ldr	r3, [pc, #24]	; (ae4 <StepperDriver_CLOCK_init+0x28>)
     aca:	2240      	movs	r2, #64	; 0x40
     acc:	211e      	movs	r1, #30
     ace:	0018      	movs	r0, r3
     ad0:	4b05      	ldr	r3, [pc, #20]	; (ae8 <StepperDriver_CLOCK_init+0x2c>)
     ad2:	4798      	blx	r3
}
     ad4:	46c0      	nop			; (mov r8, r8)
     ad6:	46bd      	mov	sp, r7
     ad8:	bd80      	pop	{r7, pc}
     ada:	46c0      	nop			; (mov r8, r8)
     adc:	40000800 	.word	0x40000800
     ae0:	00000201 	.word	0x00000201
     ae4:	40001c00 	.word	0x40001c00
     ae8:	000001bb 	.word	0x000001bb

00000aec <StepperDriver_init>:

void StepperDriver_init(void)
{
     aec:	b580      	push	{r7, lr}
     aee:	af00      	add	r7, sp, #0
	StepperDriver_CLOCK_init();
     af0:	4b07      	ldr	r3, [pc, #28]	; (b10 <StepperDriver_init+0x24>)
     af2:	4798      	blx	r3
	StepperDriver_PORT_init();
     af4:	4b07      	ldr	r3, [pc, #28]	; (b14 <StepperDriver_init+0x28>)
     af6:	4798      	blx	r3
	pwm_init(&StepperDriver, TC0, _tc_get_pwm());
     af8:	4b07      	ldr	r3, [pc, #28]	; (b18 <StepperDriver_init+0x2c>)
     afa:	4798      	blx	r3
     afc:	0002      	movs	r2, r0
     afe:	4907      	ldr	r1, [pc, #28]	; (b1c <StepperDriver_init+0x30>)
     b00:	4b07      	ldr	r3, [pc, #28]	; (b20 <StepperDriver_init+0x34>)
     b02:	0018      	movs	r0, r3
     b04:	4b07      	ldr	r3, [pc, #28]	; (b24 <StepperDriver_init+0x38>)
     b06:	4798      	blx	r3
}
     b08:	46c0      	nop			; (mov r8, r8)
     b0a:	46bd      	mov	sp, r7
     b0c:	bd80      	pop	{r7, pc}
     b0e:	46c0      	nop			; (mov r8, r8)
     b10:	00000abd 	.word	0x00000abd
     b14:	00000a91 	.word	0x00000a91
     b18:	00002cd9 	.word	0x00002cd9
     b1c:	42003000 	.word	0x42003000
     b20:	20002750 	.word	0x20002750
     b24:	00000eed 	.word	0x00000eed

00000b28 <system_init>:

void system_init(void)
{
     b28:	b580      	push	{r7, lr}
     b2a:	af00      	add	r7, sp, #0
	init_mcu();
     b2c:	4b21      	ldr	r3, [pc, #132]	; (bb4 <system_init+0x8c>)
     b2e:	4798      	blx	r3

	// GPIO on PA20

	// Set pin direction to input
	gpio_set_pin_direction(up, GPIO_DIRECTION_IN);
     b30:	2101      	movs	r1, #1
     b32:	2014      	movs	r0, #20
     b34:	4b20      	ldr	r3, [pc, #128]	; (bb8 <system_init+0x90>)
     b36:	4798      	blx	r3

	gpio_set_pin_pull_mode(up,
     b38:	2101      	movs	r1, #1
     b3a:	2014      	movs	r0, #20
     b3c:	4b1f      	ldr	r3, [pc, #124]	; (bbc <system_init+0x94>)
     b3e:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_UP);

	gpio_set_pin_function(up, GPIO_PIN_FUNCTION_OFF);
     b40:	2301      	movs	r3, #1
     b42:	425b      	negs	r3, r3
     b44:	0019      	movs	r1, r3
     b46:	2014      	movs	r0, #20
     b48:	4b1d      	ldr	r3, [pc, #116]	; (bc0 <system_init+0x98>)
     b4a:	4798      	blx	r3

	// GPIO on PA21

	// Set pin direction to input
	gpio_set_pin_direction(down, GPIO_DIRECTION_IN);
     b4c:	2101      	movs	r1, #1
     b4e:	2015      	movs	r0, #21
     b50:	4b19      	ldr	r3, [pc, #100]	; (bb8 <system_init+0x90>)
     b52:	4798      	blx	r3

	gpio_set_pin_pull_mode(down,
     b54:	2101      	movs	r1, #1
     b56:	2015      	movs	r0, #21
     b58:	4b18      	ldr	r3, [pc, #96]	; (bbc <system_init+0x94>)
     b5a:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_UP);

	gpio_set_pin_function(down, GPIO_PIN_FUNCTION_OFF);
     b5c:	2301      	movs	r3, #1
     b5e:	425b      	negs	r3, r3
     b60:	0019      	movs	r1, r3
     b62:	2015      	movs	r0, #21
     b64:	4b16      	ldr	r3, [pc, #88]	; (bc0 <system_init+0x98>)
     b66:	4798      	blx	r3

	// GPIO on PB14

	gpio_set_pin_level(Direction,
     b68:	2100      	movs	r1, #0
     b6a:	202e      	movs	r0, #46	; 0x2e
     b6c:	4b15      	ldr	r3, [pc, #84]	; (bc4 <system_init+0x9c>)
     b6e:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(Direction, GPIO_DIRECTION_OUT);
     b70:	2102      	movs	r1, #2
     b72:	202e      	movs	r0, #46	; 0x2e
     b74:	4b10      	ldr	r3, [pc, #64]	; (bb8 <system_init+0x90>)
     b76:	4798      	blx	r3

	gpio_set_pin_function(Direction, GPIO_PIN_FUNCTION_OFF);
     b78:	2301      	movs	r3, #1
     b7a:	425b      	negs	r3, r3
     b7c:	0019      	movs	r1, r3
     b7e:	202e      	movs	r0, #46	; 0x2e
     b80:	4b0f      	ldr	r3, [pc, #60]	; (bc0 <system_init+0x98>)
     b82:	4798      	blx	r3

	// GPIO on PB15

	gpio_set_pin_level(Motor_ON_OFF,
     b84:	2100      	movs	r1, #0
     b86:	202f      	movs	r0, #47	; 0x2f
     b88:	4b0e      	ldr	r3, [pc, #56]	; (bc4 <system_init+0x9c>)
     b8a:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(Motor_ON_OFF, GPIO_DIRECTION_OUT);
     b8c:	2102      	movs	r1, #2
     b8e:	202f      	movs	r0, #47	; 0x2f
     b90:	4b09      	ldr	r3, [pc, #36]	; (bb8 <system_init+0x90>)
     b92:	4798      	blx	r3

	gpio_set_pin_function(Motor_ON_OFF, GPIO_PIN_FUNCTION_OFF);
     b94:	2301      	movs	r3, #1
     b96:	425b      	negs	r3, r3
     b98:	0019      	movs	r1, r3
     b9a:	202f      	movs	r0, #47	; 0x2f
     b9c:	4b08      	ldr	r3, [pc, #32]	; (bc0 <system_init+0x98>)
     b9e:	4798      	blx	r3

	Battery_lvl_init();
     ba0:	4b09      	ldr	r3, [pc, #36]	; (bc8 <system_init+0xa0>)
     ba2:	4798      	blx	r3

	UART_init();
     ba4:	4b09      	ldr	r3, [pc, #36]	; (bcc <system_init+0xa4>)
     ba6:	4798      	blx	r3

	StepperDriver_init();
     ba8:	4b09      	ldr	r3, [pc, #36]	; (bd0 <system_init+0xa8>)
     baa:	4798      	blx	r3
}
     bac:	46c0      	nop			; (mov r8, r8)
     bae:	46bd      	mov	sp, r7
     bb0:	bd80      	pop	{r7, pc}
     bb2:	46c0      	nop			; (mov r8, r8)
     bb4:	0000094d 	.word	0x0000094d
     bb8:	000008cd 	.word	0x000008cd
     bbc:	0000086d 	.word	0x0000086d
     bc0:	000008a9 	.word	0x000008a9
     bc4:	0000090d 	.word	0x0000090d
     bc8:	000009b9 	.word	0x000009b9
     bcc:	00000a5d 	.word	0x00000a5d
     bd0:	00000aed 	.word	0x00000aed

00000bd4 <adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t adc_sync_init(struct adc_sync_descriptor *const descr, void *const hw, void *const func)
{
     bd4:	b580      	push	{r7, lr}
     bd6:	b084      	sub	sp, #16
     bd8:	af00      	add	r7, sp, #0
     bda:	60f8      	str	r0, [r7, #12]
     bdc:	60b9      	str	r1, [r7, #8]
     bde:	607a      	str	r2, [r7, #4]
	ASSERT(descr && hw);
     be0:	68fb      	ldr	r3, [r7, #12]
     be2:	2b00      	cmp	r3, #0
     be4:	d004      	beq.n	bf0 <adc_sync_init+0x1c>
     be6:	68bb      	ldr	r3, [r7, #8]
     be8:	2b00      	cmp	r3, #0
     bea:	d001      	beq.n	bf0 <adc_sync_init+0x1c>
     bec:	2301      	movs	r3, #1
     bee:	e000      	b.n	bf2 <adc_sync_init+0x1e>
     bf0:	2300      	movs	r3, #0
     bf2:	1c1a      	adds	r2, r3, #0
     bf4:	2301      	movs	r3, #1
     bf6:	4013      	ands	r3, r2
     bf8:	b2db      	uxtb	r3, r3
     bfa:	4908      	ldr	r1, [pc, #32]	; (c1c <adc_sync_init+0x48>)
     bfc:	2239      	movs	r2, #57	; 0x39
     bfe:	0018      	movs	r0, r3
     c00:	4b07      	ldr	r3, [pc, #28]	; (c20 <adc_sync_init+0x4c>)
     c02:	4798      	blx	r3

	return _adc_sync_init(&descr->device, hw);
     c04:	68fb      	ldr	r3, [r7, #12]
     c06:	68ba      	ldr	r2, [r7, #8]
     c08:	0011      	movs	r1, r2
     c0a:	0018      	movs	r0, r3
     c0c:	4b05      	ldr	r3, [pc, #20]	; (c24 <adc_sync_init+0x50>)
     c0e:	4798      	blx	r3
     c10:	0003      	movs	r3, r0
}
     c12:	0018      	movs	r0, r3
     c14:	46bd      	mov	sp, r7
     c16:	b004      	add	sp, #16
     c18:	bd80      	pop	{r7, pc}
     c1a:	46c0      	nop			; (mov r8, r8)
     c1c:	00005df8 	.word	0x00005df8
     c20:	00001331 	.word	0x00001331
     c24:	00001a29 	.word	0x00001a29

00000c28 <adc_sync_enable_channel>:

/**
 * \brief Enable ADC
 */
int32_t adc_sync_enable_channel(struct adc_sync_descriptor *const descr, const uint8_t channel)
{
     c28:	b580      	push	{r7, lr}
     c2a:	b082      	sub	sp, #8
     c2c:	af00      	add	r7, sp, #0
     c2e:	6078      	str	r0, [r7, #4]
     c30:	000a      	movs	r2, r1
     c32:	1cfb      	adds	r3, r7, #3
     c34:	701a      	strb	r2, [r3, #0]
	ASSERT(descr);
     c36:	687b      	ldr	r3, [r7, #4]
     c38:	1e5a      	subs	r2, r3, #1
     c3a:	4193      	sbcs	r3, r2
     c3c:	b2db      	uxtb	r3, r3
     c3e:	4908      	ldr	r1, [pc, #32]	; (c60 <adc_sync_enable_channel+0x38>)
     c40:	224e      	movs	r2, #78	; 0x4e
     c42:	0018      	movs	r0, r3
     c44:	4b07      	ldr	r3, [pc, #28]	; (c64 <adc_sync_enable_channel+0x3c>)
     c46:	4798      	blx	r3
	_adc_sync_enable_channel(&descr->device, channel);
     c48:	687a      	ldr	r2, [r7, #4]
     c4a:	1cfb      	adds	r3, r7, #3
     c4c:	781b      	ldrb	r3, [r3, #0]
     c4e:	0019      	movs	r1, r3
     c50:	0010      	movs	r0, r2
     c52:	4b05      	ldr	r3, [pc, #20]	; (c68 <adc_sync_enable_channel+0x40>)
     c54:	4798      	blx	r3

	return ERR_NONE;
     c56:	2300      	movs	r3, #0
}
     c58:	0018      	movs	r0, r3
     c5a:	46bd      	mov	sp, r7
     c5c:	b002      	add	sp, #8
     c5e:	bd80      	pop	{r7, pc}
     c60:	00005df8 	.word	0x00005df8
     c64:	00001331 	.word	0x00001331
     c68:	00001a7d 	.word	0x00001a7d

00000c6c <adc_sync_disable_channel>:

/**
 * \brief Disable ADC
 */
int32_t adc_sync_disable_channel(struct adc_sync_descriptor *const descr, const uint8_t channel)
{
     c6c:	b580      	push	{r7, lr}
     c6e:	b082      	sub	sp, #8
     c70:	af00      	add	r7, sp, #0
     c72:	6078      	str	r0, [r7, #4]
     c74:	000a      	movs	r2, r1
     c76:	1cfb      	adds	r3, r7, #3
     c78:	701a      	strb	r2, [r3, #0]
	ASSERT(descr);
     c7a:	687b      	ldr	r3, [r7, #4]
     c7c:	1e5a      	subs	r2, r3, #1
     c7e:	4193      	sbcs	r3, r2
     c80:	b2db      	uxtb	r3, r3
     c82:	4908      	ldr	r1, [pc, #32]	; (ca4 <adc_sync_disable_channel+0x38>)
     c84:	2259      	movs	r2, #89	; 0x59
     c86:	0018      	movs	r0, r3
     c88:	4b07      	ldr	r3, [pc, #28]	; (ca8 <adc_sync_disable_channel+0x3c>)
     c8a:	4798      	blx	r3
	_adc_sync_disable_channel(&descr->device, channel);
     c8c:	687a      	ldr	r2, [r7, #4]
     c8e:	1cfb      	adds	r3, r7, #3
     c90:	781b      	ldrb	r3, [r3, #0]
     c92:	0019      	movs	r1, r3
     c94:	0010      	movs	r0, r2
     c96:	4b05      	ldr	r3, [pc, #20]	; (cac <adc_sync_disable_channel+0x40>)
     c98:	4798      	blx	r3
	return ERR_NONE;
     c9a:	2300      	movs	r3, #0
}
     c9c:	0018      	movs	r0, r3
     c9e:	46bd      	mov	sp, r7
     ca0:	b002      	add	sp, #8
     ca2:	bd80      	pop	{r7, pc}
     ca4:	00005df8 	.word	0x00005df8
     ca8:	00001331 	.word	0x00001331
     cac:	00001aa1 	.word	0x00001aa1

00000cb0 <adc_sync_read_channel>:
/*
 * \brief Read data from ADC
 */
int32_t adc_sync_read_channel(struct adc_sync_descriptor *const descr, const uint8_t channel, uint8_t *const buffer,
                              const uint16_t length)
{
     cb0:	b590      	push	{r4, r7, lr}
     cb2:	b087      	sub	sp, #28
     cb4:	af00      	add	r7, sp, #0
     cb6:	60f8      	str	r0, [r7, #12]
     cb8:	0008      	movs	r0, r1
     cba:	607a      	str	r2, [r7, #4]
     cbc:	0019      	movs	r1, r3
     cbe:	230b      	movs	r3, #11
     cc0:	18fb      	adds	r3, r7, r3
     cc2:	1c02      	adds	r2, r0, #0
     cc4:	701a      	strb	r2, [r3, #0]
     cc6:	2308      	movs	r3, #8
     cc8:	18fb      	adds	r3, r7, r3
     cca:	1c0a      	adds	r2, r1, #0
     ccc:	801a      	strh	r2, [r3, #0]
	uint8_t  data_size;
	uint16_t offset = 0;
     cce:	2316      	movs	r3, #22
     cd0:	18fb      	adds	r3, r7, r3
     cd2:	2200      	movs	r2, #0
     cd4:	801a      	strh	r2, [r3, #0]

	ASSERT(descr && buffer && length);
     cd6:	68fb      	ldr	r3, [r7, #12]
     cd8:	2b00      	cmp	r3, #0
     cda:	d009      	beq.n	cf0 <adc_sync_read_channel+0x40>
     cdc:	687b      	ldr	r3, [r7, #4]
     cde:	2b00      	cmp	r3, #0
     ce0:	d006      	beq.n	cf0 <adc_sync_read_channel+0x40>
     ce2:	2308      	movs	r3, #8
     ce4:	18fb      	adds	r3, r7, r3
     ce6:	881b      	ldrh	r3, [r3, #0]
     ce8:	2b00      	cmp	r3, #0
     cea:	d001      	beq.n	cf0 <adc_sync_read_channel+0x40>
     cec:	2301      	movs	r3, #1
     cee:	e000      	b.n	cf2 <adc_sync_read_channel+0x42>
     cf0:	2300      	movs	r3, #0
     cf2:	1c1a      	adds	r2, r3, #0
     cf4:	2301      	movs	r3, #1
     cf6:	4013      	ands	r3, r2
     cf8:	b2db      	uxtb	r3, r3
     cfa:	493a      	ldr	r1, [pc, #232]	; (de4 <adc_sync_read_channel+0x134>)
     cfc:	2267      	movs	r2, #103	; 0x67
     cfe:	0018      	movs	r0, r3
     d00:	4b39      	ldr	r3, [pc, #228]	; (de8 <adc_sync_read_channel+0x138>)
     d02:	4798      	blx	r3
	data_size = _adc_sync_get_data_size(&descr->device);
     d04:	68fb      	ldr	r3, [r7, #12]
     d06:	2215      	movs	r2, #21
     d08:	18bc      	adds	r4, r7, r2
     d0a:	0018      	movs	r0, r3
     d0c:	4b37      	ldr	r3, [pc, #220]	; (dec <adc_sync_read_channel+0x13c>)
     d0e:	4798      	blx	r3
     d10:	0003      	movs	r3, r0
     d12:	7023      	strb	r3, [r4, #0]
	ASSERT(!(length % data_size));
     d14:	2308      	movs	r3, #8
     d16:	18fb      	adds	r3, r7, r3
     d18:	881a      	ldrh	r2, [r3, #0]
     d1a:	2315      	movs	r3, #21
     d1c:	18fb      	adds	r3, r7, r3
     d1e:	7819      	ldrb	r1, [r3, #0]
     d20:	4b33      	ldr	r3, [pc, #204]	; (df0 <adc_sync_read_channel+0x140>)
     d22:	0010      	movs	r0, r2
     d24:	4798      	blx	r3
     d26:	000b      	movs	r3, r1
     d28:	425a      	negs	r2, r3
     d2a:	4153      	adcs	r3, r2
     d2c:	b2db      	uxtb	r3, r3
     d2e:	492d      	ldr	r1, [pc, #180]	; (de4 <adc_sync_read_channel+0x134>)
     d30:	2269      	movs	r2, #105	; 0x69
     d32:	0018      	movs	r0, r3
     d34:	4b2c      	ldr	r3, [pc, #176]	; (de8 <adc_sync_read_channel+0x138>)
     d36:	4798      	blx	r3

	do {
		uint16_t result;
		_adc_sync_convert(&descr->device);
     d38:	68fb      	ldr	r3, [r7, #12]
     d3a:	0018      	movs	r0, r3
     d3c:	4b2d      	ldr	r3, [pc, #180]	; (df4 <adc_sync_read_channel+0x144>)
     d3e:	4798      	blx	r3

		while (!_adc_sync_is_channel_conversion_done(&descr->device, channel))
     d40:	46c0      	nop			; (mov r8, r8)
     d42:	68fa      	ldr	r2, [r7, #12]
     d44:	230b      	movs	r3, #11
     d46:	18fb      	adds	r3, r7, r3
     d48:	781b      	ldrb	r3, [r3, #0]
     d4a:	0019      	movs	r1, r3
     d4c:	0010      	movs	r0, r2
     d4e:	4b2a      	ldr	r3, [pc, #168]	; (df8 <adc_sync_read_channel+0x148>)
     d50:	4798      	blx	r3
     d52:	0003      	movs	r3, r0
     d54:	001a      	movs	r2, r3
     d56:	2301      	movs	r3, #1
     d58:	4053      	eors	r3, r2
     d5a:	b2db      	uxtb	r3, r3
     d5c:	2b00      	cmp	r3, #0
     d5e:	d1f0      	bne.n	d42 <adc_sync_read_channel+0x92>
			;

		result         = _adc_sync_read_channel_data(&descr->device, channel);
     d60:	68fa      	ldr	r2, [r7, #12]
     d62:	2312      	movs	r3, #18
     d64:	18fc      	adds	r4, r7, r3
     d66:	230b      	movs	r3, #11
     d68:	18fb      	adds	r3, r7, r3
     d6a:	781b      	ldrb	r3, [r3, #0]
     d6c:	0019      	movs	r1, r3
     d6e:	0010      	movs	r0, r2
     d70:	4b22      	ldr	r3, [pc, #136]	; (dfc <adc_sync_read_channel+0x14c>)
     d72:	4798      	blx	r3
     d74:	0003      	movs	r3, r0
     d76:	8023      	strh	r3, [r4, #0]
		buffer[offset] = result;
     d78:	2316      	movs	r3, #22
     d7a:	18fb      	adds	r3, r7, r3
     d7c:	881b      	ldrh	r3, [r3, #0]
     d7e:	687a      	ldr	r2, [r7, #4]
     d80:	18d3      	adds	r3, r2, r3
     d82:	2212      	movs	r2, #18
     d84:	18ba      	adds	r2, r7, r2
     d86:	8812      	ldrh	r2, [r2, #0]
     d88:	b2d2      	uxtb	r2, r2
     d8a:	701a      	strb	r2, [r3, #0]
		if (1 < data_size) {
     d8c:	2315      	movs	r3, #21
     d8e:	18fb      	adds	r3, r7, r3
     d90:	781b      	ldrb	r3, [r3, #0]
     d92:	2b01      	cmp	r3, #1
     d94:	d90c      	bls.n	db0 <adc_sync_read_channel+0x100>
			buffer[offset + 1] = result >> 8;
     d96:	2316      	movs	r3, #22
     d98:	18fb      	adds	r3, r7, r3
     d9a:	881b      	ldrh	r3, [r3, #0]
     d9c:	3301      	adds	r3, #1
     d9e:	687a      	ldr	r2, [r7, #4]
     da0:	18d3      	adds	r3, r2, r3
     da2:	2212      	movs	r2, #18
     da4:	18ba      	adds	r2, r7, r2
     da6:	8812      	ldrh	r2, [r2, #0]
     da8:	0a12      	lsrs	r2, r2, #8
     daa:	b292      	uxth	r2, r2
     dac:	b2d2      	uxtb	r2, r2
     dae:	701a      	strb	r2, [r3, #0]
		}
		offset += data_size;
     db0:	2315      	movs	r3, #21
     db2:	18fb      	adds	r3, r7, r3
     db4:	781b      	ldrb	r3, [r3, #0]
     db6:	b299      	uxth	r1, r3
     db8:	2316      	movs	r3, #22
     dba:	18fb      	adds	r3, r7, r3
     dbc:	2216      	movs	r2, #22
     dbe:	18ba      	adds	r2, r7, r2
     dc0:	8812      	ldrh	r2, [r2, #0]
     dc2:	188a      	adds	r2, r1, r2
     dc4:	801a      	strh	r2, [r3, #0]
	} while (offset < length);
     dc6:	2316      	movs	r3, #22
     dc8:	18fa      	adds	r2, r7, r3
     dca:	2308      	movs	r3, #8
     dcc:	18fb      	adds	r3, r7, r3
     dce:	8812      	ldrh	r2, [r2, #0]
     dd0:	881b      	ldrh	r3, [r3, #0]
     dd2:	429a      	cmp	r2, r3
     dd4:	d3b0      	bcc.n	d38 <adc_sync_read_channel+0x88>

	return offset;
     dd6:	2316      	movs	r3, #22
     dd8:	18fb      	adds	r3, r7, r3
     dda:	881b      	ldrh	r3, [r3, #0]
}
     ddc:	0018      	movs	r0, r3
     dde:	46bd      	mov	sp, r7
     de0:	b007      	add	sp, #28
     de2:	bd90      	pop	{r4, r7, pc}
     de4:	00005df8 	.word	0x00005df8
     de8:	00001331 	.word	0x00001331
     dec:	00001ac5 	.word	0x00001ac5
     df0:	00001cb1 	.word	0x00001cb1
     df4:	00001b19 	.word	0x00001b19
     df8:	00001af1 	.word	0x00001af1
     dfc:	00001b39 	.word	0x00001b39

00000e00 <atomic_enter_critical>:

/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
     e00:	b580      	push	{r7, lr}
     e02:	b084      	sub	sp, #16
     e04:	af00      	add	r7, sp, #0
     e06:	6078      	str	r0, [r7, #4]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     e08:	f3ef 8310 	mrs	r3, PRIMASK
     e0c:	60fb      	str	r3, [r7, #12]
  return(result);
     e0e:	68fa      	ldr	r2, [r7, #12]
	*atomic = __get_PRIMASK();
     e10:	687b      	ldr	r3, [r7, #4]
     e12:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     e14:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     e16:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
     e1a:	46c0      	nop			; (mov r8, r8)
     e1c:	46bd      	mov	sp, r7
     e1e:	b004      	add	sp, #16
     e20:	bd80      	pop	{r7, pc}

00000e22 <atomic_leave_critical>:

/**
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
     e22:	b580      	push	{r7, lr}
     e24:	b084      	sub	sp, #16
     e26:	af00      	add	r7, sp, #0
     e28:	6078      	str	r0, [r7, #4]
     e2a:	f3bf 8f5f 	dmb	sy
	__DMB();
	__set_PRIMASK(*atomic);
     e2e:	687b      	ldr	r3, [r7, #4]
     e30:	681b      	ldr	r3, [r3, #0]
     e32:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     e34:	68fb      	ldr	r3, [r7, #12]
     e36:	f383 8810 	msr	PRIMASK, r3
}
     e3a:	46c0      	nop			; (mov r8, r8)
     e3c:	46bd      	mov	sp, r7
     e3e:	b004      	add	sp, #16
     e40:	bd80      	pop	{r7, pc}
	...

00000e44 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     e44:	b580      	push	{r7, lr}
     e46:	b084      	sub	sp, #16
     e48:	af00      	add	r7, sp, #0
     e4a:	60f8      	str	r0, [r7, #12]
     e4c:	60b9      	str	r1, [r7, #8]
     e4e:	1dbb      	adds	r3, r7, #6
     e50:	801a      	strh	r2, [r3, #0]
	ASSERT(io_descr && buf);
     e52:	68fb      	ldr	r3, [r7, #12]
     e54:	2b00      	cmp	r3, #0
     e56:	d004      	beq.n	e62 <io_write+0x1e>
     e58:	68bb      	ldr	r3, [r7, #8]
     e5a:	2b00      	cmp	r3, #0
     e5c:	d001      	beq.n	e62 <io_write+0x1e>
     e5e:	2301      	movs	r3, #1
     e60:	e000      	b.n	e64 <io_write+0x20>
     e62:	2300      	movs	r3, #0
     e64:	1c1a      	adds	r2, r3, #0
     e66:	2301      	movs	r3, #1
     e68:	4013      	ands	r3, r2
     e6a:	b2db      	uxtb	r3, r3
     e6c:	4908      	ldr	r1, [pc, #32]	; (e90 <io_write+0x4c>)
     e6e:	2234      	movs	r2, #52	; 0x34
     e70:	0018      	movs	r0, r3
     e72:	4b08      	ldr	r3, [pc, #32]	; (e94 <io_write+0x50>)
     e74:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     e76:	68fb      	ldr	r3, [r7, #12]
     e78:	681b      	ldr	r3, [r3, #0]
     e7a:	1dba      	adds	r2, r7, #6
     e7c:	8812      	ldrh	r2, [r2, #0]
     e7e:	68b9      	ldr	r1, [r7, #8]
     e80:	68f8      	ldr	r0, [r7, #12]
     e82:	4798      	blx	r3
     e84:	0003      	movs	r3, r0
}
     e86:	0018      	movs	r0, r3
     e88:	46bd      	mov	sp, r7
     e8a:	b004      	add	sp, #16
     e8c:	bd80      	pop	{r7, pc}
     e8e:	46c0      	nop			; (mov r8, r8)
     e90:	00005e14 	.word	0x00005e14
     e94:	00001331 	.word	0x00001331

00000e98 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     e98:	b580      	push	{r7, lr}
     e9a:	b084      	sub	sp, #16
     e9c:	af00      	add	r7, sp, #0
     e9e:	60f8      	str	r0, [r7, #12]
     ea0:	60b9      	str	r1, [r7, #8]
     ea2:	1dbb      	adds	r3, r7, #6
     ea4:	801a      	strh	r2, [r3, #0]
	ASSERT(io_descr && buf);
     ea6:	68fb      	ldr	r3, [r7, #12]
     ea8:	2b00      	cmp	r3, #0
     eaa:	d004      	beq.n	eb6 <io_read+0x1e>
     eac:	68bb      	ldr	r3, [r7, #8]
     eae:	2b00      	cmp	r3, #0
     eb0:	d001      	beq.n	eb6 <io_read+0x1e>
     eb2:	2301      	movs	r3, #1
     eb4:	e000      	b.n	eb8 <io_read+0x20>
     eb6:	2300      	movs	r3, #0
     eb8:	1c1a      	adds	r2, r3, #0
     eba:	2301      	movs	r3, #1
     ebc:	4013      	ands	r3, r2
     ebe:	b2db      	uxtb	r3, r3
     ec0:	4908      	ldr	r1, [pc, #32]	; (ee4 <io_read+0x4c>)
     ec2:	223d      	movs	r2, #61	; 0x3d
     ec4:	0018      	movs	r0, r3
     ec6:	4b08      	ldr	r3, [pc, #32]	; (ee8 <io_read+0x50>)
     ec8:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
     eca:	68fb      	ldr	r3, [r7, #12]
     ecc:	685b      	ldr	r3, [r3, #4]
     ece:	1dba      	adds	r2, r7, #6
     ed0:	8812      	ldrh	r2, [r2, #0]
     ed2:	68b9      	ldr	r1, [r7, #8]
     ed4:	68f8      	ldr	r0, [r7, #12]
     ed6:	4798      	blx	r3
     ed8:	0003      	movs	r3, r0
}
     eda:	0018      	movs	r0, r3
     edc:	46bd      	mov	sp, r7
     ede:	b004      	add	sp, #16
     ee0:	bd80      	pop	{r7, pc}
     ee2:	46c0      	nop			; (mov r8, r8)
     ee4:	00005e14 	.word	0x00005e14
     ee8:	00001331 	.word	0x00001331

00000eec <pwm_init>:

/**
 * \brief Initialize pwm
 */
int32_t pwm_init(struct pwm_descriptor *const descr, void *const hw, struct _pwm_hpl_interface *const func)
{
     eec:	b580      	push	{r7, lr}
     eee:	b084      	sub	sp, #16
     ef0:	af00      	add	r7, sp, #0
     ef2:	60f8      	str	r0, [r7, #12]
     ef4:	60b9      	str	r1, [r7, #8]
     ef6:	607a      	str	r2, [r7, #4]
	ASSERT(descr && hw);
     ef8:	68fb      	ldr	r3, [r7, #12]
     efa:	2b00      	cmp	r3, #0
     efc:	d004      	beq.n	f08 <pwm_init+0x1c>
     efe:	68bb      	ldr	r3, [r7, #8]
     f00:	2b00      	cmp	r3, #0
     f02:	d001      	beq.n	f08 <pwm_init+0x1c>
     f04:	2301      	movs	r3, #1
     f06:	e000      	b.n	f0a <pwm_init+0x1e>
     f08:	2300      	movs	r3, #0
     f0a:	1c1a      	adds	r2, r3, #0
     f0c:	2301      	movs	r3, #1
     f0e:	4013      	ands	r3, r2
     f10:	b2db      	uxtb	r3, r3
     f12:	490b      	ldr	r1, [pc, #44]	; (f40 <pwm_init+0x54>)
     f14:	2233      	movs	r2, #51	; 0x33
     f16:	0018      	movs	r0, r3
     f18:	4b0a      	ldr	r3, [pc, #40]	; (f44 <pwm_init+0x58>)
     f1a:	4798      	blx	r3
	_pwm_init(&descr->device, hw);
     f1c:	68fb      	ldr	r3, [r7, #12]
     f1e:	68ba      	ldr	r2, [r7, #8]
     f20:	0011      	movs	r1, r2
     f22:	0018      	movs	r0, r3
     f24:	4b08      	ldr	r3, [pc, #32]	; (f48 <pwm_init+0x5c>)
     f26:	4798      	blx	r3
	descr->device.callback.pwm_period_cb = pwm_period_expired;
     f28:	68fb      	ldr	r3, [r7, #12]
     f2a:	4a08      	ldr	r2, [pc, #32]	; (f4c <pwm_init+0x60>)
     f2c:	601a      	str	r2, [r3, #0]
	descr->device.callback.pwm_error_cb  = pwm_detect_fault;
     f2e:	68fb      	ldr	r3, [r7, #12]
     f30:	4a07      	ldr	r2, [pc, #28]	; (f50 <pwm_init+0x64>)
     f32:	605a      	str	r2, [r3, #4]
	return ERR_NONE;
     f34:	2300      	movs	r3, #0
}
     f36:	0018      	movs	r0, r3
     f38:	46bd      	mov	sp, r7
     f3a:	b004      	add	sp, #16
     f3c:	bd80      	pop	{r7, pc}
     f3e:	46c0      	nop			; (mov r8, r8)
     f40:	00005e28 	.word	0x00005e28
     f44:	00001331 	.word	0x00001331
     f48:	000028f5 	.word	0x000028f5
     f4c:	0000103d 	.word	0x0000103d
     f50:	00001063 	.word	0x00001063

00000f54 <pwm_enable>:

/**
 * \brief Start pwm
 */
int32_t pwm_enable(struct pwm_descriptor *const descr)
{
     f54:	b580      	push	{r7, lr}
     f56:	b082      	sub	sp, #8
     f58:	af00      	add	r7, sp, #0
     f5a:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
     f5c:	687b      	ldr	r3, [r7, #4]
     f5e:	1e5a      	subs	r2, r3, #1
     f60:	4193      	sbcs	r3, r2
     f62:	b2db      	uxtb	r3, r3
     f64:	490b      	ldr	r1, [pc, #44]	; (f94 <pwm_enable+0x40>)
     f66:	224a      	movs	r2, #74	; 0x4a
     f68:	0018      	movs	r0, r3
     f6a:	4b0b      	ldr	r3, [pc, #44]	; (f98 <pwm_enable+0x44>)
     f6c:	4798      	blx	r3
	if (_pwm_is_enabled(&descr->device)) {
     f6e:	687b      	ldr	r3, [r7, #4]
     f70:	0018      	movs	r0, r3
     f72:	4b0a      	ldr	r3, [pc, #40]	; (f9c <pwm_enable+0x48>)
     f74:	4798      	blx	r3
     f76:	1e03      	subs	r3, r0, #0
     f78:	d002      	beq.n	f80 <pwm_enable+0x2c>
		return ERR_DENIED;
     f7a:	2311      	movs	r3, #17
     f7c:	425b      	negs	r3, r3
     f7e:	e004      	b.n	f8a <pwm_enable+0x36>
	}
	_pwm_enable(&descr->device);
     f80:	687b      	ldr	r3, [r7, #4]
     f82:	0018      	movs	r0, r3
     f84:	4b06      	ldr	r3, [pc, #24]	; (fa0 <pwm_enable+0x4c>)
     f86:	4798      	blx	r3

	return ERR_NONE;
     f88:	2300      	movs	r3, #0
}
     f8a:	0018      	movs	r0, r3
     f8c:	46bd      	mov	sp, r7
     f8e:	b002      	add	sp, #8
     f90:	bd80      	pop	{r7, pc}
     f92:	46c0      	nop			; (mov r8, r8)
     f94:	00005e28 	.word	0x00005e28
     f98:	00001331 	.word	0x00001331
     f9c:	00002cb9 	.word	0x00002cb9
     fa0:	00002b5d 	.word	0x00002b5d

00000fa4 <pwm_disable>:

/**
 * \brief Stop pwm
 */
int32_t pwm_disable(struct pwm_descriptor *const descr)
{
     fa4:	b580      	push	{r7, lr}
     fa6:	b082      	sub	sp, #8
     fa8:	af00      	add	r7, sp, #0
     faa:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
     fac:	687b      	ldr	r3, [r7, #4]
     fae:	1e5a      	subs	r2, r3, #1
     fb0:	4193      	sbcs	r3, r2
     fb2:	b2db      	uxtb	r3, r3
     fb4:	490d      	ldr	r1, [pc, #52]	; (fec <pwm_disable+0x48>)
     fb6:	2258      	movs	r2, #88	; 0x58
     fb8:	0018      	movs	r0, r3
     fba:	4b0d      	ldr	r3, [pc, #52]	; (ff0 <pwm_disable+0x4c>)
     fbc:	4798      	blx	r3
	if (!_pwm_is_enabled(&descr->device)) {
     fbe:	687b      	ldr	r3, [r7, #4]
     fc0:	0018      	movs	r0, r3
     fc2:	4b0c      	ldr	r3, [pc, #48]	; (ff4 <pwm_disable+0x50>)
     fc4:	4798      	blx	r3
     fc6:	0003      	movs	r3, r0
     fc8:	001a      	movs	r2, r3
     fca:	2301      	movs	r3, #1
     fcc:	4053      	eors	r3, r2
     fce:	b2db      	uxtb	r3, r3
     fd0:	2b00      	cmp	r3, #0
     fd2:	d002      	beq.n	fda <pwm_disable+0x36>
		return ERR_DENIED;
     fd4:	2311      	movs	r3, #17
     fd6:	425b      	negs	r3, r3
     fd8:	e004      	b.n	fe4 <pwm_disable+0x40>
	}
	_pwm_disable(&descr->device);
     fda:	687b      	ldr	r3, [r7, #4]
     fdc:	0018      	movs	r0, r3
     fde:	4b06      	ldr	r3, [pc, #24]	; (ff8 <pwm_disable+0x54>)
     fe0:	4798      	blx	r3

	return ERR_NONE;
     fe2:	2300      	movs	r3, #0
}
     fe4:	0018      	movs	r0, r3
     fe6:	46bd      	mov	sp, r7
     fe8:	b002      	add	sp, #8
     fea:	bd80      	pop	{r7, pc}
     fec:	00005e28 	.word	0x00005e28
     ff0:	00001331 	.word	0x00001331
     ff4:	00002cb9 	.word	0x00002cb9
     ff8:	00002b7d 	.word	0x00002b7d

00000ffc <pwm_set_parameters>:

/**
 * \brief Change PWM parameter
 */
int32_t pwm_set_parameters(struct pwm_descriptor *const descr, const pwm_period_t period, const pwm_period_t duty_cycle)
{
     ffc:	b580      	push	{r7, lr}
     ffe:	b084      	sub	sp, #16
    1000:	af00      	add	r7, sp, #0
    1002:	60f8      	str	r0, [r7, #12]
    1004:	60b9      	str	r1, [r7, #8]
    1006:	607a      	str	r2, [r7, #4]
	ASSERT(descr);
    1008:	68fb      	ldr	r3, [r7, #12]
    100a:	1e5a      	subs	r2, r3, #1
    100c:	4193      	sbcs	r3, r2
    100e:	b2db      	uxtb	r3, r3
    1010:	4907      	ldr	r1, [pc, #28]	; (1030 <pwm_set_parameters+0x34>)
    1012:	227c      	movs	r2, #124	; 0x7c
    1014:	0018      	movs	r0, r3
    1016:	4b07      	ldr	r3, [pc, #28]	; (1034 <pwm_set_parameters+0x38>)
    1018:	4798      	blx	r3
	_pwm_set_param(&descr->device, period, duty_cycle);
    101a:	68fb      	ldr	r3, [r7, #12]
    101c:	687a      	ldr	r2, [r7, #4]
    101e:	68b9      	ldr	r1, [r7, #8]
    1020:	0018      	movs	r0, r3
    1022:	4b05      	ldr	r3, [pc, #20]	; (1038 <pwm_set_parameters+0x3c>)
    1024:	4798      	blx	r3
	return ERR_NONE;
    1026:	2300      	movs	r3, #0
}
    1028:	0018      	movs	r0, r3
    102a:	46bd      	mov	sp, r7
    102c:	b004      	add	sp, #16
    102e:	bd80      	pop	{r7, pc}
    1030:	00005e28 	.word	0x00005e28
    1034:	00001331 	.word	0x00001331
    1038:	00002b9d 	.word	0x00002b9d

0000103c <pwm_period_expired>:

/**
 * \internal Process interrupts caused by period experied
 */
static void pwm_period_expired(struct _pwm_device *device)
{
    103c:	b580      	push	{r7, lr}
    103e:	b084      	sub	sp, #16
    1040:	af00      	add	r7, sp, #0
    1042:	6078      	str	r0, [r7, #4]
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);
    1044:	687b      	ldr	r3, [r7, #4]
    1046:	60fb      	str	r3, [r7, #12]

	if (descr->pwm_cb.period) {
    1048:	68fb      	ldr	r3, [r7, #12]
    104a:	695b      	ldr	r3, [r3, #20]
    104c:	2b00      	cmp	r3, #0
    104e:	d004      	beq.n	105a <pwm_period_expired+0x1e>
		descr->pwm_cb.period(descr);
    1050:	68fb      	ldr	r3, [r7, #12]
    1052:	695b      	ldr	r3, [r3, #20]
    1054:	68fa      	ldr	r2, [r7, #12]
    1056:	0010      	movs	r0, r2
    1058:	4798      	blx	r3
	}
}
    105a:	46c0      	nop			; (mov r8, r8)
    105c:	46bd      	mov	sp, r7
    105e:	b004      	add	sp, #16
    1060:	bd80      	pop	{r7, pc}

00001062 <pwm_detect_fault>:

/**
 * \internal Process interrupts caused by pwm fault
 */
static void pwm_detect_fault(struct _pwm_device *device)
{
    1062:	b580      	push	{r7, lr}
    1064:	b084      	sub	sp, #16
    1066:	af00      	add	r7, sp, #0
    1068:	6078      	str	r0, [r7, #4]
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);
    106a:	687b      	ldr	r3, [r7, #4]
    106c:	60fb      	str	r3, [r7, #12]

	if (descr->pwm_cb.error) {
    106e:	68fb      	ldr	r3, [r7, #12]
    1070:	699b      	ldr	r3, [r3, #24]
    1072:	2b00      	cmp	r3, #0
    1074:	d004      	beq.n	1080 <pwm_detect_fault+0x1e>
		descr->pwm_cb.error(descr);
    1076:	68fb      	ldr	r3, [r7, #12]
    1078:	699b      	ldr	r3, [r3, #24]
    107a:	68fa      	ldr	r2, [r7, #12]
    107c:	0010      	movs	r0, r2
    107e:	4798      	blx	r3
	}
}
    1080:	46c0      	nop			; (mov r8, r8)
    1082:	46bd      	mov	sp, r7
    1084:	b004      	add	sp, #16
    1086:	bd80      	pop	{r7, pc}

00001088 <usart_sync_init>:

/**
 * \brief Initialize usart interface
 */
int32_t usart_sync_init(struct usart_sync_descriptor *const descr, void *const hw, void *const func)
{
    1088:	b580      	push	{r7, lr}
    108a:	b086      	sub	sp, #24
    108c:	af00      	add	r7, sp, #0
    108e:	60f8      	str	r0, [r7, #12]
    1090:	60b9      	str	r1, [r7, #8]
    1092:	607a      	str	r2, [r7, #4]
	int32_t init_status;
	ASSERT(descr && hw);
    1094:	68fb      	ldr	r3, [r7, #12]
    1096:	2b00      	cmp	r3, #0
    1098:	d004      	beq.n	10a4 <usart_sync_init+0x1c>
    109a:	68bb      	ldr	r3, [r7, #8]
    109c:	2b00      	cmp	r3, #0
    109e:	d001      	beq.n	10a4 <usart_sync_init+0x1c>
    10a0:	2301      	movs	r3, #1
    10a2:	e000      	b.n	10a6 <usart_sync_init+0x1e>
    10a4:	2300      	movs	r3, #0
    10a6:	1c1a      	adds	r2, r3, #0
    10a8:	2301      	movs	r3, #1
    10aa:	4013      	ands	r3, r2
    10ac:	b2db      	uxtb	r3, r3
    10ae:	490f      	ldr	r1, [pc, #60]	; (10ec <usart_sync_init+0x64>)
    10b0:	2234      	movs	r2, #52	; 0x34
    10b2:	0018      	movs	r0, r3
    10b4:	4b0e      	ldr	r3, [pc, #56]	; (10f0 <usart_sync_init+0x68>)
    10b6:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    10b8:	68fb      	ldr	r3, [r7, #12]
    10ba:	3308      	adds	r3, #8
    10bc:	68ba      	ldr	r2, [r7, #8]
    10be:	0011      	movs	r1, r2
    10c0:	0018      	movs	r0, r3
    10c2:	4b0c      	ldr	r3, [pc, #48]	; (10f4 <usart_sync_init+0x6c>)
    10c4:	4798      	blx	r3
    10c6:	0003      	movs	r3, r0
    10c8:	617b      	str	r3, [r7, #20]
	if (init_status) {
    10ca:	697b      	ldr	r3, [r7, #20]
    10cc:	2b00      	cmp	r3, #0
    10ce:	d001      	beq.n	10d4 <usart_sync_init+0x4c>
		return init_status;
    10d0:	697b      	ldr	r3, [r7, #20]
    10d2:	e006      	b.n	10e2 <usart_sync_init+0x5a>
	}

	descr->io.read  = usart_sync_read;
    10d4:	68fb      	ldr	r3, [r7, #12]
    10d6:	4a08      	ldr	r2, [pc, #32]	; (10f8 <usart_sync_init+0x70>)
    10d8:	605a      	str	r2, [r3, #4]
	descr->io.write = usart_sync_write;
    10da:	68fb      	ldr	r3, [r7, #12]
    10dc:	4a07      	ldr	r2, [pc, #28]	; (10fc <usart_sync_init+0x74>)
    10de:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    10e0:	2300      	movs	r3, #0
}
    10e2:	0018      	movs	r0, r3
    10e4:	46bd      	mov	sp, r7
    10e6:	b006      	add	sp, #24
    10e8:	bd80      	pop	{r7, pc}
    10ea:	46c0      	nop			; (mov r8, r8)
    10ec:	00005e40 	.word	0x00005e40
    10f0:	00001331 	.word	0x00001331
    10f4:	00002221 	.word	0x00002221
    10f8:	00001295 	.word	0x00001295
    10fc:	000011c1 	.word	0x000011c1

00001100 <usart_sync_enable>:

/**
 * \brief Enable usart interface
 */
int32_t usart_sync_enable(struct usart_sync_descriptor *const descr)
{
    1100:	b580      	push	{r7, lr}
    1102:	b082      	sub	sp, #8
    1104:	af00      	add	r7, sp, #0
    1106:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
    1108:	687b      	ldr	r3, [r7, #4]
    110a:	1e5a      	subs	r2, r3, #1
    110c:	4193      	sbcs	r3, r2
    110e:	b2db      	uxtb	r3, r3
    1110:	4907      	ldr	r1, [pc, #28]	; (1130 <usart_sync_enable+0x30>)
    1112:	2253      	movs	r2, #83	; 0x53
    1114:	0018      	movs	r0, r3
    1116:	4b07      	ldr	r3, [pc, #28]	; (1134 <usart_sync_enable+0x34>)
    1118:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    111a:	687b      	ldr	r3, [r7, #4]
    111c:	3308      	adds	r3, #8
    111e:	0018      	movs	r0, r3
    1120:	4b05      	ldr	r3, [pc, #20]	; (1138 <usart_sync_enable+0x38>)
    1122:	4798      	blx	r3

	return ERR_NONE;
    1124:	2300      	movs	r3, #0
}
    1126:	0018      	movs	r0, r3
    1128:	46bd      	mov	sp, r7
    112a:	b002      	add	sp, #8
    112c:	bd80      	pop	{r7, pc}
    112e:	46c0      	nop			; (mov r8, r8)
    1130:	00005e40 	.word	0x00005e40
    1134:	00001331 	.word	0x00001331
    1138:	00002261 	.word	0x00002261

0000113c <usart_sync_get_io_descriptor>:

/**
 * \brief Retrieve I/O descriptor
 */
int32_t usart_sync_get_io_descriptor(struct usart_sync_descriptor *const descr, struct io_descriptor **io)
{
    113c:	b580      	push	{r7, lr}
    113e:	b082      	sub	sp, #8
    1140:	af00      	add	r7, sp, #0
    1142:	6078      	str	r0, [r7, #4]
    1144:	6039      	str	r1, [r7, #0]
	ASSERT(descr && io);
    1146:	687b      	ldr	r3, [r7, #4]
    1148:	2b00      	cmp	r3, #0
    114a:	d004      	beq.n	1156 <usart_sync_get_io_descriptor+0x1a>
    114c:	683b      	ldr	r3, [r7, #0]
    114e:	2b00      	cmp	r3, #0
    1150:	d001      	beq.n	1156 <usart_sync_get_io_descriptor+0x1a>
    1152:	2301      	movs	r3, #1
    1154:	e000      	b.n	1158 <usart_sync_get_io_descriptor+0x1c>
    1156:	2300      	movs	r3, #0
    1158:	1c1a      	adds	r2, r3, #0
    115a:	2301      	movs	r3, #1
    115c:	4013      	ands	r3, r2
    115e:	b2db      	uxtb	r3, r3
    1160:	4906      	ldr	r1, [pc, #24]	; (117c <usart_sync_get_io_descriptor+0x40>)
    1162:	2269      	movs	r2, #105	; 0x69
    1164:	0018      	movs	r0, r3
    1166:	4b06      	ldr	r3, [pc, #24]	; (1180 <usart_sync_get_io_descriptor+0x44>)
    1168:	4798      	blx	r3

	*io = &descr->io;
    116a:	687a      	ldr	r2, [r7, #4]
    116c:	683b      	ldr	r3, [r7, #0]
    116e:	601a      	str	r2, [r3, #0]
	return ERR_NONE;
    1170:	2300      	movs	r3, #0
}
    1172:	0018      	movs	r0, r3
    1174:	46bd      	mov	sp, r7
    1176:	b002      	add	sp, #8
    1178:	bd80      	pop	{r7, pc}
    117a:	46c0      	nop			; (mov r8, r8)
    117c:	00005e40 	.word	0x00005e40
    1180:	00001331 	.word	0x00001331

00001184 <usart_sync_is_rx_not_empty>:

/**
 * \brief Check if the usart receiver is not empty
 */
int32_t usart_sync_is_rx_not_empty(const struct usart_sync_descriptor *const descr)
{
    1184:	b580      	push	{r7, lr}
    1186:	b082      	sub	sp, #8
    1188:	af00      	add	r7, sp, #0
    118a:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
    118c:	687b      	ldr	r3, [r7, #4]
    118e:	1e5a      	subs	r2, r3, #1
    1190:	4193      	sbcs	r3, r2
    1192:	b2db      	uxtb	r3, r3
    1194:	4907      	ldr	r1, [pc, #28]	; (11b4 <usart_sync_is_rx_not_empty+0x30>)
    1196:	22d7      	movs	r2, #215	; 0xd7
    1198:	0018      	movs	r0, r3
    119a:	4b07      	ldr	r3, [pc, #28]	; (11b8 <usart_sync_is_rx_not_empty+0x34>)
    119c:	4798      	blx	r3
	return _usart_sync_is_byte_received(&descr->device);
    119e:	687b      	ldr	r3, [r7, #4]
    11a0:	3308      	adds	r3, #8
    11a2:	0018      	movs	r0, r3
    11a4:	4b05      	ldr	r3, [pc, #20]	; (11bc <usart_sync_is_rx_not_empty+0x38>)
    11a6:	4798      	blx	r3
    11a8:	0003      	movs	r3, r0
}
    11aa:	0018      	movs	r0, r3
    11ac:	46bd      	mov	sp, r7
    11ae:	b002      	add	sp, #8
    11b0:	bd80      	pop	{r7, pc}
    11b2:	46c0      	nop			; (mov r8, r8)
    11b4:	00005e40 	.word	0x00005e40
    11b8:	00001331 	.word	0x00001331
    11bc:	00002311 	.word	0x00002311

000011c0 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    11c0:	b580      	push	{r7, lr}
    11c2:	b086      	sub	sp, #24
    11c4:	af00      	add	r7, sp, #0
    11c6:	60f8      	str	r0, [r7, #12]
    11c8:	60b9      	str	r1, [r7, #8]
    11ca:	1dbb      	adds	r3, r7, #6
    11cc:	801a      	strh	r2, [r3, #0]
	uint32_t                      offset = 0;
    11ce:	2300      	movs	r3, #0
    11d0:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    11d2:	68fb      	ldr	r3, [r7, #12]
    11d4:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    11d6:	68fb      	ldr	r3, [r7, #12]
    11d8:	2b00      	cmp	r3, #0
    11da:	d008      	beq.n	11ee <usart_sync_write+0x2e>
    11dc:	68bb      	ldr	r3, [r7, #8]
    11de:	2b00      	cmp	r3, #0
    11e0:	d005      	beq.n	11ee <usart_sync_write+0x2e>
    11e2:	1dbb      	adds	r3, r7, #6
    11e4:	881b      	ldrh	r3, [r3, #0]
    11e6:	2b00      	cmp	r3, #0
    11e8:	d001      	beq.n	11ee <usart_sync_write+0x2e>
    11ea:	2301      	movs	r3, #1
    11ec:	e000      	b.n	11f0 <usart_sync_write+0x30>
    11ee:	2300      	movs	r3, #0
    11f0:	1c1a      	adds	r2, r3, #0
    11f2:	2301      	movs	r3, #1
    11f4:	4013      	ands	r3, r2
    11f6:	b2db      	uxtb	r3, r3
    11f8:	4921      	ldr	r1, [pc, #132]	; (1280 <usart_sync_write+0xc0>)
    11fa:	22f1      	movs	r2, #241	; 0xf1
    11fc:	0018      	movs	r0, r3
    11fe:	4b21      	ldr	r3, [pc, #132]	; (1284 <usart_sync_write+0xc4>)
    1200:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    1202:	46c0      	nop			; (mov r8, r8)
    1204:	693b      	ldr	r3, [r7, #16]
    1206:	3308      	adds	r3, #8
    1208:	0018      	movs	r0, r3
    120a:	4b1f      	ldr	r3, [pc, #124]	; (1288 <usart_sync_write+0xc8>)
    120c:	4798      	blx	r3
    120e:	0003      	movs	r3, r0
    1210:	001a      	movs	r2, r3
    1212:	2301      	movs	r3, #1
    1214:	4053      	eors	r3, r2
    1216:	b2db      	uxtb	r3, r3
    1218:	2b00      	cmp	r3, #0
    121a:	d1f3      	bne.n	1204 <usart_sync_write+0x44>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    121c:	693b      	ldr	r3, [r7, #16]
    121e:	3308      	adds	r3, #8
    1220:	0018      	movs	r0, r3
    1222:	68ba      	ldr	r2, [r7, #8]
    1224:	697b      	ldr	r3, [r7, #20]
    1226:	18d3      	adds	r3, r2, r3
    1228:	781b      	ldrb	r3, [r3, #0]
    122a:	0019      	movs	r1, r3
    122c:	4b17      	ldr	r3, [pc, #92]	; (128c <usart_sync_write+0xcc>)
    122e:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
    1230:	46c0      	nop			; (mov r8, r8)
    1232:	693b      	ldr	r3, [r7, #16]
    1234:	3308      	adds	r3, #8
    1236:	0018      	movs	r0, r3
    1238:	4b13      	ldr	r3, [pc, #76]	; (1288 <usart_sync_write+0xc8>)
    123a:	4798      	blx	r3
    123c:	0003      	movs	r3, r0
    123e:	001a      	movs	r2, r3
    1240:	2301      	movs	r3, #1
    1242:	4053      	eors	r3, r2
    1244:	b2db      	uxtb	r3, r3
    1246:	2b00      	cmp	r3, #0
    1248:	d1f3      	bne.n	1232 <usart_sync_write+0x72>
			;
	} while (++offset < length);
    124a:	697b      	ldr	r3, [r7, #20]
    124c:	3301      	adds	r3, #1
    124e:	617b      	str	r3, [r7, #20]
    1250:	1dbb      	adds	r3, r7, #6
    1252:	881b      	ldrh	r3, [r3, #0]
    1254:	697a      	ldr	r2, [r7, #20]
    1256:	429a      	cmp	r2, r3
    1258:	d3e0      	bcc.n	121c <usart_sync_write+0x5c>
	while (!_usart_sync_is_transmit_done(&descr->device))
    125a:	46c0      	nop			; (mov r8, r8)
    125c:	693b      	ldr	r3, [r7, #16]
    125e:	3308      	adds	r3, #8
    1260:	0018      	movs	r0, r3
    1262:	4b0b      	ldr	r3, [pc, #44]	; (1290 <usart_sync_write+0xd0>)
    1264:	4798      	blx	r3
    1266:	0003      	movs	r3, r0
    1268:	001a      	movs	r2, r3
    126a:	2301      	movs	r3, #1
    126c:	4053      	eors	r3, r2
    126e:	b2db      	uxtb	r3, r3
    1270:	2b00      	cmp	r3, #0
    1272:	d1f3      	bne.n	125c <usart_sync_write+0x9c>
		;
	return (int32_t)offset;
    1274:	697b      	ldr	r3, [r7, #20]
}
    1276:	0018      	movs	r0, r3
    1278:	46bd      	mov	sp, r7
    127a:	b006      	add	sp, #24
    127c:	bd80      	pop	{r7, pc}
    127e:	46c0      	nop			; (mov r8, r8)
    1280:	00005e40 	.word	0x00005e40
    1284:	00001331 	.word	0x00001331
    1288:	000022d1 	.word	0x000022d1
    128c:	00002281 	.word	0x00002281
    1290:	000022f1 	.word	0x000022f1

00001294 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1294:	b590      	push	{r4, r7, lr}
    1296:	b087      	sub	sp, #28
    1298:	af00      	add	r7, sp, #0
    129a:	60f8      	str	r0, [r7, #12]
    129c:	60b9      	str	r1, [r7, #8]
    129e:	1dbb      	adds	r3, r7, #6
    12a0:	801a      	strh	r2, [r3, #0]
	uint32_t                      offset = 0;
    12a2:	2300      	movs	r3, #0
    12a4:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    12a6:	68fb      	ldr	r3, [r7, #12]
    12a8:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    12aa:	68fb      	ldr	r3, [r7, #12]
    12ac:	2b00      	cmp	r3, #0
    12ae:	d008      	beq.n	12c2 <usart_sync_read+0x2e>
    12b0:	68bb      	ldr	r3, [r7, #8]
    12b2:	2b00      	cmp	r3, #0
    12b4:	d005      	beq.n	12c2 <usart_sync_read+0x2e>
    12b6:	1dbb      	adds	r3, r7, #6
    12b8:	881b      	ldrh	r3, [r3, #0]
    12ba:	2b00      	cmp	r3, #0
    12bc:	d001      	beq.n	12c2 <usart_sync_read+0x2e>
    12be:	2301      	movs	r3, #1
    12c0:	e000      	b.n	12c4 <usart_sync_read+0x30>
    12c2:	2300      	movs	r3, #0
    12c4:	1c1a      	adds	r2, r3, #0
    12c6:	2301      	movs	r3, #1
    12c8:	4013      	ands	r3, r2
    12ca:	b2d8      	uxtb	r0, r3
    12cc:	2386      	movs	r3, #134	; 0x86
    12ce:	005a      	lsls	r2, r3, #1
    12d0:	4b13      	ldr	r3, [pc, #76]	; (1320 <usart_sync_read+0x8c>)
    12d2:	0019      	movs	r1, r3
    12d4:	4b13      	ldr	r3, [pc, #76]	; (1324 <usart_sync_read+0x90>)
    12d6:	4798      	blx	r3
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    12d8:	46c0      	nop			; (mov r8, r8)
    12da:	693b      	ldr	r3, [r7, #16]
    12dc:	3308      	adds	r3, #8
    12de:	0018      	movs	r0, r3
    12e0:	4b11      	ldr	r3, [pc, #68]	; (1328 <usart_sync_read+0x94>)
    12e2:	4798      	blx	r3
    12e4:	0003      	movs	r3, r0
    12e6:	001a      	movs	r2, r3
    12e8:	2301      	movs	r3, #1
    12ea:	4053      	eors	r3, r2
    12ec:	b2db      	uxtb	r3, r3
    12ee:	2b00      	cmp	r3, #0
    12f0:	d1f3      	bne.n	12da <usart_sync_read+0x46>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    12f2:	68ba      	ldr	r2, [r7, #8]
    12f4:	697b      	ldr	r3, [r7, #20]
    12f6:	18d4      	adds	r4, r2, r3
    12f8:	693b      	ldr	r3, [r7, #16]
    12fa:	3308      	adds	r3, #8
    12fc:	0018      	movs	r0, r3
    12fe:	4b0b      	ldr	r3, [pc, #44]	; (132c <usart_sync_read+0x98>)
    1300:	4798      	blx	r3
    1302:	0003      	movs	r3, r0
    1304:	7023      	strb	r3, [r4, #0]
	} while (++offset < length);
    1306:	697b      	ldr	r3, [r7, #20]
    1308:	3301      	adds	r3, #1
    130a:	617b      	str	r3, [r7, #20]
    130c:	1dbb      	adds	r3, r7, #6
    130e:	881b      	ldrh	r3, [r3, #0]
    1310:	697a      	ldr	r2, [r7, #20]
    1312:	429a      	cmp	r2, r3
    1314:	d3e0      	bcc.n	12d8 <usart_sync_read+0x44>

	return (int32_t)offset;
    1316:	697b      	ldr	r3, [r7, #20]
}
    1318:	0018      	movs	r0, r3
    131a:	46bd      	mov	sp, r7
    131c:	b007      	add	sp, #28
    131e:	bd90      	pop	{r4, r7, pc}
    1320:	00005e40 	.word	0x00005e40
    1324:	00001331 	.word	0x00001331
    1328:	00002311 	.word	0x00002311
    132c:	000022ad 	.word	0x000022ad

00001330 <assert>:

/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
    1330:	b580      	push	{r7, lr}
    1332:	b084      	sub	sp, #16
    1334:	af00      	add	r7, sp, #0
    1336:	60b9      	str	r1, [r7, #8]
    1338:	607a      	str	r2, [r7, #4]
    133a:	230f      	movs	r3, #15
    133c:	18fb      	adds	r3, r7, r3
    133e:	1c02      	adds	r2, r0, #0
    1340:	701a      	strb	r2, [r3, #0]
	if (!(condition)) {
    1342:	230f      	movs	r3, #15
    1344:	18fb      	adds	r3, r7, r3
    1346:	781b      	ldrb	r3, [r3, #0]
    1348:	2201      	movs	r2, #1
    134a:	4053      	eors	r3, r2
    134c:	b2db      	uxtb	r3, r3
    134e:	2b00      	cmp	r3, #0
    1350:	d000      	beq.n	1354 <assert+0x24>
		__asm("BKPT #0");
    1352:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    1354:	46c0      	nop			; (mov r8, r8)
    1356:	46bd      	mov	sp, r7
    1358:	b004      	add	sp, #16
    135a:	bd80      	pop	{r7, pc}

0000135c <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_sampctrl_reg_t;
typedef uint8_t  hri_adc_seqstatus_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
    135c:	b580      	push	{r7, lr}
    135e:	b082      	sub	sp, #8
    1360:	af00      	add	r7, sp, #0
    1362:	6078      	str	r0, [r7, #4]
    1364:	000a      	movs	r2, r1
    1366:	1cbb      	adds	r3, r7, #2
    1368:	801a      	strh	r2, [r3, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    136a:	46c0      	nop			; (mov r8, r8)
    136c:	687b      	ldr	r3, [r7, #4]
    136e:	8c1b      	ldrh	r3, [r3, #32]
    1370:	b29b      	uxth	r3, r3
    1372:	1cba      	adds	r2, r7, #2
    1374:	8812      	ldrh	r2, [r2, #0]
    1376:	4013      	ands	r3, r2
    1378:	b29b      	uxth	r3, r3
    137a:	2b00      	cmp	r3, #0
    137c:	d1f6      	bne.n	136c <hri_adc_wait_for_sync+0x10>
	};
}
    137e:	46c0      	nop			; (mov r8, r8)
    1380:	46bd      	mov	sp, r7
    1382:	b002      	add	sp, #8
    1384:	bd80      	pop	{r7, pc}

00001386 <hri_adc_is_syncing>:

static inline bool hri_adc_is_syncing(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
    1386:	b580      	push	{r7, lr}
    1388:	b082      	sub	sp, #8
    138a:	af00      	add	r7, sp, #0
    138c:	6078      	str	r0, [r7, #4]
    138e:	000a      	movs	r2, r1
    1390:	1cbb      	adds	r3, r7, #2
    1392:	801a      	strh	r2, [r3, #0]
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
    1394:	687b      	ldr	r3, [r7, #4]
    1396:	8c1b      	ldrh	r3, [r3, #32]
    1398:	b29b      	uxth	r3, r3
    139a:	1cba      	adds	r2, r7, #2
    139c:	8812      	ldrh	r2, [r2, #0]
    139e:	4013      	ands	r3, r2
    13a0:	b29b      	uxth	r3, r3
    13a2:	1e5a      	subs	r2, r3, #1
    13a4:	4193      	sbcs	r3, r2
    13a6:	b2db      	uxtb	r3, r3
}
    13a8:	0018      	movs	r0, r3
    13aa:	46bd      	mov	sp, r7
    13ac:	b002      	add	sp, #8
    13ae:	bd80      	pop	{r7, pc}

000013b0 <hri_adc_get_interrupt_RESRDY_bit>:
{
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_WINMON;
}

static inline bool hri_adc_get_interrupt_RESRDY_bit(const void *const hw)
{
    13b0:	b580      	push	{r7, lr}
    13b2:	b082      	sub	sp, #8
    13b4:	af00      	add	r7, sp, #0
    13b6:	6078      	str	r0, [r7, #4]
	return (((Adc *)hw)->INTFLAG.reg & ADC_INTFLAG_RESRDY) >> ADC_INTFLAG_RESRDY_Pos;
    13b8:	687b      	ldr	r3, [r7, #4]
    13ba:	799b      	ldrb	r3, [r3, #6]
    13bc:	b2db      	uxtb	r3, r3
    13be:	001a      	movs	r2, r3
    13c0:	2301      	movs	r3, #1
    13c2:	4013      	ands	r3, r2
    13c4:	1e5a      	subs	r2, r3, #1
    13c6:	4193      	sbcs	r3, r2
    13c8:	b2db      	uxtb	r3, r3
}
    13ca:	0018      	movs	r0, r3
    13cc:	46bd      	mov	sp, r7
    13ce:	b002      	add	sp, #8
    13d0:	bd80      	pop	{r7, pc}

000013d2 <hri_adc_read_RESULT_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_adc_result_reg_t hri_adc_read_RESULT_reg(const void *const hw)
{
    13d2:	b580      	push	{r7, lr}
    13d4:	b082      	sub	sp, #8
    13d6:	af00      	add	r7, sp, #0
    13d8:	6078      	str	r0, [r7, #4]
	return ((Adc *)hw)->RESULT.reg;
    13da:	687b      	ldr	r3, [r7, #4]
    13dc:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    13de:	b29b      	uxth	r3, r3
}
    13e0:	0018      	movs	r0, r3
    13e2:	46bd      	mov	sp, r7
    13e4:	b002      	add	sp, #8
    13e6:	bd80      	pop	{r7, pc}

000013e8 <hri_adc_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & ADC_CTRLA_SWRST) >> ADC_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_adc_set_CTRLA_ENABLE_bit(const void *const hw)
{
    13e8:	b580      	push	{r7, lr}
    13ea:	b082      	sub	sp, #8
    13ec:	af00      	add	r7, sp, #0
    13ee:	6078      	str	r0, [r7, #4]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
    13f0:	687b      	ldr	r3, [r7, #4]
    13f2:	781b      	ldrb	r3, [r3, #0]
    13f4:	b2db      	uxtb	r3, r3
    13f6:	2202      	movs	r2, #2
    13f8:	4313      	orrs	r3, r2
    13fa:	b2da      	uxtb	r2, r3
    13fc:	687b      	ldr	r3, [r7, #4]
    13fe:	701a      	strb	r2, [r3, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    1400:	687b      	ldr	r3, [r7, #4]
    1402:	2103      	movs	r1, #3
    1404:	0018      	movs	r0, r3
    1406:	4b03      	ldr	r3, [pc, #12]	; (1414 <hri_adc_set_CTRLA_ENABLE_bit+0x2c>)
    1408:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    140a:	46c0      	nop			; (mov r8, r8)
    140c:	46bd      	mov	sp, r7
    140e:	b002      	add	sp, #8
    1410:	bd80      	pop	{r7, pc}
    1412:	46c0      	nop			; (mov r8, r8)
    1414:	0000135d 	.word	0x0000135d

00001418 <hri_adc_clear_CTRLA_ENABLE_bit>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    1418:	b580      	push	{r7, lr}
    141a:	b082      	sub	sp, #8
    141c:	af00      	add	r7, sp, #0
    141e:	6078      	str	r0, [r7, #4]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
    1420:	687b      	ldr	r3, [r7, #4]
    1422:	781b      	ldrb	r3, [r3, #0]
    1424:	b2db      	uxtb	r3, r3
    1426:	2202      	movs	r2, #2
    1428:	4393      	bics	r3, r2
    142a:	b2da      	uxtb	r2, r3
    142c:	687b      	ldr	r3, [r7, #4]
    142e:	701a      	strb	r2, [r3, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    1430:	687b      	ldr	r3, [r7, #4]
    1432:	2103      	movs	r1, #3
    1434:	0018      	movs	r0, r3
    1436:	4b03      	ldr	r3, [pc, #12]	; (1444 <hri_adc_clear_CTRLA_ENABLE_bit+0x2c>)
    1438:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    143a:	46c0      	nop			; (mov r8, r8)
    143c:	46bd      	mov	sp, r7
    143e:	b002      	add	sp, #8
    1440:	bd80      	pop	{r7, pc}
    1442:	46c0      	nop			; (mov r8, r8)
    1444:	0000135d 	.word	0x0000135d

00001448 <hri_adc_get_CTRLA_reg>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
    1448:	b580      	push	{r7, lr}
    144a:	b084      	sub	sp, #16
    144c:	af00      	add	r7, sp, #0
    144e:	6078      	str	r0, [r7, #4]
    1450:	000a      	movs	r2, r1
    1452:	1cfb      	adds	r3, r7, #3
    1454:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    1456:	687b      	ldr	r3, [r7, #4]
    1458:	2103      	movs	r1, #3
    145a:	0018      	movs	r0, r3
    145c:	4b0b      	ldr	r3, [pc, #44]	; (148c <hri_adc_get_CTRLA_reg+0x44>)
    145e:	4798      	blx	r3
	tmp = ((Adc *)hw)->CTRLA.reg;
    1460:	230f      	movs	r3, #15
    1462:	18fb      	adds	r3, r7, r3
    1464:	687a      	ldr	r2, [r7, #4]
    1466:	7812      	ldrb	r2, [r2, #0]
    1468:	701a      	strb	r2, [r3, #0]
	tmp &= mask;
    146a:	230f      	movs	r3, #15
    146c:	18fb      	adds	r3, r7, r3
    146e:	220f      	movs	r2, #15
    1470:	18ba      	adds	r2, r7, r2
    1472:	1cf9      	adds	r1, r7, #3
    1474:	7812      	ldrb	r2, [r2, #0]
    1476:	7809      	ldrb	r1, [r1, #0]
    1478:	400a      	ands	r2, r1
    147a:	701a      	strb	r2, [r3, #0]
	return tmp;
    147c:	230f      	movs	r3, #15
    147e:	18fb      	adds	r3, r7, r3
    1480:	781b      	ldrb	r3, [r3, #0]
}
    1482:	0018      	movs	r0, r3
    1484:	46bd      	mov	sp, r7
    1486:	b004      	add	sp, #16
    1488:	bd80      	pop	{r7, pc}
    148a:	46c0      	nop			; (mov r8, r8)
    148c:	0000135d 	.word	0x0000135d

00001490 <hri_adc_write_CTRLA_reg>:

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
    1490:	b580      	push	{r7, lr}
    1492:	b082      	sub	sp, #8
    1494:	af00      	add	r7, sp, #0
    1496:	6078      	str	r0, [r7, #4]
    1498:	000a      	movs	r2, r1
    149a:	1cfb      	adds	r3, r7, #3
    149c:	701a      	strb	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
    149e:	687b      	ldr	r3, [r7, #4]
    14a0:	1cfa      	adds	r2, r7, #3
    14a2:	7812      	ldrb	r2, [r2, #0]
    14a4:	701a      	strb	r2, [r3, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    14a6:	687b      	ldr	r3, [r7, #4]
    14a8:	2103      	movs	r1, #3
    14aa:	0018      	movs	r0, r3
    14ac:	4b02      	ldr	r3, [pc, #8]	; (14b8 <hri_adc_write_CTRLA_reg+0x28>)
    14ae:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    14b0:	46c0      	nop			; (mov r8, r8)
    14b2:	46bd      	mov	sp, r7
    14b4:	b002      	add	sp, #8
    14b6:	bd80      	pop	{r7, pc}
    14b8:	0000135d 	.word	0x0000135d

000014bc <hri_adc_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_CTRLB_reg(const void *const hw, hri_adc_ctrlb_reg_t data)
{
    14bc:	b580      	push	{r7, lr}
    14be:	b082      	sub	sp, #8
    14c0:	af00      	add	r7, sp, #0
    14c2:	6078      	str	r0, [r7, #4]
    14c4:	000a      	movs	r2, r1
    14c6:	1cfb      	adds	r3, r7, #3
    14c8:	701a      	strb	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLB.reg = data;
    14ca:	687b      	ldr	r3, [r7, #4]
    14cc:	1cfa      	adds	r2, r7, #3
    14ce:	7812      	ldrb	r2, [r2, #0]
    14d0:	705a      	strb	r2, [r3, #1]
	ADC_CRITICAL_SECTION_LEAVE();
}
    14d2:	46c0      	nop			; (mov r8, r8)
    14d4:	46bd      	mov	sp, r7
    14d6:	b002      	add	sp, #8
    14d8:	bd80      	pop	{r7, pc}

000014da <hri_adc_write_REFCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_REFCTRL_reg(const void *const hw, hri_adc_refctrl_reg_t data)
{
    14da:	b580      	push	{r7, lr}
    14dc:	b082      	sub	sp, #8
    14de:	af00      	add	r7, sp, #0
    14e0:	6078      	str	r0, [r7, #4]
    14e2:	000a      	movs	r2, r1
    14e4:	1cfb      	adds	r3, r7, #3
    14e6:	701a      	strb	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->REFCTRL.reg = data;
    14e8:	687b      	ldr	r3, [r7, #4]
    14ea:	1cfa      	adds	r2, r7, #3
    14ec:	7812      	ldrb	r2, [r2, #0]
    14ee:	709a      	strb	r2, [r3, #2]
	ADC_CRITICAL_SECTION_LEAVE();
}
    14f0:	46c0      	nop			; (mov r8, r8)
    14f2:	46bd      	mov	sp, r7
    14f4:	b002      	add	sp, #8
    14f6:	bd80      	pop	{r7, pc}

000014f8 <hri_adc_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_EVCTRL_reg(const void *const hw, hri_adc_evctrl_reg_t data)
{
    14f8:	b580      	push	{r7, lr}
    14fa:	b082      	sub	sp, #8
    14fc:	af00      	add	r7, sp, #0
    14fe:	6078      	str	r0, [r7, #4]
    1500:	000a      	movs	r2, r1
    1502:	1cfb      	adds	r3, r7, #3
    1504:	701a      	strb	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->EVCTRL.reg = data;
    1506:	687b      	ldr	r3, [r7, #4]
    1508:	1cfa      	adds	r2, r7, #3
    150a:	7812      	ldrb	r2, [r2, #0]
    150c:	70da      	strb	r2, [r3, #3]
	ADC_CRITICAL_SECTION_LEAVE();
}
    150e:	46c0      	nop			; (mov r8, r8)
    1510:	46bd      	mov	sp, r7
    1512:	b002      	add	sp, #8
    1514:	bd80      	pop	{r7, pc}
	...

00001518 <hri_adc_write_INPUTCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_INPUTCTRL_reg(const void *const hw, hri_adc_inputctrl_reg_t data)
{
    1518:	b580      	push	{r7, lr}
    151a:	b082      	sub	sp, #8
    151c:	af00      	add	r7, sp, #0
    151e:	6078      	str	r0, [r7, #4]
    1520:	000a      	movs	r2, r1
    1522:	1cbb      	adds	r3, r7, #2
    1524:	801a      	strh	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->INPUTCTRL.reg = data;
    1526:	687b      	ldr	r3, [r7, #4]
    1528:	1cba      	adds	r2, r7, #2
    152a:	8812      	ldrh	r2, [r2, #0]
    152c:	811a      	strh	r2, [r3, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    152e:	4a05      	ldr	r2, [pc, #20]	; (1544 <hri_adc_write_INPUTCTRL_reg+0x2c>)
    1530:	687b      	ldr	r3, [r7, #4]
    1532:	0011      	movs	r1, r2
    1534:	0018      	movs	r0, r3
    1536:	4b04      	ldr	r3, [pc, #16]	; (1548 <hri_adc_write_INPUTCTRL_reg+0x30>)
    1538:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    153a:	46c0      	nop			; (mov r8, r8)
    153c:	46bd      	mov	sp, r7
    153e:	b002      	add	sp, #8
    1540:	bd80      	pop	{r7, pc}
    1542:	46c0      	nop			; (mov r8, r8)
    1544:	000007ff 	.word	0x000007ff
    1548:	0000135d 	.word	0x0000135d

0000154c <hri_adc_read_CTRLC_RESSEL_bf>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline hri_adc_ctrlc_reg_t hri_adc_read_CTRLC_RESSEL_bf(const void *const hw)
{
    154c:	b580      	push	{r7, lr}
    154e:	b084      	sub	sp, #16
    1550:	af00      	add	r7, sp, #0
    1552:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((Adc *)hw)->CTRLC.reg;
    1554:	230e      	movs	r3, #14
    1556:	18fb      	adds	r3, r7, r3
    1558:	687a      	ldr	r2, [r7, #4]
    155a:	8952      	ldrh	r2, [r2, #10]
    155c:	801a      	strh	r2, [r3, #0]
	tmp = (tmp & ADC_CTRLC_RESSEL_Msk) >> ADC_CTRLC_RESSEL_Pos;
    155e:	230e      	movs	r3, #14
    1560:	18fb      	adds	r3, r7, r3
    1562:	881b      	ldrh	r3, [r3, #0]
    1564:	091b      	lsrs	r3, r3, #4
    1566:	b29a      	uxth	r2, r3
    1568:	230e      	movs	r3, #14
    156a:	18fb      	adds	r3, r7, r3
    156c:	2103      	movs	r1, #3
    156e:	400a      	ands	r2, r1
    1570:	801a      	strh	r2, [r3, #0]
	return tmp;
    1572:	230e      	movs	r3, #14
    1574:	18fb      	adds	r3, r7, r3
    1576:	881b      	ldrh	r3, [r3, #0]
}
    1578:	0018      	movs	r0, r3
    157a:	46bd      	mov	sp, r7
    157c:	b004      	add	sp, #16
    157e:	bd80      	pop	{r7, pc}

00001580 <hri_adc_write_CTRLC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_CTRLC_reg(const void *const hw, hri_adc_ctrlc_reg_t data)
{
    1580:	b580      	push	{r7, lr}
    1582:	b082      	sub	sp, #8
    1584:	af00      	add	r7, sp, #0
    1586:	6078      	str	r0, [r7, #4]
    1588:	000a      	movs	r2, r1
    158a:	1cbb      	adds	r3, r7, #2
    158c:	801a      	strh	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLC.reg = data;
    158e:	687b      	ldr	r3, [r7, #4]
    1590:	1cba      	adds	r2, r7, #2
    1592:	8812      	ldrh	r2, [r2, #0]
    1594:	815a      	strh	r2, [r3, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    1596:	4a05      	ldr	r2, [pc, #20]	; (15ac <hri_adc_write_CTRLC_reg+0x2c>)
    1598:	687b      	ldr	r3, [r7, #4]
    159a:	0011      	movs	r1, r2
    159c:	0018      	movs	r0, r3
    159e:	4b04      	ldr	r3, [pc, #16]	; (15b0 <hri_adc_write_CTRLC_reg+0x30>)
    15a0:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    15a2:	46c0      	nop			; (mov r8, r8)
    15a4:	46bd      	mov	sp, r7
    15a6:	b002      	add	sp, #8
    15a8:	bd80      	pop	{r7, pc}
    15aa:	46c0      	nop			; (mov r8, r8)
    15ac:	000007ff 	.word	0x000007ff
    15b0:	0000135d 	.word	0x0000135d

000015b4 <hri_adc_write_AVGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_AVGCTRL_reg(const void *const hw, hri_adc_avgctrl_reg_t data)
{
    15b4:	b580      	push	{r7, lr}
    15b6:	b082      	sub	sp, #8
    15b8:	af00      	add	r7, sp, #0
    15ba:	6078      	str	r0, [r7, #4]
    15bc:	000a      	movs	r2, r1
    15be:	1cfb      	adds	r3, r7, #3
    15c0:	701a      	strb	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->AVGCTRL.reg = data;
    15c2:	687b      	ldr	r3, [r7, #4]
    15c4:	1cfa      	adds	r2, r7, #3
    15c6:	7812      	ldrb	r2, [r2, #0]
    15c8:	731a      	strb	r2, [r3, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    15ca:	4a05      	ldr	r2, [pc, #20]	; (15e0 <hri_adc_write_AVGCTRL_reg+0x2c>)
    15cc:	687b      	ldr	r3, [r7, #4]
    15ce:	0011      	movs	r1, r2
    15d0:	0018      	movs	r0, r3
    15d2:	4b04      	ldr	r3, [pc, #16]	; (15e4 <hri_adc_write_AVGCTRL_reg+0x30>)
    15d4:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    15d6:	46c0      	nop			; (mov r8, r8)
    15d8:	46bd      	mov	sp, r7
    15da:	b002      	add	sp, #8
    15dc:	bd80      	pop	{r7, pc}
    15de:	46c0      	nop			; (mov r8, r8)
    15e0:	000007ff 	.word	0x000007ff
    15e4:	0000135d 	.word	0x0000135d

000015e8 <hri_adc_write_SAMPCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_SAMPCTRL_reg(const void *const hw, hri_adc_sampctrl_reg_t data)
{
    15e8:	b580      	push	{r7, lr}
    15ea:	b082      	sub	sp, #8
    15ec:	af00      	add	r7, sp, #0
    15ee:	6078      	str	r0, [r7, #4]
    15f0:	000a      	movs	r2, r1
    15f2:	1cfb      	adds	r3, r7, #3
    15f4:	701a      	strb	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->SAMPCTRL.reg = data;
    15f6:	687b      	ldr	r3, [r7, #4]
    15f8:	1cfa      	adds	r2, r7, #3
    15fa:	7812      	ldrb	r2, [r2, #0]
    15fc:	735a      	strb	r2, [r3, #13]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    15fe:	4a05      	ldr	r2, [pc, #20]	; (1614 <hri_adc_write_SAMPCTRL_reg+0x2c>)
    1600:	687b      	ldr	r3, [r7, #4]
    1602:	0011      	movs	r1, r2
    1604:	0018      	movs	r0, r3
    1606:	4b04      	ldr	r3, [pc, #16]	; (1618 <hri_adc_write_SAMPCTRL_reg+0x30>)
    1608:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    160a:	46c0      	nop			; (mov r8, r8)
    160c:	46bd      	mov	sp, r7
    160e:	b002      	add	sp, #8
    1610:	bd80      	pop	{r7, pc}
    1612:	46c0      	nop			; (mov r8, r8)
    1614:	000007ff 	.word	0x000007ff
    1618:	0000135d 	.word	0x0000135d

0000161c <hri_adc_write_WINLT_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_WINLT_reg(const void *const hw, hri_adc_winlt_reg_t data)
{
    161c:	b580      	push	{r7, lr}
    161e:	b082      	sub	sp, #8
    1620:	af00      	add	r7, sp, #0
    1622:	6078      	str	r0, [r7, #4]
    1624:	000a      	movs	r2, r1
    1626:	1cbb      	adds	r3, r7, #2
    1628:	801a      	strh	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->WINLT.reg = data;
    162a:	687b      	ldr	r3, [r7, #4]
    162c:	1cba      	adds	r2, r7, #2
    162e:	8812      	ldrh	r2, [r2, #0]
    1630:	81da      	strh	r2, [r3, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
    1632:	687b      	ldr	r3, [r7, #4]
    1634:	2140      	movs	r1, #64	; 0x40
    1636:	0018      	movs	r0, r3
    1638:	4b02      	ldr	r3, [pc, #8]	; (1644 <hri_adc_write_WINLT_reg+0x28>)
    163a:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    163c:	46c0      	nop			; (mov r8, r8)
    163e:	46bd      	mov	sp, r7
    1640:	b002      	add	sp, #8
    1642:	bd80      	pop	{r7, pc}
    1644:	0000135d 	.word	0x0000135d

00001648 <hri_adc_write_WINUT_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_WINUT_reg(const void *const hw, hri_adc_winut_reg_t data)
{
    1648:	b580      	push	{r7, lr}
    164a:	b082      	sub	sp, #8
    164c:	af00      	add	r7, sp, #0
    164e:	6078      	str	r0, [r7, #4]
    1650:	000a      	movs	r2, r1
    1652:	1cbb      	adds	r3, r7, #2
    1654:	801a      	strh	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->WINUT.reg = data;
    1656:	687b      	ldr	r3, [r7, #4]
    1658:	1cba      	adds	r2, r7, #2
    165a:	8812      	ldrh	r2, [r2, #0]
    165c:	821a      	strh	r2, [r3, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
    165e:	687b      	ldr	r3, [r7, #4]
    1660:	2180      	movs	r1, #128	; 0x80
    1662:	0018      	movs	r0, r3
    1664:	4b02      	ldr	r3, [pc, #8]	; (1670 <hri_adc_write_WINUT_reg+0x28>)
    1666:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1668:	46c0      	nop			; (mov r8, r8)
    166a:	46bd      	mov	sp, r7
    166c:	b002      	add	sp, #8
    166e:	bd80      	pop	{r7, pc}
    1670:	0000135d 	.word	0x0000135d

00001674 <hri_adc_write_GAINCORR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_GAINCORR_reg(const void *const hw, hri_adc_gaincorr_reg_t data)
{
    1674:	b580      	push	{r7, lr}
    1676:	b082      	sub	sp, #8
    1678:	af00      	add	r7, sp, #0
    167a:	6078      	str	r0, [r7, #4]
    167c:	000a      	movs	r2, r1
    167e:	1cbb      	adds	r3, r7, #2
    1680:	801a      	strh	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->GAINCORR.reg = data;
    1682:	687b      	ldr	r3, [r7, #4]
    1684:	1cba      	adds	r2, r7, #2
    1686:	8812      	ldrh	r2, [r2, #0]
    1688:	825a      	strh	r2, [r3, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
    168a:	2380      	movs	r3, #128	; 0x80
    168c:	005a      	lsls	r2, r3, #1
    168e:	687b      	ldr	r3, [r7, #4]
    1690:	0011      	movs	r1, r2
    1692:	0018      	movs	r0, r3
    1694:	4b02      	ldr	r3, [pc, #8]	; (16a0 <hri_adc_write_GAINCORR_reg+0x2c>)
    1696:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1698:	46c0      	nop			; (mov r8, r8)
    169a:	46bd      	mov	sp, r7
    169c:	b002      	add	sp, #8
    169e:	bd80      	pop	{r7, pc}
    16a0:	0000135d 	.word	0x0000135d

000016a4 <hri_adc_write_OFFSETCORR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_OFFSETCORR_reg(const void *const hw, hri_adc_offsetcorr_reg_t data)
{
    16a4:	b580      	push	{r7, lr}
    16a6:	b082      	sub	sp, #8
    16a8:	af00      	add	r7, sp, #0
    16aa:	6078      	str	r0, [r7, #4]
    16ac:	000a      	movs	r2, r1
    16ae:	1cbb      	adds	r3, r7, #2
    16b0:	801a      	strh	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->OFFSETCORR.reg = data;
    16b2:	687b      	ldr	r3, [r7, #4]
    16b4:	1cba      	adds	r2, r7, #2
    16b6:	8812      	ldrh	r2, [r2, #0]
    16b8:	829a      	strh	r2, [r3, #20]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
    16ba:	2380      	movs	r3, #128	; 0x80
    16bc:	009a      	lsls	r2, r3, #2
    16be:	687b      	ldr	r3, [r7, #4]
    16c0:	0011      	movs	r1, r2
    16c2:	0018      	movs	r0, r3
    16c4:	4b02      	ldr	r3, [pc, #8]	; (16d0 <hri_adc_write_OFFSETCORR_reg+0x2c>)
    16c6:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    16c8:	46c0      	nop			; (mov r8, r8)
    16ca:	46bd      	mov	sp, r7
    16cc:	b002      	add	sp, #8
    16ce:	bd80      	pop	{r7, pc}
    16d0:	0000135d 	.word	0x0000135d

000016d4 <hri_adc_set_SWTRIG_START_bit>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_adc_set_SWTRIG_START_bit(const void *const hw)
{
    16d4:	b580      	push	{r7, lr}
    16d6:	b082      	sub	sp, #8
    16d8:	af00      	add	r7, sp, #0
    16da:	6078      	str	r0, [r7, #4]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
    16dc:	687b      	ldr	r3, [r7, #4]
    16de:	7e1b      	ldrb	r3, [r3, #24]
    16e0:	b2db      	uxtb	r3, r3
    16e2:	2202      	movs	r2, #2
    16e4:	4313      	orrs	r3, r2
    16e6:	b2da      	uxtb	r2, r3
    16e8:	687b      	ldr	r3, [r7, #4]
    16ea:	761a      	strb	r2, [r3, #24]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    16ec:	4a04      	ldr	r2, [pc, #16]	; (1700 <hri_adc_set_SWTRIG_START_bit+0x2c>)
    16ee:	687b      	ldr	r3, [r7, #4]
    16f0:	0011      	movs	r1, r2
    16f2:	0018      	movs	r0, r3
    16f4:	4b03      	ldr	r3, [pc, #12]	; (1704 <hri_adc_set_SWTRIG_START_bit+0x30>)
    16f6:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    16f8:	46c0      	nop			; (mov r8, r8)
    16fa:	46bd      	mov	sp, r7
    16fc:	b002      	add	sp, #8
    16fe:	bd80      	pop	{r7, pc}
    1700:	000007ff 	.word	0x000007ff
    1704:	0000135d 	.word	0x0000135d

00001708 <hri_adc_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_DBGCTRL_reg(const void *const hw, hri_adc_dbgctrl_reg_t data)
{
    1708:	b580      	push	{r7, lr}
    170a:	b082      	sub	sp, #8
    170c:	af00      	add	r7, sp, #0
    170e:	6078      	str	r0, [r7, #4]
    1710:	000a      	movs	r2, r1
    1712:	1cfb      	adds	r3, r7, #3
    1714:	701a      	strb	r2, [r3, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->DBGCTRL.reg = data;
    1716:	687b      	ldr	r3, [r7, #4]
    1718:	1cfa      	adds	r2, r7, #3
    171a:	7812      	ldrb	r2, [r2, #0]
    171c:	771a      	strb	r2, [r3, #28]
	ADC_CRITICAL_SECTION_LEAVE();
}
    171e:	46c0      	nop			; (mov r8, r8)
    1720:	46bd      	mov	sp, r7
    1722:	b002      	add	sp, #8
    1724:	bd80      	pop	{r7, pc}

00001726 <hri_adc_write_SEQCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_SEQCTRL_reg(const void *const hw, hri_adc_seqctrl_reg_t data)
{
    1726:	b580      	push	{r7, lr}
    1728:	b082      	sub	sp, #8
    172a:	af00      	add	r7, sp, #0
    172c:	6078      	str	r0, [r7, #4]
    172e:	6039      	str	r1, [r7, #0]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->SEQCTRL.reg = data;
    1730:	687b      	ldr	r3, [r7, #4]
    1732:	683a      	ldr	r2, [r7, #0]
    1734:	629a      	str	r2, [r3, #40]	; 0x28
	ADC_CRITICAL_SECTION_LEAVE();
}
    1736:	46c0      	nop			; (mov r8, r8)
    1738:	46bd      	mov	sp, r7
    173a:	b002      	add	sp, #8
    173c:	bd80      	pop	{r7, pc}
	...

00001740 <_adc_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given adc hardware instance
 */
static uint8_t _adc_get_hardware_index(const void *const hw)
{
    1740:	b580      	push	{r7, lr}
    1742:	b082      	sub	sp, #8
    1744:	af00      	add	r7, sp, #0
    1746:	6078      	str	r0, [r7, #4]
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
    1748:	687b      	ldr	r3, [r7, #4]
    174a:	4a04      	ldr	r2, [pc, #16]	; (175c <_adc_get_hardware_index+0x1c>)
    174c:	4694      	mov	ip, r2
    174e:	4463      	add	r3, ip
    1750:	0a9b      	lsrs	r3, r3, #10
    1752:	b2db      	uxtb	r3, r3
}
    1754:	0018      	movs	r0, r3
    1756:	46bd      	mov	sp, r7
    1758:	b002      	add	sp, #8
    175a:	bd80      	pop	{r7, pc}
    175c:	bdffbc00 	.word	0xbdffbc00

00001760 <_adc_get_regs>:
/** \brief Return the pointer to register settings of specific ADC
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific ADC.
 */
static uint8_t _adc_get_regs(const uint32_t hw_addr)
{
    1760:	b590      	push	{r4, r7, lr}
    1762:	b085      	sub	sp, #20
    1764:	af00      	add	r7, sp, #0
    1766:	6078      	str	r0, [r7, #4]
	uint8_t n = _adc_get_hardware_index((const void *)hw_addr);
    1768:	687b      	ldr	r3, [r7, #4]
    176a:	220e      	movs	r2, #14
    176c:	18bc      	adds	r4, r7, r2
    176e:	0018      	movs	r0, r3
    1770:	4b18      	ldr	r3, [pc, #96]	; (17d4 <_adc_get_regs+0x74>)
    1772:	4798      	blx	r3
    1774:	0003      	movs	r3, r0
    1776:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    1778:	230f      	movs	r3, #15
    177a:	18fb      	adds	r3, r7, r3
    177c:	2200      	movs	r2, #0
    177e:	701a      	strb	r2, [r3, #0]
    1780:	e018      	b.n	17b4 <_adc_get_regs+0x54>
		if (_adcs[i].number == n) {
    1782:	230f      	movs	r3, #15
    1784:	18fb      	adds	r3, r7, r3
    1786:	781a      	ldrb	r2, [r3, #0]
    1788:	4913      	ldr	r1, [pc, #76]	; (17d8 <_adc_get_regs+0x78>)
    178a:	0013      	movs	r3, r2
    178c:	00db      	lsls	r3, r3, #3
    178e:	1a9b      	subs	r3, r3, r2
    1790:	009b      	lsls	r3, r3, #2
    1792:	5c5b      	ldrb	r3, [r3, r1]
    1794:	220e      	movs	r2, #14
    1796:	18ba      	adds	r2, r7, r2
    1798:	7812      	ldrb	r2, [r2, #0]
    179a:	429a      	cmp	r2, r3
    179c:	d103      	bne.n	17a6 <_adc_get_regs+0x46>
			return i;
    179e:	230f      	movs	r3, #15
    17a0:	18fb      	adds	r3, r7, r3
    17a2:	781b      	ldrb	r3, [r3, #0]
    17a4:	e012      	b.n	17cc <_adc_get_regs+0x6c>
	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    17a6:	230f      	movs	r3, #15
    17a8:	18fb      	adds	r3, r7, r3
    17aa:	781a      	ldrb	r2, [r3, #0]
    17ac:	230f      	movs	r3, #15
    17ae:	18fb      	adds	r3, r7, r3
    17b0:	3201      	adds	r2, #1
    17b2:	701a      	strb	r2, [r3, #0]
    17b4:	230f      	movs	r3, #15
    17b6:	18fb      	adds	r3, r7, r3
    17b8:	781b      	ldrb	r3, [r3, #0]
    17ba:	2b00      	cmp	r3, #0
    17bc:	d0e1      	beq.n	1782 <_adc_get_regs+0x22>
		}
	}

	ASSERT(false);
    17be:	4b07      	ldr	r3, [pc, #28]	; (17dc <_adc_get_regs+0x7c>)
    17c0:	228d      	movs	r2, #141	; 0x8d
    17c2:	0019      	movs	r1, r3
    17c4:	2000      	movs	r0, #0
    17c6:	4b06      	ldr	r3, [pc, #24]	; (17e0 <_adc_get_regs+0x80>)
    17c8:	4798      	blx	r3
	return 0;
    17ca:	2300      	movs	r3, #0
}
    17cc:	0018      	movs	r0, r3
    17ce:	46bd      	mov	sp, r7
    17d0:	b005      	add	sp, #20
    17d2:	bd90      	pop	{r4, r7, pc}
    17d4:	00001741 	.word	0x00001741
    17d8:	00005e5c 	.word	0x00005e5c
    17dc:	00005e78 	.word	0x00005e78
    17e0:	00001331 	.word	0x00001331

000017e4 <_adc_init>:
 *
 * \param[in] hw The pointer to hardware instance
 * \param[in] i The number of hardware instance
 */
static int32_t _adc_init(void *const hw, const uint8_t i)
{
    17e4:	b580      	push	{r7, lr}
    17e6:	b082      	sub	sp, #8
    17e8:	af00      	add	r7, sp, #0
    17ea:	6078      	str	r0, [r7, #4]
    17ec:	000a      	movs	r2, r1
    17ee:	1cfb      	adds	r3, r7, #3
    17f0:	701a      	strb	r2, [r3, #0]

	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
    17f2:	687b      	ldr	r3, [r7, #4]
    17f4:	2101      	movs	r1, #1
    17f6:	0018      	movs	r0, r3
    17f8:	4b78      	ldr	r3, [pc, #480]	; (19dc <_adc_init+0x1f8>)
    17fa:	4798      	blx	r3
    17fc:	0003      	movs	r3, r0
    17fe:	001a      	movs	r2, r3
    1800:	2301      	movs	r3, #1
    1802:	4053      	eors	r3, r2
    1804:	b2db      	uxtb	r3, r3
    1806:	2b00      	cmp	r3, #0
    1808:	d014      	beq.n	1834 <_adc_init+0x50>
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
    180a:	687b      	ldr	r3, [r7, #4]
    180c:	2102      	movs	r1, #2
    180e:	0018      	movs	r0, r3
    1810:	4b73      	ldr	r3, [pc, #460]	; (19e0 <_adc_init+0x1fc>)
    1812:	4798      	blx	r3
    1814:	1e03      	subs	r3, r0, #0
    1816:	d008      	beq.n	182a <_adc_init+0x46>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
    1818:	687b      	ldr	r3, [r7, #4]
    181a:	0018      	movs	r0, r3
    181c:	4b71      	ldr	r3, [pc, #452]	; (19e4 <_adc_init+0x200>)
    181e:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
    1820:	687b      	ldr	r3, [r7, #4]
    1822:	2102      	movs	r1, #2
    1824:	0018      	movs	r0, r3
    1826:	4b70      	ldr	r3, [pc, #448]	; (19e8 <_adc_init+0x204>)
    1828:	4798      	blx	r3
		}
		hri_adc_write_CTRLA_reg(hw, ADC_CTRLA_SWRST);
    182a:	687b      	ldr	r3, [r7, #4]
    182c:	2101      	movs	r1, #1
    182e:	0018      	movs	r0, r3
    1830:	4b6e      	ldr	r3, [pc, #440]	; (19ec <_adc_init+0x208>)
    1832:	4798      	blx	r3
	}
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
    1834:	687b      	ldr	r3, [r7, #4]
    1836:	2101      	movs	r1, #1
    1838:	0018      	movs	r0, r3
    183a:	4b6b      	ldr	r3, [pc, #428]	; (19e8 <_adc_init+0x204>)
    183c:	4798      	blx	r3

	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
    183e:	1cfb      	adds	r3, r7, #3
    1840:	781a      	ldrb	r2, [r3, #0]
    1842:	496b      	ldr	r1, [pc, #428]	; (19f0 <_adc_init+0x20c>)
    1844:	0013      	movs	r3, r2
    1846:	00db      	lsls	r3, r3, #3
    1848:	1a9b      	subs	r3, r3, r2
    184a:	009b      	lsls	r3, r3, #2
    184c:	18cb      	adds	r3, r1, r3
    184e:	3302      	adds	r3, #2
    1850:	781a      	ldrb	r2, [r3, #0]
    1852:	687b      	ldr	r3, [r7, #4]
    1854:	0011      	movs	r1, r2
    1856:	0018      	movs	r0, r3
    1858:	4b66      	ldr	r3, [pc, #408]	; (19f4 <_adc_init+0x210>)
    185a:	4798      	blx	r3
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
    185c:	1cfb      	adds	r3, r7, #3
    185e:	781a      	ldrb	r2, [r3, #0]
    1860:	4963      	ldr	r1, [pc, #396]	; (19f0 <_adc_init+0x20c>)
    1862:	0013      	movs	r3, r2
    1864:	00db      	lsls	r3, r3, #3
    1866:	1a9b      	subs	r3, r3, r2
    1868:	009b      	lsls	r3, r3, #2
    186a:	18cb      	adds	r3, r1, r3
    186c:	3303      	adds	r3, #3
    186e:	781a      	ldrb	r2, [r3, #0]
    1870:	687b      	ldr	r3, [r7, #4]
    1872:	0011      	movs	r1, r2
    1874:	0018      	movs	r0, r3
    1876:	4b60      	ldr	r3, [pc, #384]	; (19f8 <_adc_init+0x214>)
    1878:	4798      	blx	r3
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
    187a:	1cfb      	adds	r3, r7, #3
    187c:	781a      	ldrb	r2, [r3, #0]
    187e:	495c      	ldr	r1, [pc, #368]	; (19f0 <_adc_init+0x20c>)
    1880:	0013      	movs	r3, r2
    1882:	00db      	lsls	r3, r3, #3
    1884:	1a9b      	subs	r3, r3, r2
    1886:	009b      	lsls	r3, r3, #2
    1888:	18cb      	adds	r3, r1, r3
    188a:	3304      	adds	r3, #4
    188c:	781a      	ldrb	r2, [r3, #0]
    188e:	687b      	ldr	r3, [r7, #4]
    1890:	0011      	movs	r1, r2
    1892:	0018      	movs	r0, r3
    1894:	4b59      	ldr	r3, [pc, #356]	; (19fc <_adc_init+0x218>)
    1896:	4798      	blx	r3
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
    1898:	1cfb      	adds	r3, r7, #3
    189a:	781a      	ldrb	r2, [r3, #0]
    189c:	4954      	ldr	r1, [pc, #336]	; (19f0 <_adc_init+0x20c>)
    189e:	0013      	movs	r3, r2
    18a0:	00db      	lsls	r3, r3, #3
    18a2:	1a9b      	subs	r3, r3, r2
    18a4:	009b      	lsls	r3, r3, #2
    18a6:	18cb      	adds	r3, r1, r3
    18a8:	3306      	adds	r3, #6
    18aa:	881a      	ldrh	r2, [r3, #0]
    18ac:	687b      	ldr	r3, [r7, #4]
    18ae:	0011      	movs	r1, r2
    18b0:	0018      	movs	r0, r3
    18b2:	4b53      	ldr	r3, [pc, #332]	; (1a00 <_adc_init+0x21c>)
    18b4:	4798      	blx	r3
	hri_adc_write_CTRLC_reg(hw, _adcs[i].ctrl_c);
    18b6:	1cfb      	adds	r3, r7, #3
    18b8:	781a      	ldrb	r2, [r3, #0]
    18ba:	494d      	ldr	r1, [pc, #308]	; (19f0 <_adc_init+0x20c>)
    18bc:	0013      	movs	r3, r2
    18be:	00db      	lsls	r3, r3, #3
    18c0:	1a9b      	subs	r3, r3, r2
    18c2:	009b      	lsls	r3, r3, #2
    18c4:	18cb      	adds	r3, r1, r3
    18c6:	3308      	adds	r3, #8
    18c8:	881a      	ldrh	r2, [r3, #0]
    18ca:	687b      	ldr	r3, [r7, #4]
    18cc:	0011      	movs	r1, r2
    18ce:	0018      	movs	r0, r3
    18d0:	4b4c      	ldr	r3, [pc, #304]	; (1a04 <_adc_init+0x220>)
    18d2:	4798      	blx	r3
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
    18d4:	1cfb      	adds	r3, r7, #3
    18d6:	781a      	ldrb	r2, [r3, #0]
    18d8:	4945      	ldr	r1, [pc, #276]	; (19f0 <_adc_init+0x20c>)
    18da:	0013      	movs	r3, r2
    18dc:	00db      	lsls	r3, r3, #3
    18de:	1a9b      	subs	r3, r3, r2
    18e0:	009b      	lsls	r3, r3, #2
    18e2:	18cb      	adds	r3, r1, r3
    18e4:	330a      	adds	r3, #10
    18e6:	781a      	ldrb	r2, [r3, #0]
    18e8:	687b      	ldr	r3, [r7, #4]
    18ea:	0011      	movs	r1, r2
    18ec:	0018      	movs	r0, r3
    18ee:	4b46      	ldr	r3, [pc, #280]	; (1a08 <_adc_init+0x224>)
    18f0:	4798      	blx	r3
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
    18f2:	1cfb      	adds	r3, r7, #3
    18f4:	781a      	ldrb	r2, [r3, #0]
    18f6:	493e      	ldr	r1, [pc, #248]	; (19f0 <_adc_init+0x20c>)
    18f8:	0013      	movs	r3, r2
    18fa:	00db      	lsls	r3, r3, #3
    18fc:	1a9b      	subs	r3, r3, r2
    18fe:	009b      	lsls	r3, r3, #2
    1900:	18cb      	adds	r3, r1, r3
    1902:	330b      	adds	r3, #11
    1904:	781a      	ldrb	r2, [r3, #0]
    1906:	687b      	ldr	r3, [r7, #4]
    1908:	0011      	movs	r1, r2
    190a:	0018      	movs	r0, r3
    190c:	4b3f      	ldr	r3, [pc, #252]	; (1a0c <_adc_init+0x228>)
    190e:	4798      	blx	r3
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
    1910:	1cfb      	adds	r3, r7, #3
    1912:	781a      	ldrb	r2, [r3, #0]
    1914:	4936      	ldr	r1, [pc, #216]	; (19f0 <_adc_init+0x20c>)
    1916:	0013      	movs	r3, r2
    1918:	00db      	lsls	r3, r3, #3
    191a:	1a9b      	subs	r3, r3, r2
    191c:	009b      	lsls	r3, r3, #2
    191e:	18cb      	adds	r3, r1, r3
    1920:	330c      	adds	r3, #12
    1922:	881a      	ldrh	r2, [r3, #0]
    1924:	687b      	ldr	r3, [r7, #4]
    1926:	0011      	movs	r1, r2
    1928:	0018      	movs	r0, r3
    192a:	4b39      	ldr	r3, [pc, #228]	; (1a10 <_adc_init+0x22c>)
    192c:	4798      	blx	r3
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
    192e:	1cfb      	adds	r3, r7, #3
    1930:	781a      	ldrb	r2, [r3, #0]
    1932:	492f      	ldr	r1, [pc, #188]	; (19f0 <_adc_init+0x20c>)
    1934:	0013      	movs	r3, r2
    1936:	00db      	lsls	r3, r3, #3
    1938:	1a9b      	subs	r3, r3, r2
    193a:	009b      	lsls	r3, r3, #2
    193c:	18cb      	adds	r3, r1, r3
    193e:	330e      	adds	r3, #14
    1940:	881a      	ldrh	r2, [r3, #0]
    1942:	687b      	ldr	r3, [r7, #4]
    1944:	0011      	movs	r1, r2
    1946:	0018      	movs	r0, r3
    1948:	4b32      	ldr	r3, [pc, #200]	; (1a14 <_adc_init+0x230>)
    194a:	4798      	blx	r3
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
    194c:	1cfb      	adds	r3, r7, #3
    194e:	781a      	ldrb	r2, [r3, #0]
    1950:	4927      	ldr	r1, [pc, #156]	; (19f0 <_adc_init+0x20c>)
    1952:	0013      	movs	r3, r2
    1954:	00db      	lsls	r3, r3, #3
    1956:	1a9b      	subs	r3, r3, r2
    1958:	009b      	lsls	r3, r3, #2
    195a:	18cb      	adds	r3, r1, r3
    195c:	3310      	adds	r3, #16
    195e:	881a      	ldrh	r2, [r3, #0]
    1960:	687b      	ldr	r3, [r7, #4]
    1962:	0011      	movs	r1, r2
    1964:	0018      	movs	r0, r3
    1966:	4b2c      	ldr	r3, [pc, #176]	; (1a18 <_adc_init+0x234>)
    1968:	4798      	blx	r3
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
    196a:	1cfb      	adds	r3, r7, #3
    196c:	781a      	ldrb	r2, [r3, #0]
    196e:	4920      	ldr	r1, [pc, #128]	; (19f0 <_adc_init+0x20c>)
    1970:	0013      	movs	r3, r2
    1972:	00db      	lsls	r3, r3, #3
    1974:	1a9b      	subs	r3, r3, r2
    1976:	009b      	lsls	r3, r3, #2
    1978:	18cb      	adds	r3, r1, r3
    197a:	3312      	adds	r3, #18
    197c:	881a      	ldrh	r2, [r3, #0]
    197e:	687b      	ldr	r3, [r7, #4]
    1980:	0011      	movs	r1, r2
    1982:	0018      	movs	r0, r3
    1984:	4b25      	ldr	r3, [pc, #148]	; (1a1c <_adc_init+0x238>)
    1986:	4798      	blx	r3
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
    1988:	1cfb      	adds	r3, r7, #3
    198a:	781a      	ldrb	r2, [r3, #0]
    198c:	4918      	ldr	r1, [pc, #96]	; (19f0 <_adc_init+0x20c>)
    198e:	0013      	movs	r3, r2
    1990:	00db      	lsls	r3, r3, #3
    1992:	1a9b      	subs	r3, r3, r2
    1994:	009b      	lsls	r3, r3, #2
    1996:	18cb      	adds	r3, r1, r3
    1998:	3314      	adds	r3, #20
    199a:	781a      	ldrb	r2, [r3, #0]
    199c:	687b      	ldr	r3, [r7, #4]
    199e:	0011      	movs	r1, r2
    19a0:	0018      	movs	r0, r3
    19a2:	4b1f      	ldr	r3, [pc, #124]	; (1a20 <_adc_init+0x23c>)
    19a4:	4798      	blx	r3
	hri_adc_write_SEQCTRL_reg(hw, _adcs[i].seq_ctrl);
    19a6:	2200      	movs	r2, #0
    19a8:	687b      	ldr	r3, [r7, #4]
    19aa:	0011      	movs	r1, r2
    19ac:	0018      	movs	r0, r3
    19ae:	4b1d      	ldr	r3, [pc, #116]	; (1a24 <_adc_init+0x240>)
    19b0:	4798      	blx	r3
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
    19b2:	1cfb      	adds	r3, r7, #3
    19b4:	781a      	ldrb	r2, [r3, #0]
    19b6:	490e      	ldr	r1, [pc, #56]	; (19f0 <_adc_init+0x20c>)
    19b8:	0013      	movs	r3, r2
    19ba:	00db      	lsls	r3, r3, #3
    19bc:	1a9b      	subs	r3, r3, r2
    19be:	009b      	lsls	r3, r3, #2
    19c0:	18cb      	adds	r3, r1, r3
    19c2:	3301      	adds	r3, #1
    19c4:	781a      	ldrb	r2, [r3, #0]
    19c6:	687b      	ldr	r3, [r7, #4]
    19c8:	0011      	movs	r1, r2
    19ca:	0018      	movs	r0, r3
    19cc:	4b07      	ldr	r3, [pc, #28]	; (19ec <_adc_init+0x208>)
    19ce:	4798      	blx	r3

	return ERR_NONE;
    19d0:	2300      	movs	r3, #0
}
    19d2:	0018      	movs	r0, r3
    19d4:	46bd      	mov	sp, r7
    19d6:	b002      	add	sp, #8
    19d8:	bd80      	pop	{r7, pc}
    19da:	46c0      	nop			; (mov r8, r8)
    19dc:	00001387 	.word	0x00001387
    19e0:	00001449 	.word	0x00001449
    19e4:	00001419 	.word	0x00001419
    19e8:	0000135d 	.word	0x0000135d
    19ec:	00001491 	.word	0x00001491
    19f0:	00005e5c 	.word	0x00005e5c
    19f4:	000014bd 	.word	0x000014bd
    19f8:	000014db 	.word	0x000014db
    19fc:	000014f9 	.word	0x000014f9
    1a00:	00001519 	.word	0x00001519
    1a04:	00001581 	.word	0x00001581
    1a08:	000015b5 	.word	0x000015b5
    1a0c:	000015e9 	.word	0x000015e9
    1a10:	0000161d 	.word	0x0000161d
    1a14:	00001649 	.word	0x00001649
    1a18:	00001675 	.word	0x00001675
    1a1c:	000016a5 	.word	0x000016a5
    1a20:	00001709 	.word	0x00001709
    1a24:	00001727 	.word	0x00001727

00001a28 <_adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t _adc_sync_init(struct _adc_sync_device *const device, void *const hw)
{
    1a28:	b580      	push	{r7, lr}
    1a2a:	b082      	sub	sp, #8
    1a2c:	af00      	add	r7, sp, #0
    1a2e:	6078      	str	r0, [r7, #4]
    1a30:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    1a32:	687b      	ldr	r3, [r7, #4]
    1a34:	1e5a      	subs	r2, r3, #1
    1a36:	4193      	sbcs	r3, r2
    1a38:	b2db      	uxtb	r3, r3
    1a3a:	490c      	ldr	r1, [pc, #48]	; (1a6c <_adc_sync_init+0x44>)
    1a3c:	22d4      	movs	r2, #212	; 0xd4
    1a3e:	0018      	movs	r0, r3
    1a40:	4b0b      	ldr	r3, [pc, #44]	; (1a70 <_adc_sync_init+0x48>)
    1a42:	4798      	blx	r3

	device->hw = hw;
    1a44:	687b      	ldr	r3, [r7, #4]
    1a46:	683a      	ldr	r2, [r7, #0]
    1a48:	601a      	str	r2, [r3, #0]

	return _adc_init(hw, _adc_get_regs((uint32_t)hw));
    1a4a:	683b      	ldr	r3, [r7, #0]
    1a4c:	0018      	movs	r0, r3
    1a4e:	4b09      	ldr	r3, [pc, #36]	; (1a74 <_adc_sync_init+0x4c>)
    1a50:	4798      	blx	r3
    1a52:	0003      	movs	r3, r0
    1a54:	001a      	movs	r2, r3
    1a56:	683b      	ldr	r3, [r7, #0]
    1a58:	0011      	movs	r1, r2
    1a5a:	0018      	movs	r0, r3
    1a5c:	4b06      	ldr	r3, [pc, #24]	; (1a78 <_adc_sync_init+0x50>)
    1a5e:	4798      	blx	r3
    1a60:	0003      	movs	r3, r0
}
    1a62:	0018      	movs	r0, r3
    1a64:	46bd      	mov	sp, r7
    1a66:	b002      	add	sp, #8
    1a68:	bd80      	pop	{r7, pc}
    1a6a:	46c0      	nop			; (mov r8, r8)
    1a6c:	00005e78 	.word	0x00005e78
    1a70:	00001331 	.word	0x00001331
    1a74:	00001761 	.word	0x00001761
    1a78:	000017e5 	.word	0x000017e5

00001a7c <_adc_sync_enable_channel>:

/**
 * \brief Enable ADC
 */
void _adc_sync_enable_channel(struct _adc_sync_device *const device, const uint8_t channel)
{
    1a7c:	b580      	push	{r7, lr}
    1a7e:	b082      	sub	sp, #8
    1a80:	af00      	add	r7, sp, #0
    1a82:	6078      	str	r0, [r7, #4]
    1a84:	000a      	movs	r2, r1
    1a86:	1cfb      	adds	r3, r7, #3
    1a88:	701a      	strb	r2, [r3, #0]
	(void)channel;

	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
    1a8a:	687b      	ldr	r3, [r7, #4]
    1a8c:	681b      	ldr	r3, [r3, #0]
    1a8e:	0018      	movs	r0, r3
    1a90:	4b02      	ldr	r3, [pc, #8]	; (1a9c <_adc_sync_enable_channel+0x20>)
    1a92:	4798      	blx	r3
}
    1a94:	46c0      	nop			; (mov r8, r8)
    1a96:	46bd      	mov	sp, r7
    1a98:	b002      	add	sp, #8
    1a9a:	bd80      	pop	{r7, pc}
    1a9c:	000013e9 	.word	0x000013e9

00001aa0 <_adc_sync_disable_channel>:

/**
 * \brief Disable ADC
 */
void _adc_sync_disable_channel(struct _adc_sync_device *const device, const uint8_t channel)
{
    1aa0:	b580      	push	{r7, lr}
    1aa2:	b082      	sub	sp, #8
    1aa4:	af00      	add	r7, sp, #0
    1aa6:	6078      	str	r0, [r7, #4]
    1aa8:	000a      	movs	r2, r1
    1aaa:	1cfb      	adds	r3, r7, #3
    1aac:	701a      	strb	r2, [r3, #0]
	(void)channel;

	hri_adc_clear_CTRLA_ENABLE_bit(device->hw);
    1aae:	687b      	ldr	r3, [r7, #4]
    1ab0:	681b      	ldr	r3, [r3, #0]
    1ab2:	0018      	movs	r0, r3
    1ab4:	4b02      	ldr	r3, [pc, #8]	; (1ac0 <_adc_sync_disable_channel+0x20>)
    1ab6:	4798      	blx	r3
}
    1ab8:	46c0      	nop			; (mov r8, r8)
    1aba:	46bd      	mov	sp, r7
    1abc:	b002      	add	sp, #8
    1abe:	bd80      	pop	{r7, pc}
    1ac0:	00001419 	.word	0x00001419

00001ac4 <_adc_sync_get_data_size>:

/**
 * \brief Retrieve ADC conversion data size
 */
uint8_t _adc_sync_get_data_size(const struct _adc_sync_device *const device)
{
    1ac4:	b580      	push	{r7, lr}
    1ac6:	b082      	sub	sp, #8
    1ac8:	af00      	add	r7, sp, #0
    1aca:	6078      	str	r0, [r7, #4]
	return hri_adc_read_CTRLC_RESSEL_bf(device->hw) == ADC_CTRLC_RESSEL_8BIT_Val ? 1 : 2;
    1acc:	687b      	ldr	r3, [r7, #4]
    1ace:	681b      	ldr	r3, [r3, #0]
    1ad0:	0018      	movs	r0, r3
    1ad2:	4b06      	ldr	r3, [pc, #24]	; (1aec <_adc_sync_get_data_size+0x28>)
    1ad4:	4798      	blx	r3
    1ad6:	0003      	movs	r3, r0
    1ad8:	2b03      	cmp	r3, #3
    1ada:	d101      	bne.n	1ae0 <_adc_sync_get_data_size+0x1c>
    1adc:	2301      	movs	r3, #1
    1ade:	e000      	b.n	1ae2 <_adc_sync_get_data_size+0x1e>
    1ae0:	2302      	movs	r3, #2
}
    1ae2:	0018      	movs	r0, r3
    1ae4:	46bd      	mov	sp, r7
    1ae6:	b002      	add	sp, #8
    1ae8:	bd80      	pop	{r7, pc}
    1aea:	46c0      	nop			; (mov r8, r8)
    1aec:	0000154d 	.word	0x0000154d

00001af0 <_adc_sync_is_channel_conversion_done>:

/**
 * \brief Check if conversion is done
 */
bool _adc_sync_is_channel_conversion_done(const struct _adc_sync_device *const device, const uint8_t channel)
{
    1af0:	b580      	push	{r7, lr}
    1af2:	b082      	sub	sp, #8
    1af4:	af00      	add	r7, sp, #0
    1af6:	6078      	str	r0, [r7, #4]
    1af8:	000a      	movs	r2, r1
    1afa:	1cfb      	adds	r3, r7, #3
    1afc:	701a      	strb	r2, [r3, #0]
	(void)channel;

	return hri_adc_get_interrupt_RESRDY_bit(device->hw);
    1afe:	687b      	ldr	r3, [r7, #4]
    1b00:	681b      	ldr	r3, [r3, #0]
    1b02:	0018      	movs	r0, r3
    1b04:	4b03      	ldr	r3, [pc, #12]	; (1b14 <_adc_sync_is_channel_conversion_done+0x24>)
    1b06:	4798      	blx	r3
    1b08:	0003      	movs	r3, r0
}
    1b0a:	0018      	movs	r0, r3
    1b0c:	46bd      	mov	sp, r7
    1b0e:	b002      	add	sp, #8
    1b10:	bd80      	pop	{r7, pc}
    1b12:	46c0      	nop			; (mov r8, r8)
    1b14:	000013b1 	.word	0x000013b1

00001b18 <_adc_sync_convert>:

/**
 * \brief Make conversion
 */
void _adc_sync_convert(struct _adc_sync_device *const device)
{
    1b18:	b580      	push	{r7, lr}
    1b1a:	b082      	sub	sp, #8
    1b1c:	af00      	add	r7, sp, #0
    1b1e:	6078      	str	r0, [r7, #4]
	hri_adc_set_SWTRIG_START_bit(device->hw);
    1b20:	687b      	ldr	r3, [r7, #4]
    1b22:	681b      	ldr	r3, [r3, #0]
    1b24:	0018      	movs	r0, r3
    1b26:	4b03      	ldr	r3, [pc, #12]	; (1b34 <_adc_sync_convert+0x1c>)
    1b28:	4798      	blx	r3
}
    1b2a:	46c0      	nop			; (mov r8, r8)
    1b2c:	46bd      	mov	sp, r7
    1b2e:	b002      	add	sp, #8
    1b30:	bd80      	pop	{r7, pc}
    1b32:	46c0      	nop			; (mov r8, r8)
    1b34:	000016d5 	.word	0x000016d5

00001b38 <_adc_sync_read_channel_data>:

/**
 * \brief Retrieve the conversion result
 */
uint16_t _adc_sync_read_channel_data(const struct _adc_sync_device *const device, const uint8_t channel)
{
    1b38:	b580      	push	{r7, lr}
    1b3a:	b082      	sub	sp, #8
    1b3c:	af00      	add	r7, sp, #0
    1b3e:	6078      	str	r0, [r7, #4]
    1b40:	000a      	movs	r2, r1
    1b42:	1cfb      	adds	r3, r7, #3
    1b44:	701a      	strb	r2, [r3, #0]
	(void)channel;

	return hri_adc_read_RESULT_reg(device->hw);
    1b46:	687b      	ldr	r3, [r7, #4]
    1b48:	681b      	ldr	r3, [r3, #0]
    1b4a:	0018      	movs	r0, r3
    1b4c:	4b03      	ldr	r3, [pc, #12]	; (1b5c <_adc_sync_read_channel_data+0x24>)
    1b4e:	4798      	blx	r3
    1b50:	0003      	movs	r3, r0
}
    1b52:	0018      	movs	r0, r3
    1b54:	46bd      	mov	sp, r7
    1b56:	b002      	add	sp, #8
    1b58:	bd80      	pop	{r7, pc}
    1b5a:	46c0      	nop			; (mov r8, r8)
    1b5c:	000013d3 	.word	0x000013d3

00001b60 <_adc_get_adc_sync>:

/**
 * \brief Retrieve ADC sync helper functions
 */
void *_adc_get_adc_sync(void)
{
    1b60:	b580      	push	{r7, lr}
    1b62:	af00      	add	r7, sp, #0
	return (void *)NULL;
    1b64:	2300      	movs	r3, #0
}
    1b66:	0018      	movs	r0, r3
    1b68:	46bd      	mov	sp, r7
    1b6a:	bd80      	pop	{r7, pc}

00001b6c <hri_nvmctrl_set_CTRLB_RWS_bf>:
	((Nvmctrl *)hw)->CTRLB.reg ^= NVMCTRL_CTRLB_MANW;
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
    1b6c:	b580      	push	{r7, lr}
    1b6e:	b082      	sub	sp, #8
    1b70:	af00      	add	r7, sp, #0
    1b72:	6078      	str	r0, [r7, #4]
    1b74:	6039      	str	r1, [r7, #0]
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    1b76:	687b      	ldr	r3, [r7, #4]
    1b78:	685a      	ldr	r2, [r3, #4]
    1b7a:	683b      	ldr	r3, [r7, #0]
    1b7c:	005b      	lsls	r3, r3, #1
    1b7e:	211e      	movs	r1, #30
    1b80:	400b      	ands	r3, r1
    1b82:	431a      	orrs	r2, r3
    1b84:	687b      	ldr	r3, [r7, #4]
    1b86:	605a      	str	r2, [r3, #4]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
    1b88:	46c0      	nop			; (mov r8, r8)
    1b8a:	46bd      	mov	sp, r7
    1b8c:	b002      	add	sp, #8
    1b8e:	bd80      	pop	{r7, pc}

00001b90 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    1b90:	b580      	push	{r7, lr}
    1b92:	af00      	add	r7, sp, #0
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);
    1b94:	4b0a      	ldr	r3, [pc, #40]	; (1bc0 <_init_chip+0x30>)
    1b96:	2100      	movs	r1, #0
    1b98:	0018      	movs	r0, r3
    1b9a:	4b0a      	ldr	r3, [pc, #40]	; (1bc4 <_init_chip+0x34>)
    1b9c:	4798      	blx	r3

	_osc32kctrl_init_sources();
    1b9e:	4b0a      	ldr	r3, [pc, #40]	; (1bc8 <_init_chip+0x38>)
    1ba0:	4798      	blx	r3
	_oscctrl_init_sources();
    1ba2:	4b0a      	ldr	r3, [pc, #40]	; (1bcc <_init_chip+0x3c>)
    1ba4:	4798      	blx	r3
	_mclk_init();
    1ba6:	4b0a      	ldr	r3, [pc, #40]	; (1bd0 <_init_chip+0x40>)
    1ba8:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
    1baa:	4b0a      	ldr	r3, [pc, #40]	; (1bd4 <_init_chip+0x44>)
    1bac:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1bae:	20ff      	movs	r0, #255	; 0xff
    1bb0:	4b09      	ldr	r3, [pc, #36]	; (1bd8 <_init_chip+0x48>)
    1bb2:	4798      	blx	r3

	_div_init();
    1bb4:	4b09      	ldr	r3, [pc, #36]	; (1bdc <_init_chip+0x4c>)
    1bb6:	4798      	blx	r3
#endif

#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif
}
    1bb8:	46c0      	nop			; (mov r8, r8)
    1bba:	46bd      	mov	sp, r7
    1bbc:	bd80      	pop	{r7, pc}
    1bbe:	46c0      	nop			; (mov r8, r8)
    1bc0:	41004000 	.word	0x41004000
    1bc4:	00001b6d 	.word	0x00001b6d
    1bc8:	00001e3d 	.word	0x00001e3d
    1bcc:	00001f81 	.word	0x00001f81
    1bd0:	00001dc5 	.word	0x00001dc5
    1bd4:	00001ffd 	.word	0x00001ffd
    1bd8:	00001d5d 	.word	0x00001d5d
    1bdc:	00001c95 	.word	0x00001c95

00001be0 <hri_divas_write_CTRLA_DLZ_bit>:
	tmp = (tmp & DIVAS_CTRLA_DLZ) >> DIVAS_CTRLA_DLZ_Pos;
	return (bool)tmp;
}

static inline void hri_divas_write_CTRLA_DLZ_bit(const void *const hw, bool value)
{
    1be0:	b580      	push	{r7, lr}
    1be2:	b084      	sub	sp, #16
    1be4:	af00      	add	r7, sp, #0
    1be6:	6078      	str	r0, [r7, #4]
    1be8:	000a      	movs	r2, r1
    1bea:	1cfb      	adds	r3, r7, #3
    1bec:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	DIVAS_CRITICAL_SECTION_ENTER();
	tmp = ((Divas *)hw)->CTRLA.reg;
    1bee:	230f      	movs	r3, #15
    1bf0:	18fb      	adds	r3, r7, r3
    1bf2:	687a      	ldr	r2, [r7, #4]
    1bf4:	7812      	ldrb	r2, [r2, #0]
    1bf6:	701a      	strb	r2, [r3, #0]
	tmp &= ~DIVAS_CTRLA_DLZ;
    1bf8:	230f      	movs	r3, #15
    1bfa:	18fb      	adds	r3, r7, r3
    1bfc:	220f      	movs	r2, #15
    1bfe:	18ba      	adds	r2, r7, r2
    1c00:	7812      	ldrb	r2, [r2, #0]
    1c02:	2102      	movs	r1, #2
    1c04:	438a      	bics	r2, r1
    1c06:	701a      	strb	r2, [r3, #0]
	tmp |= value << DIVAS_CTRLA_DLZ_Pos;
    1c08:	1cfb      	adds	r3, r7, #3
    1c0a:	781b      	ldrb	r3, [r3, #0]
    1c0c:	005b      	lsls	r3, r3, #1
    1c0e:	b25a      	sxtb	r2, r3
    1c10:	230f      	movs	r3, #15
    1c12:	18fb      	adds	r3, r7, r3
    1c14:	781b      	ldrb	r3, [r3, #0]
    1c16:	b25b      	sxtb	r3, r3
    1c18:	4313      	orrs	r3, r2
    1c1a:	b25a      	sxtb	r2, r3
    1c1c:	230f      	movs	r3, #15
    1c1e:	18fb      	adds	r3, r7, r3
    1c20:	701a      	strb	r2, [r3, #0]
	((Divas *)hw)->CTRLA.reg = tmp;
    1c22:	687b      	ldr	r3, [r7, #4]
    1c24:	220f      	movs	r2, #15
    1c26:	18ba      	adds	r2, r7, r2
    1c28:	7812      	ldrb	r2, [r2, #0]
    1c2a:	701a      	strb	r2, [r3, #0]
	DIVAS_CRITICAL_SECTION_LEAVE();
}
    1c2c:	46c0      	nop			; (mov r8, r8)
    1c2e:	46bd      	mov	sp, r7
    1c30:	b004      	add	sp, #16
    1c32:	bd80      	pop	{r7, pc}

00001c34 <_divas_div>:
 *  \param[in] s Indicate operation mode: signed/unsigned
 *  \param[in] n The dividend
 *  \param[in] d The divisor
 */
static inline void _divas_div(const uint8_t s, const uint32_t n, const uint32_t d)
{
    1c34:	b580      	push	{r7, lr}
    1c36:	b084      	sub	sp, #16
    1c38:	af00      	add	r7, sp, #0
    1c3a:	60b9      	str	r1, [r7, #8]
    1c3c:	607a      	str	r2, [r7, #4]
    1c3e:	230f      	movs	r3, #15
    1c40:	18fb      	adds	r3, r7, r3
    1c42:	1c02      	adds	r2, r0, #0
    1c44:	701a      	strb	r2, [r3, #0]
	DIVAS->CTRLA.bit.SIGNED = s;
    1c46:	2390      	movs	r3, #144	; 0x90
    1c48:	05da      	lsls	r2, r3, #23
    1c4a:	230f      	movs	r3, #15
    1c4c:	18fb      	adds	r3, r7, r3
    1c4e:	781b      	ldrb	r3, [r3, #0]
    1c50:	2101      	movs	r1, #1
    1c52:	400b      	ands	r3, r1
    1c54:	b2d9      	uxtb	r1, r3
    1c56:	7813      	ldrb	r3, [r2, #0]
    1c58:	2001      	movs	r0, #1
    1c5a:	4008      	ands	r0, r1
    1c5c:	2101      	movs	r1, #1
    1c5e:	438b      	bics	r3, r1
    1c60:	1c19      	adds	r1, r3, #0
    1c62:	1c03      	adds	r3, r0, #0
    1c64:	430b      	orrs	r3, r1
    1c66:	7013      	strb	r3, [r2, #0]
	DIVAS->DIVIDEND.reg     = n;
    1c68:	2390      	movs	r3, #144	; 0x90
    1c6a:	05db      	lsls	r3, r3, #23
    1c6c:	68ba      	ldr	r2, [r7, #8]
    1c6e:	609a      	str	r2, [r3, #8]
	DIVAS->DIVISOR.reg      = d;
    1c70:	2390      	movs	r3, #144	; 0x90
    1c72:	05db      	lsls	r3, r3, #23
    1c74:	687a      	ldr	r2, [r7, #4]
    1c76:	60da      	str	r2, [r3, #12]
	while (DIVAS->STATUS.bit.BUSY) {
    1c78:	46c0      	nop			; (mov r8, r8)
    1c7a:	2390      	movs	r3, #144	; 0x90
    1c7c:	05db      	lsls	r3, r3, #23
    1c7e:	791b      	ldrb	r3, [r3, #4]
    1c80:	07db      	lsls	r3, r3, #31
    1c82:	0fdb      	lsrs	r3, r3, #31
    1c84:	b2db      	uxtb	r3, r3
    1c86:	2b00      	cmp	r3, #0
    1c88:	d1f7      	bne.n	1c7a <_divas_div+0x46>
		/* Wait the division is complete. */
	}
}
    1c8a:	46c0      	nop			; (mov r8, r8)
    1c8c:	46bd      	mov	sp, r7
    1c8e:	b004      	add	sp, #16
    1c90:	bd80      	pop	{r7, pc}
	...

00001c94 <_div_init>:

/**
 * \brief Initialize hardware for division operation
 */
void _div_init(void)
{
    1c94:	b580      	push	{r7, lr}
    1c96:	af00      	add	r7, sp, #0
	hri_divas_write_CTRLA_DLZ_bit(DIVAS, CONF_DIVAS_DLZ);
    1c98:	2390      	movs	r3, #144	; 0x90
    1c9a:	05db      	lsls	r3, r3, #23
    1c9c:	2100      	movs	r1, #0
    1c9e:	0018      	movs	r0, r3
    1ca0:	4b02      	ldr	r3, [pc, #8]	; (1cac <_div_init+0x18>)
    1ca2:	4798      	blx	r3
}
    1ca4:	46c0      	nop			; (mov r8, r8)
    1ca6:	46bd      	mov	sp, r7
    1ca8:	bd80      	pop	{r7, pc}
    1caa:	46c0      	nop			; (mov r8, r8)
    1cac:	00001be1 	.word	0x00001be1

00001cb0 <__aeabi_idivmod>:

/**
 * \brief Do signed division, return result and remainder
 */
uint64_t __aeabi_idivmod(int numerator, int denominator)
{
    1cb0:	b590      	push	{r4, r7, lr}
    1cb2:	b089      	sub	sp, #36	; 0x24
    1cb4:	af00      	add	r7, sp, #0
    1cb6:	6078      	str	r0, [r7, #4]
    1cb8:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    1cba:	f3ef 8310 	mrs	r3, PRIMASK
    1cbe:	613b      	str	r3, [r7, #16]
  return(result);
    1cc0:	693b      	ldr	r3, [r7, #16]
	uint64_t res;
	_DIVAS_CRITICAL_ENTER();
    1cc2:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsid i" : : : "memory");
    1cc4:	b672      	cpsid	i
	_divas_div(1, numerator, denominator);
    1cc6:	687b      	ldr	r3, [r7, #4]
    1cc8:	683a      	ldr	r2, [r7, #0]
    1cca:	0019      	movs	r1, r3
    1ccc:	2001      	movs	r0, #1
    1cce:	4b09      	ldr	r3, [pc, #36]	; (1cf4 <__aeabi_idivmod+0x44>)
    1cd0:	4798      	blx	r3
	res = _divas_result64();
    1cd2:	4b09      	ldr	r3, [pc, #36]	; (1cf8 <__aeabi_idivmod+0x48>)
    1cd4:	685c      	ldr	r4, [r3, #4]
    1cd6:	681b      	ldr	r3, [r3, #0]
    1cd8:	61bb      	str	r3, [r7, #24]
    1cda:	61fc      	str	r4, [r7, #28]
	_DIVAS_CRITICAL_LEAVE();
    1cdc:	68fb      	ldr	r3, [r7, #12]
    1cde:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    1ce0:	697b      	ldr	r3, [r7, #20]
    1ce2:	f383 8810 	msr	PRIMASK, r3
	return res;
    1ce6:	69bb      	ldr	r3, [r7, #24]
    1ce8:	69fc      	ldr	r4, [r7, #28]
}
    1cea:	0018      	movs	r0, r3
    1cec:	0021      	movs	r1, r4
    1cee:	46bd      	mov	sp, r7
    1cf0:	b009      	add	sp, #36	; 0x24
    1cf2:	bd90      	pop	{r4, r7, pc}
    1cf4:	00001c35 	.word	0x00001c35
    1cf8:	48000010 	.word	0x48000010

00001cfc <hri_gclk_wait_for_sync>:
{
    1cfc:	b580      	push	{r7, lr}
    1cfe:	b082      	sub	sp, #8
    1d00:	af00      	add	r7, sp, #0
    1d02:	6078      	str	r0, [r7, #4]
    1d04:	6039      	str	r1, [r7, #0]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1d06:	46c0      	nop			; (mov r8, r8)
    1d08:	687b      	ldr	r3, [r7, #4]
    1d0a:	685b      	ldr	r3, [r3, #4]
    1d0c:	683a      	ldr	r2, [r7, #0]
    1d0e:	4013      	ands	r3, r2
    1d10:	d1fa      	bne.n	1d08 <hri_gclk_wait_for_sync+0xc>
}
    1d12:	46c0      	nop			; (mov r8, r8)
    1d14:	46bd      	mov	sp, r7
    1d16:	b002      	add	sp, #8
    1d18:	bd80      	pop	{r7, pc}
	...

00001d1c <hri_gclk_write_GENCTRL_reg>:
{
    1d1c:	b580      	push	{r7, lr}
    1d1e:	b084      	sub	sp, #16
    1d20:	af00      	add	r7, sp, #0
    1d22:	60f8      	str	r0, [r7, #12]
    1d24:	607a      	str	r2, [r7, #4]
    1d26:	230b      	movs	r3, #11
    1d28:	18fb      	adds	r3, r7, r3
    1d2a:	1c0a      	adds	r2, r1, #0
    1d2c:	701a      	strb	r2, [r3, #0]
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1d2e:	230b      	movs	r3, #11
    1d30:	18fb      	adds	r3, r7, r3
    1d32:	781a      	ldrb	r2, [r3, #0]
    1d34:	68fb      	ldr	r3, [r7, #12]
    1d36:	3208      	adds	r2, #8
    1d38:	0092      	lsls	r2, r2, #2
    1d3a:	6879      	ldr	r1, [r7, #4]
    1d3c:	50d1      	str	r1, [r2, r3]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    1d3e:	4a05      	ldr	r2, [pc, #20]	; (1d54 <hri_gclk_write_GENCTRL_reg+0x38>)
    1d40:	68fb      	ldr	r3, [r7, #12]
    1d42:	0011      	movs	r1, r2
    1d44:	0018      	movs	r0, r3
    1d46:	4b04      	ldr	r3, [pc, #16]	; (1d58 <hri_gclk_write_GENCTRL_reg+0x3c>)
    1d48:	4798      	blx	r3
}
    1d4a:	46c0      	nop			; (mov r8, r8)
    1d4c:	46bd      	mov	sp, r7
    1d4e:	b004      	add	sp, #16
    1d50:	bd80      	pop	{r7, pc}
    1d52:	46c0      	nop			; (mov r8, r8)
    1d54:	000007fd 	.word	0x000007fd
    1d58:	00001cfd 	.word	0x00001cfd

00001d5c <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    1d5c:	b580      	push	{r7, lr}
    1d5e:	b082      	sub	sp, #8
    1d60:	af00      	add	r7, sp, #0
    1d62:	6078      	str	r0, [r7, #4]

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    1d64:	687b      	ldr	r3, [r7, #4]
    1d66:	2201      	movs	r2, #1
    1d68:	4013      	ands	r3, r2
    1d6a:	d005      	beq.n	1d78 <_gclk_init_generators_by_fref+0x1c>
		hri_gclk_write_GENCTRL_reg(
    1d6c:	4a09      	ldr	r2, [pc, #36]	; (1d94 <_gclk_init_generators_by_fref+0x38>)
    1d6e:	4b0a      	ldr	r3, [pc, #40]	; (1d98 <_gclk_init_generators_by_fref+0x3c>)
    1d70:	2100      	movs	r1, #0
    1d72:	0018      	movs	r0, r3
    1d74:	4b09      	ldr	r3, [pc, #36]	; (1d9c <_gclk_init_generators_by_fref+0x40>)
    1d76:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    1d78:	687b      	ldr	r3, [r7, #4]
    1d7a:	2204      	movs	r2, #4
    1d7c:	4013      	ands	r3, r2
    1d7e:	d005      	beq.n	1d8c <_gclk_init_generators_by_fref+0x30>
		hri_gclk_write_GENCTRL_reg(
    1d80:	4a07      	ldr	r2, [pc, #28]	; (1da0 <_gclk_init_generators_by_fref+0x44>)
    1d82:	4b05      	ldr	r3, [pc, #20]	; (1d98 <_gclk_init_generators_by_fref+0x3c>)
    1d84:	2102      	movs	r1, #2
    1d86:	0018      	movs	r0, r3
    1d88:	4b04      	ldr	r3, [pc, #16]	; (1d9c <_gclk_init_generators_by_fref+0x40>)
    1d8a:	4798      	blx	r3
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SOURCE);
	}
#endif
}
    1d8c:	46c0      	nop			; (mov r8, r8)
    1d8e:	46bd      	mov	sp, r7
    1d90:	b002      	add	sp, #8
    1d92:	bd80      	pop	{r7, pc}
    1d94:	00010106 	.word	0x00010106
    1d98:	40001c00 	.word	0x40001c00
    1d9c:	00001d1d 	.word	0x00001d1d
    1da0:	00010103 	.word	0x00010103

00001da4 <hri_mclk_write_CPUDIV_reg>:
{
    1da4:	b580      	push	{r7, lr}
    1da6:	b082      	sub	sp, #8
    1da8:	af00      	add	r7, sp, #0
    1daa:	6078      	str	r0, [r7, #4]
    1dac:	000a      	movs	r2, r1
    1dae:	1cfb      	adds	r3, r7, #3
    1db0:	701a      	strb	r2, [r3, #0]
	((Mclk *)hw)->CPUDIV.reg = data;
    1db2:	687b      	ldr	r3, [r7, #4]
    1db4:	1cfa      	adds	r2, r7, #3
    1db6:	7812      	ldrb	r2, [r2, #0]
    1db8:	711a      	strb	r2, [r3, #4]
}
    1dba:	46c0      	nop			; (mov r8, r8)
    1dbc:	46bd      	mov	sp, r7
    1dbe:	b002      	add	sp, #8
    1dc0:	bd80      	pop	{r7, pc}
	...

00001dc4 <_mclk_init>:

/**
 * \brief Initialize master clock generator
 */
void _mclk_init(void)
{
    1dc4:	b580      	push	{r7, lr}
    1dc6:	b082      	sub	sp, #8
    1dc8:	af00      	add	r7, sp, #0
	void *hw = (void *)MCLK;
    1dca:	4b05      	ldr	r3, [pc, #20]	; (1de0 <_mclk_init+0x1c>)
    1dcc:	607b      	str	r3, [r7, #4]
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_CPUDIV(CONF_MCLK_CPUDIV));
    1dce:	687b      	ldr	r3, [r7, #4]
    1dd0:	2101      	movs	r1, #1
    1dd2:	0018      	movs	r0, r3
    1dd4:	4b03      	ldr	r3, [pc, #12]	; (1de4 <_mclk_init+0x20>)
    1dd6:	4798      	blx	r3
}
    1dd8:	46c0      	nop			; (mov r8, r8)
    1dda:	46bd      	mov	sp, r7
    1ddc:	b002      	add	sp, #8
    1dde:	bd80      	pop	{r7, pc}
    1de0:	40000800 	.word	0x40000800
    1de4:	00001da5 	.word	0x00001da5

00001de8 <hri_osc32kctrl_write_RTCCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_RTCCTRL_reg(const void *const hw, hri_osc32kctrl_rtcctrl_reg_t data)
{
    1de8:	b580      	push	{r7, lr}
    1dea:	b082      	sub	sp, #8
    1dec:	af00      	add	r7, sp, #0
    1dee:	6078      	str	r0, [r7, #4]
    1df0:	6039      	str	r1, [r7, #0]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    1df2:	687b      	ldr	r3, [r7, #4]
    1df4:	683a      	ldr	r2, [r7, #0]
    1df6:	611a      	str	r2, [r3, #16]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
    1df8:	46c0      	nop			; (mov r8, r8)
    1dfa:	46bd      	mov	sp, r7
    1dfc:	b002      	add	sp, #8
    1dfe:	bd80      	pop	{r7, pc}

00001e00 <hri_osc32kctrl_read_OSCULP32K_CALIB_bf>:
	((Osc32kctrl *)hw)->OSCULP32K.reg ^= OSC32KCTRL_OSCULP32K_CALIB(mask);
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
    1e00:	b580      	push	{r7, lr}
    1e02:	b084      	sub	sp, #16
    1e04:	af00      	add	r7, sp, #0
    1e06:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    1e08:	687b      	ldr	r3, [r7, #4]
    1e0a:	69db      	ldr	r3, [r3, #28]
    1e0c:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & OSC32KCTRL_OSCULP32K_CALIB_Msk) >> OSC32KCTRL_OSCULP32K_CALIB_Pos;
    1e0e:	68fb      	ldr	r3, [r7, #12]
    1e10:	0a1b      	lsrs	r3, r3, #8
    1e12:	221f      	movs	r2, #31
    1e14:	4013      	ands	r3, r2
    1e16:	60fb      	str	r3, [r7, #12]
	return tmp;
    1e18:	68fb      	ldr	r3, [r7, #12]
}
    1e1a:	0018      	movs	r0, r3
    1e1c:	46bd      	mov	sp, r7
    1e1e:	b004      	add	sp, #16
    1e20:	bd80      	pop	{r7, pc}

00001e22 <hri_osc32kctrl_write_OSCULP32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
    1e22:	b580      	push	{r7, lr}
    1e24:	b082      	sub	sp, #8
    1e26:	af00      	add	r7, sp, #0
    1e28:	6078      	str	r0, [r7, #4]
    1e2a:	6039      	str	r1, [r7, #0]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    1e2c:	687b      	ldr	r3, [r7, #4]
    1e2e:	683a      	ldr	r2, [r7, #0]
    1e30:	61da      	str	r2, [r3, #28]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
    1e32:	46c0      	nop			; (mov r8, r8)
    1e34:	46bd      	mov	sp, r7
    1e36:	b002      	add	sp, #8
    1e38:	bd80      	pop	{r7, pc}
	...

00001e3c <_osc32kctrl_init_sources>:

/**
 * \brief Initialize 32 kHz clock sources
 */
void _osc32kctrl_init_sources(void)
{
    1e3c:	b580      	push	{r7, lr}
    1e3e:	b082      	sub	sp, #8
    1e40:	af00      	add	r7, sp, #0
	void *   hw    = (void *)OSC32KCTRL;
    1e42:	4b10      	ldr	r3, [pc, #64]	; (1e84 <_osc32kctrl_init_sources+0x48>)
    1e44:	607b      	str	r3, [r7, #4]
	uint16_t calib = 0;
    1e46:	1cbb      	adds	r3, r7, #2
    1e48:	2200      	movs	r2, #0
    1e4a:	801a      	strh	r2, [r3, #0]
	        | (CONF_OSC32K_RUNSTDBY << OSC32KCTRL_OSC32K_RUNSTDBY_Pos)
	        | (CONF_OSC32K_EN1K << OSC32KCTRL_OSC32K_EN1K_Pos) | (CONF_OSC32K_EN32K << OSC32KCTRL_OSC32K_EN32K_Pos)
	        | (CONF_OSC32K_ENABLE << OSC32KCTRL_OSC32K_ENABLE_Pos));
#endif
#if CONF_OSCULP32K_CONFIG == 1
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
    1e4c:	687b      	ldr	r3, [r7, #4]
    1e4e:	0018      	movs	r0, r3
    1e50:	4b0d      	ldr	r3, [pc, #52]	; (1e88 <_osc32kctrl_init_sources+0x4c>)
    1e52:	4798      	blx	r3
    1e54:	0002      	movs	r2, r0
    1e56:	1cbb      	adds	r3, r7, #2
    1e58:	801a      	strh	r2, [r3, #0]
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSC32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSC32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    1e5a:	1cbb      	adds	r3, r7, #2
    1e5c:	881b      	ldrh	r3, [r3, #0]
    1e5e:	021b      	lsls	r3, r3, #8
    1e60:	001a      	movs	r2, r3
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
    1e62:	23f8      	movs	r3, #248	; 0xf8
    1e64:	015b      	lsls	r3, r3, #5
    1e66:	401a      	ands	r2, r3
    1e68:	687b      	ldr	r3, [r7, #4]
    1e6a:	0011      	movs	r1, r2
    1e6c:	0018      	movs	r0, r3
    1e6e:	4b07      	ldr	r3, [pc, #28]	; (1e8c <_osc32kctrl_init_sources+0x50>)
    1e70:	4798      	blx	r3
#if CONF_OSC32K_ENABLE == 1 && CONF_OSC32K_ONDEMAND == 0
	while (!hri_osc32kctrl_get_STATUS_OSC32KRDY_bit(hw))
		;
#endif
#endif
	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
    1e72:	687b      	ldr	r3, [r7, #4]
    1e74:	2100      	movs	r1, #0
    1e76:	0018      	movs	r0, r3
    1e78:	4b05      	ldr	r3, [pc, #20]	; (1e90 <_osc32kctrl_init_sources+0x54>)
    1e7a:	4798      	blx	r3
	(void)calib;
}
    1e7c:	46c0      	nop			; (mov r8, r8)
    1e7e:	46bd      	mov	sp, r7
    1e80:	b002      	add	sp, #8
    1e82:	bd80      	pop	{r7, pc}
    1e84:	40001400 	.word	0x40001400
    1e88:	00001e01 	.word	0x00001e01
    1e8c:	00001e23 	.word	0x00001e23
    1e90:	00001de9 	.word	0x00001de9

00001e94 <hri_oscctrl_osc48msyncbusy_wait_for_sync>:
typedef uint8_t  hri_oscctrl_osc48mctrl_reg_t;
typedef uint8_t  hri_oscctrl_osc48mdiv_reg_t;
typedef uint8_t  hri_oscctrl_osc48mstup_reg_t;

static inline void hri_oscctrl_osc48msyncbusy_wait_for_sync(const void *const hw, hri_oscctrl_osc48msyncbusy_reg_t reg)
{
    1e94:	b580      	push	{r7, lr}
    1e96:	b082      	sub	sp, #8
    1e98:	af00      	add	r7, sp, #0
    1e9a:	6078      	str	r0, [r7, #4]
    1e9c:	6039      	str	r1, [r7, #0]
	while (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & reg) {
    1e9e:	46c0      	nop			; (mov r8, r8)
    1ea0:	687b      	ldr	r3, [r7, #4]
    1ea2:	699b      	ldr	r3, [r3, #24]
    1ea4:	683a      	ldr	r2, [r7, #0]
    1ea6:	4013      	ands	r3, r2
    1ea8:	d1fa      	bne.n	1ea0 <hri_oscctrl_osc48msyncbusy_wait_for_sync+0xc>
	};
}
    1eaa:	46c0      	nop			; (mov r8, r8)
    1eac:	46bd      	mov	sp, r7
    1eae:	b002      	add	sp, #8
    1eb0:	bd80      	pop	{r7, pc}

00001eb2 <hri_oscctrl_get_STATUS_OSC48MRDY_bit>:
{
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCCKSW) >> OSCCTRL_STATUS_XOSCCKSW_Pos;
}

static inline bool hri_oscctrl_get_STATUS_OSC48MRDY_bit(const void *const hw)
{
    1eb2:	b580      	push	{r7, lr}
    1eb4:	b082      	sub	sp, #8
    1eb6:	af00      	add	r7, sp, #0
    1eb8:	6078      	str	r0, [r7, #4]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_OSC48MRDY) >> OSCCTRL_STATUS_OSC48MRDY_Pos;
    1eba:	687b      	ldr	r3, [r7, #4]
    1ebc:	68db      	ldr	r3, [r3, #12]
    1ebe:	091b      	lsrs	r3, r3, #4
    1ec0:	2201      	movs	r2, #1
    1ec2:	4013      	ands	r3, r2
    1ec4:	1e5a      	subs	r2, r3, #1
    1ec6:	4193      	sbcs	r3, r2
    1ec8:	b2db      	uxtb	r3, r3
}
    1eca:	0018      	movs	r0, r3
    1ecc:	46bd      	mov	sp, r7
    1ece:	b002      	add	sp, #8
    1ed0:	bd80      	pop	{r7, pc}

00001ed2 <hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit>:
{
	return ((Oscctrl *)hw)->STATUS.reg;
}

static inline bool hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit(const void *const hw)
{
    1ed2:	b580      	push	{r7, lr}
    1ed4:	b082      	sub	sp, #8
    1ed6:	af00      	add	r7, sp, #0
    1ed8:	6078      	str	r0, [r7, #4]
	return (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV)
    1eda:	687b      	ldr	r3, [r7, #4]
    1edc:	699b      	ldr	r3, [r3, #24]
	       >> OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV_Pos;
    1ede:	089b      	lsrs	r3, r3, #2
    1ee0:	2201      	movs	r2, #1
    1ee2:	4013      	ands	r3, r2
    1ee4:	1e5a      	subs	r2, r3, #1
    1ee6:	4193      	sbcs	r3, r2
    1ee8:	b2db      	uxtb	r3, r3
}
    1eea:	0018      	movs	r0, r3
    1eec:	46bd      	mov	sp, r7
    1eee:	b002      	add	sp, #8
    1ef0:	bd80      	pop	{r7, pc}

00001ef2 <hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit>:
	((Oscctrl *)hw)->OSC48MCTRL.reg ^= OSCCTRL_OSC48MCTRL_RUNSTDBY;
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit(const void *const hw)
{
    1ef2:	b580      	push	{r7, lr}
    1ef4:	b082      	sub	sp, #8
    1ef6:	af00      	add	r7, sp, #0
    1ef8:	6078      	str	r0, [r7, #4]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MCTRL.reg |= OSCCTRL_OSC48MCTRL_ONDEMAND;
    1efa:	687b      	ldr	r3, [r7, #4]
    1efc:	7d1b      	ldrb	r3, [r3, #20]
    1efe:	b2db      	uxtb	r3, r3
    1f00:	2280      	movs	r2, #128	; 0x80
    1f02:	4252      	negs	r2, r2
    1f04:	4313      	orrs	r3, r2
    1f06:	b2da      	uxtb	r2, r3
    1f08:	687b      	ldr	r3, [r7, #4]
    1f0a:	751a      	strb	r2, [r3, #20]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    1f0c:	46c0      	nop			; (mov r8, r8)
    1f0e:	46bd      	mov	sp, r7
    1f10:	b002      	add	sp, #8
    1f12:	bd80      	pop	{r7, pc}

00001f14 <hri_oscctrl_write_OSC48MCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_OSC48MCTRL_reg(const void *const hw, hri_oscctrl_osc48mctrl_reg_t data)
{
    1f14:	b580      	push	{r7, lr}
    1f16:	b082      	sub	sp, #8
    1f18:	af00      	add	r7, sp, #0
    1f1a:	6078      	str	r0, [r7, #4]
    1f1c:	000a      	movs	r2, r1
    1f1e:	1cfb      	adds	r3, r7, #3
    1f20:	701a      	strb	r2, [r3, #0]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MCTRL.reg = data;
    1f22:	687b      	ldr	r3, [r7, #4]
    1f24:	1cfa      	adds	r2, r7, #3
    1f26:	7812      	ldrb	r2, [r2, #0]
    1f28:	751a      	strb	r2, [r3, #20]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    1f2a:	46c0      	nop			; (mov r8, r8)
    1f2c:	46bd      	mov	sp, r7
    1f2e:	b002      	add	sp, #8
    1f30:	bd80      	pop	{r7, pc}
	...

00001f34 <hri_oscctrl_write_OSC48MDIV_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_OSC48MDIV_reg(const void *const hw, hri_oscctrl_osc48mdiv_reg_t data)
{
    1f34:	b580      	push	{r7, lr}
    1f36:	b082      	sub	sp, #8
    1f38:	af00      	add	r7, sp, #0
    1f3a:	6078      	str	r0, [r7, #4]
    1f3c:	000a      	movs	r2, r1
    1f3e:	1cfb      	adds	r3, r7, #3
    1f40:	701a      	strb	r2, [r3, #0]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MDIV.reg = data;
    1f42:	687b      	ldr	r3, [r7, #4]
    1f44:	1cfa      	adds	r2, r7, #3
    1f46:	7812      	ldrb	r2, [r2, #0]
    1f48:	755a      	strb	r2, [r3, #21]
	hri_oscctrl_osc48msyncbusy_wait_for_sync(hw, OSCCTRL_OSC48MSYNCBUSY_MASK);
    1f4a:	687b      	ldr	r3, [r7, #4]
    1f4c:	2104      	movs	r1, #4
    1f4e:	0018      	movs	r0, r3
    1f50:	4b02      	ldr	r3, [pc, #8]	; (1f5c <hri_oscctrl_write_OSC48MDIV_reg+0x28>)
    1f52:	4798      	blx	r3
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    1f54:	46c0      	nop			; (mov r8, r8)
    1f56:	46bd      	mov	sp, r7
    1f58:	b002      	add	sp, #8
    1f5a:	bd80      	pop	{r7, pc}
    1f5c:	00001e95 	.word	0x00001e95

00001f60 <hri_oscctrl_write_OSC48MSTUP_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_OSC48MSTUP_reg(const void *const hw, hri_oscctrl_osc48mstup_reg_t data)
{
    1f60:	b580      	push	{r7, lr}
    1f62:	b082      	sub	sp, #8
    1f64:	af00      	add	r7, sp, #0
    1f66:	6078      	str	r0, [r7, #4]
    1f68:	000a      	movs	r2, r1
    1f6a:	1cfb      	adds	r3, r7, #3
    1f6c:	701a      	strb	r2, [r3, #0]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MSTUP.reg = data;
    1f6e:	687b      	ldr	r3, [r7, #4]
    1f70:	1cfa      	adds	r2, r7, #3
    1f72:	7812      	ldrb	r2, [r2, #0]
    1f74:	759a      	strb	r2, [r3, #22]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    1f76:	46c0      	nop			; (mov r8, r8)
    1f78:	46bd      	mov	sp, r7
    1f7a:	b002      	add	sp, #8
    1f7c:	bd80      	pop	{r7, pc}
	...

00001f80 <_oscctrl_init_sources>:

/**
 * \brief Initialize clock sources
 */
void _oscctrl_init_sources(void)
{
    1f80:	b580      	push	{r7, lr}
    1f82:	b082      	sub	sp, #8
    1f84:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
    1f86:	4b16      	ldr	r3, [pc, #88]	; (1fe0 <_oscctrl_init_sources+0x60>)
    1f88:	607b      	str	r3, [r7, #4]
	        | (CONF_XOSC_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));

	hri_oscctrl_write_EVCTRL_reg(hw, (CONF_XOSC_CFDEO << OSCCTRL_EVCTRL_CFDEO_Pos));
#endif
#if CONF_OSC48M_CONFIG == 1
	hri_oscctrl_write_OSC48MCTRL_reg(hw,
    1f8a:	687b      	ldr	r3, [r7, #4]
    1f8c:	2102      	movs	r1, #2
    1f8e:	0018      	movs	r0, r3
    1f90:	4b14      	ldr	r3, [pc, #80]	; (1fe4 <_oscctrl_init_sources+0x64>)
    1f92:	4798      	blx	r3
	                                 (CONF_OSC48M_RUNSTDBY << OSCCTRL_OSC48MCTRL_RUNSTDBY_Pos)
	                                     | (CONF_OSC48M_ENABLE << OSCCTRL_OSC48MCTRL_ENABLE_Pos));
	hri_oscctrl_write_OSC48MDIV_reg(hw, OSCCTRL_OSC48MDIV_DIV(CONF_OSC48M_DIV));
    1f94:	687b      	ldr	r3, [r7, #4]
    1f96:	210b      	movs	r1, #11
    1f98:	0018      	movs	r0, r3
    1f9a:	4b13      	ldr	r3, [pc, #76]	; (1fe8 <_oscctrl_init_sources+0x68>)
    1f9c:	4798      	blx	r3
	while (hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit(hw))
    1f9e:	46c0      	nop			; (mov r8, r8)
    1fa0:	687b      	ldr	r3, [r7, #4]
    1fa2:	0018      	movs	r0, r3
    1fa4:	4b11      	ldr	r3, [pc, #68]	; (1fec <_oscctrl_init_sources+0x6c>)
    1fa6:	4798      	blx	r3
    1fa8:	1e03      	subs	r3, r0, #0
    1faa:	d1f9      	bne.n	1fa0 <_oscctrl_init_sources+0x20>
		;
	hri_oscctrl_write_OSC48MSTUP_reg(hw, OSCCTRL_OSC48MSTUP_STARTUP(CONF_OSC48M_STARTUP));
    1fac:	687b      	ldr	r3, [r7, #4]
    1fae:	2107      	movs	r1, #7
    1fb0:	0018      	movs	r0, r3
    1fb2:	4b0f      	ldr	r3, [pc, #60]	; (1ff0 <_oscctrl_init_sources+0x70>)
    1fb4:	4798      	blx	r3
#endif
#endif

#if CONF_OSC48M_CONFIG == 1
#if CONF_OSC48M_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_OSC48MRDY_bit(hw))
    1fb6:	46c0      	nop			; (mov r8, r8)
    1fb8:	687b      	ldr	r3, [r7, #4]
    1fba:	0018      	movs	r0, r3
    1fbc:	4b0d      	ldr	r3, [pc, #52]	; (1ff4 <_oscctrl_init_sources+0x74>)
    1fbe:	4798      	blx	r3
    1fc0:	0003      	movs	r3, r0
    1fc2:	001a      	movs	r2, r3
    1fc4:	2301      	movs	r3, #1
    1fc6:	4053      	eors	r3, r2
    1fc8:	b2db      	uxtb	r3, r3
    1fca:	2b00      	cmp	r3, #0
    1fcc:	d1f4      	bne.n	1fb8 <_oscctrl_init_sources+0x38>
		;
#endif
#if CONF_OSC48M_ONDEMAND == 1
	hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit(hw);
    1fce:	687b      	ldr	r3, [r7, #4]
    1fd0:	0018      	movs	r0, r3
    1fd2:	4b09      	ldr	r3, [pc, #36]	; (1ff8 <_oscctrl_init_sources+0x78>)
    1fd4:	4798      	blx	r3
#endif
#endif
	(void)hw;
}
    1fd6:	46c0      	nop			; (mov r8, r8)
    1fd8:	46bd      	mov	sp, r7
    1fda:	b002      	add	sp, #8
    1fdc:	bd80      	pop	{r7, pc}
    1fde:	46c0      	nop			; (mov r8, r8)
    1fe0:	40001000 	.word	0x40001000
    1fe4:	00001f15 	.word	0x00001f15
    1fe8:	00001f35 	.word	0x00001f35
    1fec:	00001ed3 	.word	0x00001ed3
    1ff0:	00001f61 	.word	0x00001f61
    1ff4:	00001eb3 	.word	0x00001eb3
    1ff8:	00001ef3 	.word	0x00001ef3

00001ffc <_oscctrl_init_referenced_generators>:

void _oscctrl_init_referenced_generators(void)
{
    1ffc:	b580      	push	{r7, lr}
    1ffe:	b082      	sub	sp, #8
    2000:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
    2002:	4b03      	ldr	r3, [pc, #12]	; (2010 <STACK_SIZE+0x10>)
    2004:	607b      	str	r3, [r7, #4]
#if CONF_DPLL_ONDEMAND == 1
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
    2006:	46c0      	nop			; (mov r8, r8)
    2008:	46bd      	mov	sp, r7
    200a:	b002      	add	sp, #8
    200c:	bd80      	pop	{r7, pc}
    200e:	46c0      	nop			; (mov r8, r8)
    2010:	40001000 	.word	0x40001000

00002014 <hri_sercomusart_wait_for_sync>:
{
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
    2014:	b580      	push	{r7, lr}
    2016:	b082      	sub	sp, #8
    2018:	af00      	add	r7, sp, #0
    201a:	6078      	str	r0, [r7, #4]
    201c:	6039      	str	r1, [r7, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    201e:	46c0      	nop			; (mov r8, r8)
    2020:	687b      	ldr	r3, [r7, #4]
    2022:	69db      	ldr	r3, [r3, #28]
    2024:	683a      	ldr	r2, [r7, #0]
    2026:	4013      	ands	r3, r2
    2028:	d1fa      	bne.n	2020 <hri_sercomusart_wait_for_sync+0xc>
	};
}
    202a:	46c0      	nop			; (mov r8, r8)
    202c:	46bd      	mov	sp, r7
    202e:	b002      	add	sp, #8
    2030:	bd80      	pop	{r7, pc}

00002032 <hri_sercomusart_is_syncing>:

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
    2032:	b580      	push	{r7, lr}
    2034:	b082      	sub	sp, #8
    2036:	af00      	add	r7, sp, #0
    2038:	6078      	str	r0, [r7, #4]
    203a:	6039      	str	r1, [r7, #0]
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    203c:	687b      	ldr	r3, [r7, #4]
    203e:	69db      	ldr	r3, [r3, #28]
    2040:	683a      	ldr	r2, [r7, #0]
    2042:	4013      	ands	r3, r2
    2044:	1e5a      	subs	r2, r3, #1
    2046:	4193      	sbcs	r3, r2
    2048:	b2db      	uxtb	r3, r3
}
    204a:	0018      	movs	r0, r3
    204c:	46bd      	mov	sp, r7
    204e:	b002      	add	sp, #8
    2050:	bd80      	pop	{r7, pc}

00002052 <hri_sercomusart_get_interrupt_DRE_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
    2052:	b580      	push	{r7, lr}
    2054:	b082      	sub	sp, #8
    2056:	af00      	add	r7, sp, #0
    2058:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    205a:	687b      	ldr	r3, [r7, #4]
    205c:	7e1b      	ldrb	r3, [r3, #24]
    205e:	b2db      	uxtb	r3, r3
    2060:	001a      	movs	r2, r3
    2062:	2301      	movs	r3, #1
    2064:	4013      	ands	r3, r2
    2066:	1e5a      	subs	r2, r3, #1
    2068:	4193      	sbcs	r3, r2
    206a:	b2db      	uxtb	r3, r3
}
    206c:	0018      	movs	r0, r3
    206e:	46bd      	mov	sp, r7
    2070:	b002      	add	sp, #8
    2072:	bd80      	pop	{r7, pc}

00002074 <hri_sercomusart_get_interrupt_TXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_DRE;
}

static inline bool hri_sercomusart_get_interrupt_TXC_bit(const void *const hw)
{
    2074:	b580      	push	{r7, lr}
    2076:	b082      	sub	sp, #8
    2078:	af00      	add	r7, sp, #0
    207a:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    207c:	687b      	ldr	r3, [r7, #4]
    207e:	7e1b      	ldrb	r3, [r3, #24]
    2080:	b2db      	uxtb	r3, r3
    2082:	085b      	lsrs	r3, r3, #1
    2084:	2201      	movs	r2, #1
    2086:	4013      	ands	r3, r2
    2088:	1e5a      	subs	r2, r3, #1
    208a:	4193      	sbcs	r3, r2
    208c:	b2db      	uxtb	r3, r3
}
    208e:	0018      	movs	r0, r3
    2090:	46bd      	mov	sp, r7
    2092:	b002      	add	sp, #8
    2094:	bd80      	pop	{r7, pc}

00002096 <hri_sercomusart_get_interrupt_RXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_TXC;
}

static inline bool hri_sercomusart_get_interrupt_RXC_bit(const void *const hw)
{
    2096:	b580      	push	{r7, lr}
    2098:	b082      	sub	sp, #8
    209a:	af00      	add	r7, sp, #0
    209c:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    209e:	687b      	ldr	r3, [r7, #4]
    20a0:	7e1b      	ldrb	r3, [r3, #24]
    20a2:	b2db      	uxtb	r3, r3
    20a4:	089b      	lsrs	r3, r3, #2
    20a6:	2201      	movs	r2, #1
    20a8:	4013      	ands	r3, r2
    20aa:	1e5a      	subs	r2, r3, #1
    20ac:	4193      	sbcs	r3, r2
    20ae:	b2db      	uxtb	r3, r3
}
    20b0:	0018      	movs	r0, r3
    20b2:	46bd      	mov	sp, r7
    20b4:	b002      	add	sp, #8
    20b6:	bd80      	pop	{r7, pc}

000020b8 <hri_sercomusart_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_USART_CTRLA_SWRST) >> SERCOM_USART_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomusart_set_CTRLA_ENABLE_bit(const void *const hw)
{
    20b8:	b580      	push	{r7, lr}
    20ba:	b082      	sub	sp, #8
    20bc:	af00      	add	r7, sp, #0
    20be:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    20c0:	687b      	ldr	r3, [r7, #4]
    20c2:	681b      	ldr	r3, [r3, #0]
    20c4:	2202      	movs	r2, #2
    20c6:	431a      	orrs	r2, r3
    20c8:	687b      	ldr	r3, [r7, #4]
    20ca:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    20cc:	687b      	ldr	r3, [r7, #4]
    20ce:	2103      	movs	r1, #3
    20d0:	0018      	movs	r0, r3
    20d2:	4b03      	ldr	r3, [pc, #12]	; (20e0 <hri_sercomusart_set_CTRLA_ENABLE_bit+0x28>)
    20d4:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    20d6:	46c0      	nop			; (mov r8, r8)
    20d8:	46bd      	mov	sp, r7
    20da:	b002      	add	sp, #8
    20dc:	bd80      	pop	{r7, pc}
    20de:	46c0      	nop			; (mov r8, r8)
    20e0:	00002015 	.word	0x00002015

000020e4 <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    20e4:	b580      	push	{r7, lr}
    20e6:	b082      	sub	sp, #8
    20e8:	af00      	add	r7, sp, #0
    20ea:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    20ec:	687b      	ldr	r3, [r7, #4]
    20ee:	681b      	ldr	r3, [r3, #0]
    20f0:	2202      	movs	r2, #2
    20f2:	4393      	bics	r3, r2
    20f4:	001a      	movs	r2, r3
    20f6:	687b      	ldr	r3, [r7, #4]
    20f8:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    20fa:	687b      	ldr	r3, [r7, #4]
    20fc:	2103      	movs	r1, #3
    20fe:	0018      	movs	r0, r3
    2100:	4b02      	ldr	r3, [pc, #8]	; (210c <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x28>)
    2102:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2104:	46c0      	nop			; (mov r8, r8)
    2106:	46bd      	mov	sp, r7
    2108:	b002      	add	sp, #8
    210a:	bd80      	pop	{r7, pc}
    210c:	00002015 	.word	0x00002015

00002110 <hri_sercomusart_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
    2110:	b580      	push	{r7, lr}
    2112:	b084      	sub	sp, #16
    2114:	af00      	add	r7, sp, #0
    2116:	6078      	str	r0, [r7, #4]
    2118:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    211a:	687b      	ldr	r3, [r7, #4]
    211c:	2103      	movs	r1, #3
    211e:	0018      	movs	r0, r3
    2120:	4b06      	ldr	r3, [pc, #24]	; (213c <hri_sercomusart_get_CTRLA_reg+0x2c>)
    2122:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    2124:	687b      	ldr	r3, [r7, #4]
    2126:	681b      	ldr	r3, [r3, #0]
    2128:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    212a:	68fb      	ldr	r3, [r7, #12]
    212c:	683a      	ldr	r2, [r7, #0]
    212e:	4013      	ands	r3, r2
    2130:	60fb      	str	r3, [r7, #12]
	return tmp;
    2132:	68fb      	ldr	r3, [r7, #12]
}
    2134:	0018      	movs	r0, r3
    2136:	46bd      	mov	sp, r7
    2138:	b004      	add	sp, #16
    213a:	bd80      	pop	{r7, pc}
    213c:	00002015 	.word	0x00002015

00002140 <hri_sercomusart_write_CTRLA_reg>:

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
    2140:	b580      	push	{r7, lr}
    2142:	b082      	sub	sp, #8
    2144:	af00      	add	r7, sp, #0
    2146:	6078      	str	r0, [r7, #4]
    2148:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    214a:	687b      	ldr	r3, [r7, #4]
    214c:	683a      	ldr	r2, [r7, #0]
    214e:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    2150:	687b      	ldr	r3, [r7, #4]
    2152:	2103      	movs	r1, #3
    2154:	0018      	movs	r0, r3
    2156:	4b03      	ldr	r3, [pc, #12]	; (2164 <hri_sercomusart_write_CTRLA_reg+0x24>)
    2158:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    215a:	46c0      	nop			; (mov r8, r8)
    215c:	46bd      	mov	sp, r7
    215e:	b002      	add	sp, #8
    2160:	bd80      	pop	{r7, pc}
    2162:	46c0      	nop			; (mov r8, r8)
    2164:	00002015 	.word	0x00002015

00002168 <hri_sercomusart_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
    2168:	b580      	push	{r7, lr}
    216a:	b082      	sub	sp, #8
    216c:	af00      	add	r7, sp, #0
    216e:	6078      	str	r0, [r7, #4]
    2170:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    2172:	687b      	ldr	r3, [r7, #4]
    2174:	683a      	ldr	r2, [r7, #0]
    2176:	605a      	str	r2, [r3, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
    2178:	687b      	ldr	r3, [r7, #4]
    217a:	2107      	movs	r1, #7
    217c:	0018      	movs	r0, r3
    217e:	4b03      	ldr	r3, [pc, #12]	; (218c <hri_sercomusart_write_CTRLB_reg+0x24>)
    2180:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2182:	46c0      	nop			; (mov r8, r8)
    2184:	46bd      	mov	sp, r7
    2186:	b002      	add	sp, #8
    2188:	bd80      	pop	{r7, pc}
    218a:	46c0      	nop			; (mov r8, r8)
    218c:	00002015 	.word	0x00002015

00002190 <hri_sercomusart_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
    2190:	b580      	push	{r7, lr}
    2192:	b082      	sub	sp, #8
    2194:	af00      	add	r7, sp, #0
    2196:	6078      	str	r0, [r7, #4]
    2198:	000a      	movs	r2, r1
    219a:	1cbb      	adds	r3, r7, #2
    219c:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    219e:	687b      	ldr	r3, [r7, #4]
    21a0:	1cba      	adds	r2, r7, #2
    21a2:	8812      	ldrh	r2, [r2, #0]
    21a4:	819a      	strh	r2, [r3, #12]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    21a6:	46c0      	nop			; (mov r8, r8)
    21a8:	46bd      	mov	sp, r7
    21aa:	b002      	add	sp, #8
    21ac:	bd80      	pop	{r7, pc}

000021ae <hri_sercomusart_write_RXPL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
    21ae:	b580      	push	{r7, lr}
    21b0:	b082      	sub	sp, #8
    21b2:	af00      	add	r7, sp, #0
    21b4:	6078      	str	r0, [r7, #4]
    21b6:	000a      	movs	r2, r1
    21b8:	1cfb      	adds	r3, r7, #3
    21ba:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
    21bc:	687b      	ldr	r3, [r7, #4]
    21be:	1cfa      	adds	r2, r7, #3
    21c0:	7812      	ldrb	r2, [r2, #0]
    21c2:	739a      	strb	r2, [r3, #14]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    21c4:	46c0      	nop			; (mov r8, r8)
    21c6:	46bd      	mov	sp, r7
    21c8:	b002      	add	sp, #8
    21ca:	bd80      	pop	{r7, pc}

000021cc <hri_sercomusart_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DATA_reg(const void *const hw, hri_sercomusart_data_reg_t data)
{
    21cc:	b580      	push	{r7, lr}
    21ce:	b082      	sub	sp, #8
    21d0:	af00      	add	r7, sp, #0
    21d2:	6078      	str	r0, [r7, #4]
    21d4:	000a      	movs	r2, r1
    21d6:	1cbb      	adds	r3, r7, #2
    21d8:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DATA.reg = data;
    21da:	687b      	ldr	r3, [r7, #4]
    21dc:	1cba      	adds	r2, r7, #2
    21de:	8812      	ldrh	r2, [r2, #0]
    21e0:	851a      	strh	r2, [r3, #40]	; 0x28
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    21e2:	46c0      	nop			; (mov r8, r8)
    21e4:	46bd      	mov	sp, r7
    21e6:	b002      	add	sp, #8
    21e8:	bd80      	pop	{r7, pc}

000021ea <hri_sercomusart_read_DATA_reg>:
	((Sercom *)hw)->USART.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_data_reg_t hri_sercomusart_read_DATA_reg(const void *const hw)
{
    21ea:	b580      	push	{r7, lr}
    21ec:	b082      	sub	sp, #8
    21ee:	af00      	add	r7, sp, #0
    21f0:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
    21f2:	687b      	ldr	r3, [r7, #4]
    21f4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    21f6:	b29b      	uxth	r3, r3
}
    21f8:	0018      	movs	r0, r3
    21fa:	46bd      	mov	sp, r7
    21fc:	b002      	add	sp, #8
    21fe:	bd80      	pop	{r7, pc}

00002200 <hri_sercomusart_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
    2200:	b580      	push	{r7, lr}
    2202:	b082      	sub	sp, #8
    2204:	af00      	add	r7, sp, #0
    2206:	6078      	str	r0, [r7, #4]
    2208:	000a      	movs	r2, r1
    220a:	1cfb      	adds	r3, r7, #3
    220c:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    220e:	687b      	ldr	r3, [r7, #4]
    2210:	1cfa      	adds	r2, r7, #3
    2212:	2130      	movs	r1, #48	; 0x30
    2214:	7812      	ldrb	r2, [r2, #0]
    2216:	545a      	strb	r2, [r3, r1]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2218:	46c0      	nop			; (mov r8, r8)
    221a:	46bd      	mov	sp, r7
    221c:	b002      	add	sp, #8
    221e:	bd80      	pop	{r7, pc}

00002220 <_usart_sync_init>:

/**
 * \brief Initialize synchronous SERCOM USART
 */
int32_t _usart_sync_init(struct _usart_sync_device *const device, void *const hw)
{
    2220:	b580      	push	{r7, lr}
    2222:	b082      	sub	sp, #8
    2224:	af00      	add	r7, sp, #0
    2226:	6078      	str	r0, [r7, #4]
    2228:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    222a:	687b      	ldr	r3, [r7, #4]
    222c:	1e5a      	subs	r2, r3, #1
    222e:	4193      	sbcs	r3, r2
    2230:	b2db      	uxtb	r3, r3
    2232:	4908      	ldr	r1, [pc, #32]	; (2254 <_usart_sync_init+0x34>)
    2234:	22b4      	movs	r2, #180	; 0xb4
    2236:	0018      	movs	r0, r3
    2238:	4b07      	ldr	r3, [pc, #28]	; (2258 <_usart_sync_init+0x38>)
    223a:	4798      	blx	r3

	device->hw = hw;
    223c:	687b      	ldr	r3, [r7, #4]
    223e:	683a      	ldr	r2, [r7, #0]
    2240:	601a      	str	r2, [r3, #0]

	return _usart_init(hw);
    2242:	683b      	ldr	r3, [r7, #0]
    2244:	0018      	movs	r0, r3
    2246:	4b05      	ldr	r3, [pc, #20]	; (225c <_usart_sync_init+0x3c>)
    2248:	4798      	blx	r3
    224a:	0003      	movs	r3, r0
}
    224c:	0018      	movs	r0, r3
    224e:	46bd      	mov	sp, r7
    2250:	b002      	add	sp, #8
    2252:	bd80      	pop	{r7, pc}
    2254:	00005e90 	.word	0x00005e90
    2258:	00001331 	.word	0x00001331
    225c:	000023d9 	.word	0x000023d9

00002260 <_usart_sync_enable>:

/**
 * \brief Enable SERCOM module
 */
void _usart_sync_enable(struct _usart_sync_device *const device)
{
    2260:	b580      	push	{r7, lr}
    2262:	b082      	sub	sp, #8
    2264:	af00      	add	r7, sp, #0
    2266:	6078      	str	r0, [r7, #4]
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    2268:	687b      	ldr	r3, [r7, #4]
    226a:	681b      	ldr	r3, [r3, #0]
    226c:	0018      	movs	r0, r3
    226e:	4b03      	ldr	r3, [pc, #12]	; (227c <_usart_sync_enable+0x1c>)
    2270:	4798      	blx	r3
}
    2272:	46c0      	nop			; (mov r8, r8)
    2274:	46bd      	mov	sp, r7
    2276:	b002      	add	sp, #8
    2278:	bd80      	pop	{r7, pc}
    227a:	46c0      	nop			; (mov r8, r8)
    227c:	000020b9 	.word	0x000020b9

00002280 <_usart_sync_write_byte>:

/**
 * \brief Write a byte to the given SERCOM USART instance
 */
void _usart_sync_write_byte(struct _usart_sync_device *const device, uint8_t data)
{
    2280:	b580      	push	{r7, lr}
    2282:	b082      	sub	sp, #8
    2284:	af00      	add	r7, sp, #0
    2286:	6078      	str	r0, [r7, #4]
    2288:	000a      	movs	r2, r1
    228a:	1cfb      	adds	r3, r7, #3
    228c:	701a      	strb	r2, [r3, #0]
	hri_sercomusart_write_DATA_reg(device->hw, data);
    228e:	687b      	ldr	r3, [r7, #4]
    2290:	681a      	ldr	r2, [r3, #0]
    2292:	1cfb      	adds	r3, r7, #3
    2294:	781b      	ldrb	r3, [r3, #0]
    2296:	b29b      	uxth	r3, r3
    2298:	0019      	movs	r1, r3
    229a:	0010      	movs	r0, r2
    229c:	4b02      	ldr	r3, [pc, #8]	; (22a8 <_usart_sync_write_byte+0x28>)
    229e:	4798      	blx	r3
}
    22a0:	46c0      	nop			; (mov r8, r8)
    22a2:	46bd      	mov	sp, r7
    22a4:	b002      	add	sp, #8
    22a6:	bd80      	pop	{r7, pc}
    22a8:	000021cd 	.word	0x000021cd

000022ac <_usart_sync_read_byte>:

/**
 * \brief Read a byte from the given SERCOM USART instance
 */
uint8_t _usart_sync_read_byte(const struct _usart_sync_device *const device)
{
    22ac:	b580      	push	{r7, lr}
    22ae:	b082      	sub	sp, #8
    22b0:	af00      	add	r7, sp, #0
    22b2:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_read_DATA_reg(device->hw);
    22b4:	687b      	ldr	r3, [r7, #4]
    22b6:	681b      	ldr	r3, [r3, #0]
    22b8:	0018      	movs	r0, r3
    22ba:	4b04      	ldr	r3, [pc, #16]	; (22cc <_usart_sync_read_byte+0x20>)
    22bc:	4798      	blx	r3
    22be:	0003      	movs	r3, r0
    22c0:	b2db      	uxtb	r3, r3
}
    22c2:	0018      	movs	r0, r3
    22c4:	46bd      	mov	sp, r7
    22c6:	b002      	add	sp, #8
    22c8:	bd80      	pop	{r7, pc}
    22ca:	46c0      	nop			; (mov r8, r8)
    22cc:	000021eb 	.word	0x000021eb

000022d0 <_usart_sync_is_ready_to_send>:

/**
 * \brief Check if USART is ready to send next byte
 */
bool _usart_sync_is_ready_to_send(const struct _usart_sync_device *const device)
{
    22d0:	b580      	push	{r7, lr}
    22d2:	b082      	sub	sp, #8
    22d4:	af00      	add	r7, sp, #0
    22d6:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    22d8:	687b      	ldr	r3, [r7, #4]
    22da:	681b      	ldr	r3, [r3, #0]
    22dc:	0018      	movs	r0, r3
    22de:	4b03      	ldr	r3, [pc, #12]	; (22ec <_usart_sync_is_ready_to_send+0x1c>)
    22e0:	4798      	blx	r3
    22e2:	0003      	movs	r3, r0
}
    22e4:	0018      	movs	r0, r3
    22e6:	46bd      	mov	sp, r7
    22e8:	b002      	add	sp, #8
    22ea:	bd80      	pop	{r7, pc}
    22ec:	00002053 	.word	0x00002053

000022f0 <_usart_sync_is_transmit_done>:

/**
 * \brief Check if USART transmission complete
 */
bool _usart_sync_is_transmit_done(const struct _usart_sync_device *const device)
{
    22f0:	b580      	push	{r7, lr}
    22f2:	b082      	sub	sp, #8
    22f4:	af00      	add	r7, sp, #0
    22f6:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    22f8:	687b      	ldr	r3, [r7, #4]
    22fa:	681b      	ldr	r3, [r3, #0]
    22fc:	0018      	movs	r0, r3
    22fe:	4b03      	ldr	r3, [pc, #12]	; (230c <_usart_sync_is_transmit_done+0x1c>)
    2300:	4798      	blx	r3
    2302:	0003      	movs	r3, r0
}
    2304:	0018      	movs	r0, r3
    2306:	46bd      	mov	sp, r7
    2308:	b002      	add	sp, #8
    230a:	bd80      	pop	{r7, pc}
    230c:	00002075 	.word	0x00002075

00002310 <_usart_sync_is_byte_received>:

/**
 * \brief Check if there is data received by USART
 */
bool _usart_sync_is_byte_received(const struct _usart_sync_device *const device)
{
    2310:	b580      	push	{r7, lr}
    2312:	b082      	sub	sp, #8
    2314:	af00      	add	r7, sp, #0
    2316:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    2318:	687b      	ldr	r3, [r7, #4]
    231a:	681b      	ldr	r3, [r3, #0]
    231c:	0018      	movs	r0, r3
    231e:	4b03      	ldr	r3, [pc, #12]	; (232c <_usart_sync_is_byte_received+0x1c>)
    2320:	4798      	blx	r3
    2322:	0003      	movs	r3, r0
}
    2324:	0018      	movs	r0, r3
    2326:	46bd      	mov	sp, r7
    2328:	b002      	add	sp, #8
    232a:	bd80      	pop	{r7, pc}
    232c:	00002097 	.word	0x00002097

00002330 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    2330:	b580      	push	{r7, lr}
    2332:	b082      	sub	sp, #8
    2334:	af00      	add	r7, sp, #0
    2336:	6078      	str	r0, [r7, #4]
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
    2338:	687b      	ldr	r3, [r7, #4]
    233a:	4a04      	ldr	r2, [pc, #16]	; (234c <_sercom_get_hardware_index+0x1c>)
    233c:	4694      	mov	ip, r2
    233e:	4463      	add	r3, ip
    2340:	0a9b      	lsrs	r3, r3, #10
    2342:	b2db      	uxtb	r3, r3
}
    2344:	0018      	movs	r0, r3
    2346:	46bd      	mov	sp, r7
    2348:	b002      	add	sp, #8
    234a:	bd80      	pop	{r7, pc}
    234c:	bdfffc00 	.word	0xbdfffc00

00002350 <_get_sercom_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_sercom_index(const void *const hw)
{
    2350:	b590      	push	{r4, r7, lr}
    2352:	b085      	sub	sp, #20
    2354:	af00      	add	r7, sp, #0
    2356:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    2358:	230e      	movs	r3, #14
    235a:	18fc      	adds	r4, r7, r3
    235c:	687b      	ldr	r3, [r7, #4]
    235e:	0018      	movs	r0, r3
    2360:	4b18      	ldr	r3, [pc, #96]	; (23c4 <_get_sercom_index+0x74>)
    2362:	4798      	blx	r3
    2364:	0003      	movs	r3, r0
    2366:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    2368:	230f      	movs	r3, #15
    236a:	18fb      	adds	r3, r7, r3
    236c:	2200      	movs	r2, #0
    236e:	701a      	strb	r2, [r3, #0]
    2370:	e018      	b.n	23a4 <_get_sercom_index+0x54>
		if (_usarts[i].number == sercom_offset) {
    2372:	230f      	movs	r3, #15
    2374:	18fb      	adds	r3, r7, r3
    2376:	781a      	ldrb	r2, [r3, #0]
    2378:	4913      	ldr	r1, [pc, #76]	; (23c8 <_get_sercom_index+0x78>)
    237a:	0013      	movs	r3, r2
    237c:	009b      	lsls	r3, r3, #2
    237e:	189b      	adds	r3, r3, r2
    2380:	009b      	lsls	r3, r3, #2
    2382:	5c5b      	ldrb	r3, [r3, r1]
    2384:	220e      	movs	r2, #14
    2386:	18ba      	adds	r2, r7, r2
    2388:	7812      	ldrb	r2, [r2, #0]
    238a:	429a      	cmp	r2, r3
    238c:	d103      	bne.n	2396 <_get_sercom_index+0x46>
			return i;
    238e:	230f      	movs	r3, #15
    2390:	18fb      	adds	r3, r7, r3
    2392:	781b      	ldrb	r3, [r3, #0]
    2394:	e012      	b.n	23bc <_get_sercom_index+0x6c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    2396:	230f      	movs	r3, #15
    2398:	18fb      	adds	r3, r7, r3
    239a:	781a      	ldrb	r2, [r3, #0]
    239c:	230f      	movs	r3, #15
    239e:	18fb      	adds	r3, r7, r3
    23a0:	3201      	adds	r2, #1
    23a2:	701a      	strb	r2, [r3, #0]
    23a4:	230f      	movs	r3, #15
    23a6:	18fb      	adds	r3, r7, r3
    23a8:	781b      	ldrb	r3, [r3, #0]
    23aa:	2b00      	cmp	r3, #0
    23ac:	d0e1      	beq.n	2372 <_get_sercom_index+0x22>
		}
	}

	ASSERT(false);
    23ae:	4a07      	ldr	r2, [pc, #28]	; (23cc <_get_sercom_index+0x7c>)
    23b0:	4b07      	ldr	r3, [pc, #28]	; (23d0 <_get_sercom_index+0x80>)
    23b2:	0019      	movs	r1, r3
    23b4:	2000      	movs	r0, #0
    23b6:	4b07      	ldr	r3, [pc, #28]	; (23d4 <_get_sercom_index+0x84>)
    23b8:	4798      	blx	r3
	return 0;
    23ba:	2300      	movs	r3, #0
}
    23bc:	0018      	movs	r0, r3
    23be:	46bd      	mov	sp, r7
    23c0:	b005      	add	sp, #20
    23c2:	bd90      	pop	{r4, r7, pc}
    23c4:	00002331 	.word	0x00002331
    23c8:	20000000 	.word	0x20000000
    23cc:	0000023a 	.word	0x0000023a
    23d0:	00005e90 	.word	0x00005e90
    23d4:	00001331 	.word	0x00001331

000023d8 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    23d8:	b590      	push	{r4, r7, lr}
    23da:	b085      	sub	sp, #20
    23dc:	af00      	add	r7, sp, #0
    23de:	6078      	str	r0, [r7, #4]
	uint8_t i = _get_sercom_index(hw);
    23e0:	230f      	movs	r3, #15
    23e2:	18fc      	adds	r4, r7, r3
    23e4:	687b      	ldr	r3, [r7, #4]
    23e6:	0018      	movs	r0, r3
    23e8:	4b6f      	ldr	r3, [pc, #444]	; (25a8 <_usart_init+0x1d0>)
    23ea:	4798      	blx	r3
    23ec:	0003      	movs	r3, r0
    23ee:	7023      	strb	r3, [r4, #0]

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    23f0:	687b      	ldr	r3, [r7, #4]
    23f2:	2101      	movs	r1, #1
    23f4:	0018      	movs	r0, r3
    23f6:	4b6d      	ldr	r3, [pc, #436]	; (25ac <_usart_init+0x1d4>)
    23f8:	4798      	blx	r3
    23fa:	0003      	movs	r3, r0
    23fc:	001a      	movs	r2, r3
    23fe:	2301      	movs	r3, #1
    2400:	4053      	eors	r3, r2
    2402:	b2db      	uxtb	r3, r3
    2404:	2b00      	cmp	r3, #0
    2406:	d025      	beq.n	2454 <_usart_init+0x7c>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    2408:	230f      	movs	r3, #15
    240a:	18fb      	adds	r3, r7, r3
    240c:	781a      	ldrb	r2, [r3, #0]
    240e:	4968      	ldr	r1, [pc, #416]	; (25b0 <_usart_init+0x1d8>)
    2410:	0013      	movs	r3, r2
    2412:	009b      	lsls	r3, r3, #2
    2414:	189b      	adds	r3, r3, r2
    2416:	009b      	lsls	r3, r3, #2
    2418:	18cb      	adds	r3, r1, r3
    241a:	3304      	adds	r3, #4
    241c:	681b      	ldr	r3, [r3, #0]
    241e:	221c      	movs	r2, #28
    2420:	4013      	ands	r3, r2
    2422:	60bb      	str	r3, [r7, #8]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    2424:	687b      	ldr	r3, [r7, #4]
    2426:	2102      	movs	r1, #2
    2428:	0018      	movs	r0, r3
    242a:	4b62      	ldr	r3, [pc, #392]	; (25b4 <_usart_init+0x1dc>)
    242c:	4798      	blx	r3
    242e:	1e03      	subs	r3, r0, #0
    2430:	d008      	beq.n	2444 <_usart_init+0x6c>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
    2432:	687b      	ldr	r3, [r7, #4]
    2434:	0018      	movs	r0, r3
    2436:	4b60      	ldr	r3, [pc, #384]	; (25b8 <_usart_init+0x1e0>)
    2438:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
    243a:	687b      	ldr	r3, [r7, #4]
    243c:	2102      	movs	r1, #2
    243e:	0018      	movs	r0, r3
    2440:	4b5e      	ldr	r3, [pc, #376]	; (25bc <_usart_init+0x1e4>)
    2442:	4798      	blx	r3
		}
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    2444:	68bb      	ldr	r3, [r7, #8]
    2446:	2201      	movs	r2, #1
    2448:	431a      	orrs	r2, r3
    244a:	687b      	ldr	r3, [r7, #4]
    244c:	0011      	movs	r1, r2
    244e:	0018      	movs	r0, r3
    2450:	4b5b      	ldr	r3, [pc, #364]	; (25c0 <_usart_init+0x1e8>)
    2452:	4798      	blx	r3
	}
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
    2454:	687b      	ldr	r3, [r7, #4]
    2456:	2101      	movs	r1, #1
    2458:	0018      	movs	r0, r3
    245a:	4b58      	ldr	r3, [pc, #352]	; (25bc <_usart_init+0x1e4>)
    245c:	4798      	blx	r3

	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    245e:	230f      	movs	r3, #15
    2460:	18fb      	adds	r3, r7, r3
    2462:	781a      	ldrb	r2, [r3, #0]
    2464:	4952      	ldr	r1, [pc, #328]	; (25b0 <_usart_init+0x1d8>)
    2466:	0013      	movs	r3, r2
    2468:	009b      	lsls	r3, r3, #2
    246a:	189b      	adds	r3, r3, r2
    246c:	009b      	lsls	r3, r3, #2
    246e:	18cb      	adds	r3, r1, r3
    2470:	3304      	adds	r3, #4
    2472:	681a      	ldr	r2, [r3, #0]
    2474:	687b      	ldr	r3, [r7, #4]
    2476:	0011      	movs	r1, r2
    2478:	0018      	movs	r0, r3
    247a:	4b51      	ldr	r3, [pc, #324]	; (25c0 <_usart_init+0x1e8>)
    247c:	4798      	blx	r3
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    247e:	230f      	movs	r3, #15
    2480:	18fb      	adds	r3, r7, r3
    2482:	781a      	ldrb	r2, [r3, #0]
    2484:	494a      	ldr	r1, [pc, #296]	; (25b0 <_usart_init+0x1d8>)
    2486:	0013      	movs	r3, r2
    2488:	009b      	lsls	r3, r3, #2
    248a:	189b      	adds	r3, r3, r2
    248c:	009b      	lsls	r3, r3, #2
    248e:	18cb      	adds	r3, r1, r3
    2490:	3308      	adds	r3, #8
    2492:	681a      	ldr	r2, [r3, #0]
    2494:	687b      	ldr	r3, [r7, #4]
    2496:	0011      	movs	r1, r2
    2498:	0018      	movs	r0, r3
    249a:	4b4a      	ldr	r3, [pc, #296]	; (25c4 <_usart_init+0x1ec>)
    249c:	4798      	blx	r3
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    249e:	230f      	movs	r3, #15
    24a0:	18fb      	adds	r3, r7, r3
    24a2:	781a      	ldrb	r2, [r3, #0]
    24a4:	4942      	ldr	r1, [pc, #264]	; (25b0 <_usart_init+0x1d8>)
    24a6:	0013      	movs	r3, r2
    24a8:	009b      	lsls	r3, r3, #2
    24aa:	189b      	adds	r3, r3, r2
    24ac:	009b      	lsls	r3, r3, #2
    24ae:	18cb      	adds	r3, r1, r3
    24b0:	3304      	adds	r3, #4
    24b2:	681a      	ldr	r2, [r3, #0]
    24b4:	2380      	movs	r3, #128	; 0x80
    24b6:	019b      	lsls	r3, r3, #6
    24b8:	4013      	ands	r3, r2
    24ba:	d10e      	bne.n	24da <_usart_init+0x102>
    24bc:	230f      	movs	r3, #15
    24be:	18fb      	adds	r3, r7, r3
    24c0:	781a      	ldrb	r2, [r3, #0]
    24c2:	493b      	ldr	r1, [pc, #236]	; (25b0 <_usart_init+0x1d8>)
    24c4:	0013      	movs	r3, r2
    24c6:	009b      	lsls	r3, r3, #2
    24c8:	189b      	adds	r3, r3, r2
    24ca:	009b      	lsls	r3, r3, #2
    24cc:	18cb      	adds	r3, r1, r3
    24ce:	3304      	adds	r3, #4
    24d0:	681a      	ldr	r2, [r3, #0]
    24d2:	23c0      	movs	r3, #192	; 0xc0
    24d4:	01db      	lsls	r3, r3, #7
    24d6:	4013      	ands	r3, r2
    24d8:	d030      	beq.n	253c <_usart_init+0x164>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    24da:	230f      	movs	r3, #15
    24dc:	18fb      	adds	r3, r7, r3
    24de:	781a      	ldrb	r2, [r3, #0]
    24e0:	4933      	ldr	r1, [pc, #204]	; (25b0 <_usart_init+0x1d8>)
    24e2:	0013      	movs	r3, r2
    24e4:	009b      	lsls	r3, r3, #2
    24e6:	189b      	adds	r3, r3, r2
    24e8:	009b      	lsls	r3, r3, #2
    24ea:	18cb      	adds	r3, r1, r3
    24ec:	330c      	adds	r3, #12
    24ee:	881b      	ldrh	r3, [r3, #0]
    24f0:	04db      	lsls	r3, r3, #19
    24f2:	0cdb      	lsrs	r3, r3, #19
    24f4:	b299      	uxth	r1, r3
    24f6:	687a      	ldr	r2, [r7, #4]
    24f8:	8993      	ldrh	r3, [r2, #12]
    24fa:	04c9      	lsls	r1, r1, #19
    24fc:	0cc8      	lsrs	r0, r1, #19
    24fe:	0b5b      	lsrs	r3, r3, #13
    2500:	035b      	lsls	r3, r3, #13
    2502:	1c19      	adds	r1, r3, #0
    2504:	1c03      	adds	r3, r0, #0
    2506:	430b      	orrs	r3, r1
    2508:	8193      	strh	r3, [r2, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    250a:	230f      	movs	r3, #15
    250c:	18fb      	adds	r3, r7, r3
    250e:	781a      	ldrb	r2, [r3, #0]
    2510:	4927      	ldr	r1, [pc, #156]	; (25b0 <_usart_init+0x1d8>)
    2512:	0013      	movs	r3, r2
    2514:	009b      	lsls	r3, r3, #2
    2516:	189b      	adds	r3, r3, r2
    2518:	009b      	lsls	r3, r3, #2
    251a:	18cb      	adds	r3, r1, r3
    251c:	330e      	adds	r3, #14
    251e:	781b      	ldrb	r3, [r3, #0]
    2520:	1c1a      	adds	r2, r3, #0
    2522:	2307      	movs	r3, #7
    2524:	4013      	ands	r3, r2
    2526:	b2d9      	uxtb	r1, r3
    2528:	687a      	ldr	r2, [r7, #4]
    252a:	8993      	ldrh	r3, [r2, #12]
    252c:	0348      	lsls	r0, r1, #13
    252e:	04db      	lsls	r3, r3, #19
    2530:	0cdb      	lsrs	r3, r3, #19
    2532:	1c19      	adds	r1, r3, #0
    2534:	1c03      	adds	r3, r0, #0
    2536:	430b      	orrs	r3, r1
    2538:	8193      	strh	r3, [r2, #12]
    253a:	e00f      	b.n	255c <_usart_init+0x184>
	} else {
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    253c:	230f      	movs	r3, #15
    253e:	18fb      	adds	r3, r7, r3
    2540:	781a      	ldrb	r2, [r3, #0]
    2542:	491b      	ldr	r1, [pc, #108]	; (25b0 <_usart_init+0x1d8>)
    2544:	0013      	movs	r3, r2
    2546:	009b      	lsls	r3, r3, #2
    2548:	189b      	adds	r3, r3, r2
    254a:	009b      	lsls	r3, r3, #2
    254c:	18cb      	adds	r3, r1, r3
    254e:	330c      	adds	r3, #12
    2550:	881a      	ldrh	r2, [r3, #0]
    2552:	687b      	ldr	r3, [r7, #4]
    2554:	0011      	movs	r1, r2
    2556:	0018      	movs	r0, r3
    2558:	4b1b      	ldr	r3, [pc, #108]	; (25c8 <_usart_init+0x1f0>)
    255a:	4798      	blx	r3
	}

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    255c:	230f      	movs	r3, #15
    255e:	18fb      	adds	r3, r7, r3
    2560:	781a      	ldrb	r2, [r3, #0]
    2562:	4913      	ldr	r1, [pc, #76]	; (25b0 <_usart_init+0x1d8>)
    2564:	0013      	movs	r3, r2
    2566:	009b      	lsls	r3, r3, #2
    2568:	189b      	adds	r3, r3, r2
    256a:	009b      	lsls	r3, r3, #2
    256c:	18cb      	adds	r3, r1, r3
    256e:	330f      	adds	r3, #15
    2570:	781a      	ldrb	r2, [r3, #0]
    2572:	687b      	ldr	r3, [r7, #4]
    2574:	0011      	movs	r1, r2
    2576:	0018      	movs	r0, r3
    2578:	4b14      	ldr	r3, [pc, #80]	; (25cc <_usart_init+0x1f4>)
    257a:	4798      	blx	r3
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    257c:	230f      	movs	r3, #15
    257e:	18fb      	adds	r3, r7, r3
    2580:	781a      	ldrb	r2, [r3, #0]
    2582:	490b      	ldr	r1, [pc, #44]	; (25b0 <_usart_init+0x1d8>)
    2584:	0013      	movs	r3, r2
    2586:	009b      	lsls	r3, r3, #2
    2588:	189b      	adds	r3, r3, r2
    258a:	009b      	lsls	r3, r3, #2
    258c:	18cb      	adds	r3, r1, r3
    258e:	3310      	adds	r3, #16
    2590:	781a      	ldrb	r2, [r3, #0]
    2592:	687b      	ldr	r3, [r7, #4]
    2594:	0011      	movs	r1, r2
    2596:	0018      	movs	r0, r3
    2598:	4b0d      	ldr	r3, [pc, #52]	; (25d0 <_usart_init+0x1f8>)
    259a:	4798      	blx	r3

	return ERR_NONE;
    259c:	2300      	movs	r3, #0
}
    259e:	0018      	movs	r0, r3
    25a0:	46bd      	mov	sp, r7
    25a2:	b005      	add	sp, #20
    25a4:	bd90      	pop	{r4, r7, pc}
    25a6:	46c0      	nop			; (mov r8, r8)
    25a8:	00002351 	.word	0x00002351
    25ac:	00002033 	.word	0x00002033
    25b0:	20000000 	.word	0x20000000
    25b4:	00002111 	.word	0x00002111
    25b8:	000020e5 	.word	0x000020e5
    25bc:	00002015 	.word	0x00002015
    25c0:	00002141 	.word	0x00002141
    25c4:	00002169 	.word	0x00002169
    25c8:	00002191 	.word	0x00002191
    25cc:	000021af 	.word	0x000021af
    25d0:	00002201 	.word	0x00002201

000025d4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    25d4:	b580      	push	{r7, lr}
    25d6:	b082      	sub	sp, #8
    25d8:	af00      	add	r7, sp, #0
    25da:	0002      	movs	r2, r0
    25dc:	1dfb      	adds	r3, r7, #7
    25de:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    25e0:	1dfb      	adds	r3, r7, #7
    25e2:	781b      	ldrb	r3, [r3, #0]
    25e4:	2b7f      	cmp	r3, #127	; 0x7f
    25e6:	d809      	bhi.n	25fc <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    25e8:	4b06      	ldr	r3, [pc, #24]	; (2604 <__NVIC_EnableIRQ+0x30>)
    25ea:	1dfa      	adds	r2, r7, #7
    25ec:	7812      	ldrb	r2, [r2, #0]
    25ee:	0011      	movs	r1, r2
    25f0:	221f      	movs	r2, #31
    25f2:	400a      	ands	r2, r1
    25f4:	2101      	movs	r1, #1
    25f6:	4091      	lsls	r1, r2
    25f8:	000a      	movs	r2, r1
    25fa:	601a      	str	r2, [r3, #0]
  }
}
    25fc:	46c0      	nop			; (mov r8, r8)
    25fe:	46bd      	mov	sp, r7
    2600:	b002      	add	sp, #8
    2602:	bd80      	pop	{r7, pc}
    2604:	e000e100 	.word	0xe000e100

00002608 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
    2608:	b580      	push	{r7, lr}
    260a:	b082      	sub	sp, #8
    260c:	af00      	add	r7, sp, #0
    260e:	0002      	movs	r2, r0
    2610:	1dfb      	adds	r3, r7, #7
    2612:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    2614:	1dfb      	adds	r3, r7, #7
    2616:	781b      	ldrb	r3, [r3, #0]
    2618:	2b7f      	cmp	r3, #127	; 0x7f
    261a:	d80e      	bhi.n	263a <__NVIC_DisableIRQ+0x32>
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    261c:	4909      	ldr	r1, [pc, #36]	; (2644 <__NVIC_DisableIRQ+0x3c>)
    261e:	1dfb      	adds	r3, r7, #7
    2620:	781b      	ldrb	r3, [r3, #0]
    2622:	001a      	movs	r2, r3
    2624:	231f      	movs	r3, #31
    2626:	4013      	ands	r3, r2
    2628:	2201      	movs	r2, #1
    262a:	409a      	lsls	r2, r3
    262c:	0013      	movs	r3, r2
    262e:	2280      	movs	r2, #128	; 0x80
    2630:	508b      	str	r3, [r1, r2]
  __ASM volatile ("dsb 0xF":::"memory");
    2632:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2636:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
    263a:	46c0      	nop			; (mov r8, r8)
    263c:	46bd      	mov	sp, r7
    263e:	b002      	add	sp, #8
    2640:	bd80      	pop	{r7, pc}
    2642:	46c0      	nop			; (mov r8, r8)
    2644:	e000e100 	.word	0xe000e100

00002648 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    2648:	b580      	push	{r7, lr}
    264a:	b082      	sub	sp, #8
    264c:	af00      	add	r7, sp, #0
    264e:	0002      	movs	r2, r0
    2650:	1dfb      	adds	r3, r7, #7
    2652:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    2654:	1dfb      	adds	r3, r7, #7
    2656:	781b      	ldrb	r3, [r3, #0]
    2658:	2b7f      	cmp	r3, #127	; 0x7f
    265a:	d80a      	bhi.n	2672 <__NVIC_ClearPendingIRQ+0x2a>
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    265c:	4907      	ldr	r1, [pc, #28]	; (267c <__NVIC_ClearPendingIRQ+0x34>)
    265e:	1dfb      	adds	r3, r7, #7
    2660:	781b      	ldrb	r3, [r3, #0]
    2662:	001a      	movs	r2, r3
    2664:	231f      	movs	r3, #31
    2666:	4013      	ands	r3, r2
    2668:	2201      	movs	r2, #1
    266a:	409a      	lsls	r2, r3
    266c:	23c0      	movs	r3, #192	; 0xc0
    266e:	005b      	lsls	r3, r3, #1
    2670:	50ca      	str	r2, [r1, r3]
  }
}
    2672:	46c0      	nop			; (mov r8, r8)
    2674:	46bd      	mov	sp, r7
    2676:	b002      	add	sp, #8
    2678:	bd80      	pop	{r7, pc}
    267a:	46c0      	nop			; (mov r8, r8)
    267c:	e000e100 	.word	0xe000e100

00002680 <hri_tc_wait_for_sync>:
typedef uint8_t  hri_tccount8_count_reg_t;
typedef uint8_t  hri_tccount8_per_reg_t;
typedef uint8_t  hri_tccount8_perbuf_reg_t;

static inline void hri_tc_wait_for_sync(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
    2680:	b580      	push	{r7, lr}
    2682:	b082      	sub	sp, #8
    2684:	af00      	add	r7, sp, #0
    2686:	6078      	str	r0, [r7, #4]
    2688:	6039      	str	r1, [r7, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    268a:	46c0      	nop			; (mov r8, r8)
    268c:	687b      	ldr	r3, [r7, #4]
    268e:	691b      	ldr	r3, [r3, #16]
    2690:	683a      	ldr	r2, [r7, #0]
    2692:	4013      	ands	r3, r2
    2694:	d1fa      	bne.n	268c <hri_tc_wait_for_sync+0xc>
	};
}
    2696:	46c0      	nop			; (mov r8, r8)
    2698:	46bd      	mov	sp, r7
    269a:	b002      	add	sp, #8
    269c:	bd80      	pop	{r7, pc}

0000269e <hri_tc_is_syncing>:

static inline bool hri_tc_is_syncing(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
    269e:	b580      	push	{r7, lr}
    26a0:	b082      	sub	sp, #8
    26a2:	af00      	add	r7, sp, #0
    26a4:	6078      	str	r0, [r7, #4]
    26a6:	6039      	str	r1, [r7, #0]
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
    26a8:	687b      	ldr	r3, [r7, #4]
    26aa:	691b      	ldr	r3, [r3, #16]
    26ac:	683a      	ldr	r2, [r7, #0]
    26ae:	4013      	ands	r3, r2
    26b0:	1e5a      	subs	r2, r3, #1
    26b2:	4193      	sbcs	r3, r2
    26b4:	b2db      	uxtb	r3, r3
}
    26b6:	0018      	movs	r0, r3
    26b8:	46bd      	mov	sp, r7
    26ba:	b002      	add	sp, #8
    26bc:	bd80      	pop	{r7, pc}

000026be <hri_tc_get_interrupt_OVF_bit>:
{
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_MC1;
}

static inline bool hri_tc_get_interrupt_OVF_bit(const void *const hw)
{
    26be:	b580      	push	{r7, lr}
    26c0:	b082      	sub	sp, #8
    26c2:	af00      	add	r7, sp, #0
    26c4:	6078      	str	r0, [r7, #4]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    26c6:	687b      	ldr	r3, [r7, #4]
    26c8:	7a9b      	ldrb	r3, [r3, #10]
    26ca:	b2db      	uxtb	r3, r3
    26cc:	001a      	movs	r2, r3
    26ce:	2301      	movs	r3, #1
    26d0:	4013      	ands	r3, r2
    26d2:	1e5a      	subs	r2, r3, #1
    26d4:	4193      	sbcs	r3, r2
    26d6:	b2db      	uxtb	r3, r3
}
    26d8:	0018      	movs	r0, r3
    26da:	46bd      	mov	sp, r7
    26dc:	b002      	add	sp, #8
    26de:	bd80      	pop	{r7, pc}

000026e0 <hri_tc_clear_interrupt_OVF_bit>:

static inline void hri_tc_clear_interrupt_OVF_bit(const void *const hw)
{
    26e0:	b580      	push	{r7, lr}
    26e2:	b082      	sub	sp, #8
    26e4:	af00      	add	r7, sp, #0
    26e6:	6078      	str	r0, [r7, #4]
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    26e8:	687b      	ldr	r3, [r7, #4]
    26ea:	2201      	movs	r2, #1
    26ec:	729a      	strb	r2, [r3, #10]
}
    26ee:	46c0      	nop			; (mov r8, r8)
    26f0:	46bd      	mov	sp, r7
    26f2:	b002      	add	sp, #8
    26f4:	bd80      	pop	{r7, pc}

000026f6 <hri_tc_clear_interrupt_ERR_bit>:
{
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_ERR) >> TC_INTFLAG_ERR_Pos;
}

static inline void hri_tc_clear_interrupt_ERR_bit(const void *const hw)
{
    26f6:	b580      	push	{r7, lr}
    26f8:	b082      	sub	sp, #8
    26fa:	af00      	add	r7, sp, #0
    26fc:	6078      	str	r0, [r7, #4]
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_ERR;
    26fe:	687b      	ldr	r3, [r7, #4]
    2700:	2202      	movs	r2, #2
    2702:	729a      	strb	r2, [r3, #10]
}
    2704:	46c0      	nop			; (mov r8, r8)
    2706:	46bd      	mov	sp, r7
    2708:	b002      	add	sp, #8
    270a:	bd80      	pop	{r7, pc}

0000270c <hri_tc_get_INTEN_ERR_bit>:
{
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_ERR;
}

static inline bool hri_tc_get_INTEN_ERR_bit(const void *const hw)
{
    270c:	b580      	push	{r7, lr}
    270e:	b082      	sub	sp, #8
    2710:	af00      	add	r7, sp, #0
    2712:	6078      	str	r0, [r7, #4]
	return (((Tc *)hw)->COUNT16.INTENSET.reg & TC_INTENSET_ERR) >> TC_INTENSET_ERR_Pos;
    2714:	687b      	ldr	r3, [r7, #4]
    2716:	7a5b      	ldrb	r3, [r3, #9]
    2718:	b2db      	uxtb	r3, r3
    271a:	085b      	lsrs	r3, r3, #1
    271c:	2201      	movs	r2, #1
    271e:	4013      	ands	r3, r2
    2720:	1e5a      	subs	r2, r3, #1
    2722:	4193      	sbcs	r3, r2
    2724:	b2db      	uxtb	r3, r3
}
    2726:	0018      	movs	r0, r3
    2728:	46bd      	mov	sp, r7
    272a:	b002      	add	sp, #8
    272c:	bd80      	pop	{r7, pc}
	...

00002730 <hri_tc_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & TC_CTRLA_SWRST) >> TC_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_tc_set_CTRLA_ENABLE_bit(const void *const hw)
{
    2730:	b580      	push	{r7, lr}
    2732:	b082      	sub	sp, #8
    2734:	af00      	add	r7, sp, #0
    2736:	6078      	str	r0, [r7, #4]
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    2738:	687b      	ldr	r3, [r7, #4]
    273a:	681b      	ldr	r3, [r3, #0]
    273c:	2202      	movs	r2, #2
    273e:	431a      	orrs	r2, r3
    2740:	687b      	ldr	r3, [r7, #4]
    2742:	601a      	str	r2, [r3, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
    2744:	687b      	ldr	r3, [r7, #4]
    2746:	2103      	movs	r1, #3
    2748:	0018      	movs	r0, r3
    274a:	4b03      	ldr	r3, [pc, #12]	; (2758 <hri_tc_set_CTRLA_ENABLE_bit+0x28>)
    274c:	4798      	blx	r3
	TC_CRITICAL_SECTION_LEAVE();
}
    274e:	46c0      	nop			; (mov r8, r8)
    2750:	46bd      	mov	sp, r7
    2752:	b002      	add	sp, #8
    2754:	bd80      	pop	{r7, pc}
    2756:	46c0      	nop			; (mov r8, r8)
    2758:	00002681 	.word	0x00002681

0000275c <hri_tc_get_CTRLA_ENABLE_bit>:

static inline bool hri_tc_get_CTRLA_ENABLE_bit(const void *const hw)
{
    275c:	b580      	push	{r7, lr}
    275e:	b084      	sub	sp, #16
    2760:	af00      	add	r7, sp, #0
    2762:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
    2764:	687b      	ldr	r3, [r7, #4]
    2766:	2103      	movs	r1, #3
    2768:	0018      	movs	r0, r3
    276a:	4b09      	ldr	r3, [pc, #36]	; (2790 <hri_tc_get_CTRLA_ENABLE_bit+0x34>)
    276c:	4798      	blx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    276e:	687b      	ldr	r3, [r7, #4]
    2770:	681b      	ldr	r3, [r3, #0]
    2772:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & TC_CTRLA_ENABLE) >> TC_CTRLA_ENABLE_Pos;
    2774:	68fb      	ldr	r3, [r7, #12]
    2776:	085b      	lsrs	r3, r3, #1
    2778:	2201      	movs	r2, #1
    277a:	4013      	ands	r3, r2
    277c:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    277e:	68fb      	ldr	r3, [r7, #12]
    2780:	1e5a      	subs	r2, r3, #1
    2782:	4193      	sbcs	r3, r2
    2784:	b2db      	uxtb	r3, r3
}
    2786:	0018      	movs	r0, r3
    2788:	46bd      	mov	sp, r7
    278a:	b004      	add	sp, #16
    278c:	bd80      	pop	{r7, pc}
    278e:	46c0      	nop			; (mov r8, r8)
    2790:	00002681 	.word	0x00002681

00002794 <hri_tc_clear_CTRLA_ENABLE_bit>:
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	TC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_tc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    2794:	b580      	push	{r7, lr}
    2796:	b082      	sub	sp, #8
    2798:	af00      	add	r7, sp, #0
    279a:	6078      	str	r0, [r7, #4]
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    279c:	687b      	ldr	r3, [r7, #4]
    279e:	681b      	ldr	r3, [r3, #0]
    27a0:	2202      	movs	r2, #2
    27a2:	4393      	bics	r3, r2
    27a4:	001a      	movs	r2, r3
    27a6:	687b      	ldr	r3, [r7, #4]
    27a8:	601a      	str	r2, [r3, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
    27aa:	687b      	ldr	r3, [r7, #4]
    27ac:	2103      	movs	r1, #3
    27ae:	0018      	movs	r0, r3
    27b0:	4b02      	ldr	r3, [pc, #8]	; (27bc <hri_tc_clear_CTRLA_ENABLE_bit+0x28>)
    27b2:	4798      	blx	r3
	TC_CRITICAL_SECTION_LEAVE();
}
    27b4:	46c0      	nop			; (mov r8, r8)
    27b6:	46bd      	mov	sp, r7
    27b8:	b002      	add	sp, #8
    27ba:	bd80      	pop	{r7, pc}
    27bc:	00002681 	.word	0x00002681

000027c0 <hri_tc_get_CTRLA_reg>:
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	TC_CRITICAL_SECTION_LEAVE();
}

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
    27c0:	b580      	push	{r7, lr}
    27c2:	b084      	sub	sp, #16
    27c4:	af00      	add	r7, sp, #0
    27c6:	6078      	str	r0, [r7, #4]
    27c8:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
    27ca:	687b      	ldr	r3, [r7, #4]
    27cc:	2103      	movs	r1, #3
    27ce:	0018      	movs	r0, r3
    27d0:	4b06      	ldr	r3, [pc, #24]	; (27ec <hri_tc_get_CTRLA_reg+0x2c>)
    27d2:	4798      	blx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    27d4:	687b      	ldr	r3, [r7, #4]
    27d6:	681b      	ldr	r3, [r3, #0]
    27d8:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    27da:	68fb      	ldr	r3, [r7, #12]
    27dc:	683a      	ldr	r2, [r7, #0]
    27de:	4013      	ands	r3, r2
    27e0:	60fb      	str	r3, [r7, #12]
	return tmp;
    27e2:	68fb      	ldr	r3, [r7, #12]
}
    27e4:	0018      	movs	r0, r3
    27e6:	46bd      	mov	sp, r7
    27e8:	b004      	add	sp, #16
    27ea:	bd80      	pop	{r7, pc}
    27ec:	00002681 	.word	0x00002681

000027f0 <hri_tc_write_CTRLA_reg>:

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
    27f0:	b580      	push	{r7, lr}
    27f2:	b082      	sub	sp, #8
    27f4:	af00      	add	r7, sp, #0
    27f6:	6078      	str	r0, [r7, #4]
    27f8:	6039      	str	r1, [r7, #0]
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    27fa:	687b      	ldr	r3, [r7, #4]
    27fc:	683a      	ldr	r2, [r7, #0]
    27fe:	601a      	str	r2, [r3, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
    2800:	687b      	ldr	r3, [r7, #4]
    2802:	2103      	movs	r1, #3
    2804:	0018      	movs	r0, r3
    2806:	4b03      	ldr	r3, [pc, #12]	; (2814 <hri_tc_write_CTRLA_reg+0x24>)
    2808:	4798      	blx	r3
	TC_CRITICAL_SECTION_LEAVE();
}
    280a:	46c0      	nop			; (mov r8, r8)
    280c:	46bd      	mov	sp, r7
    280e:	b002      	add	sp, #8
    2810:	bd80      	pop	{r7, pc}
    2812:	46c0      	nop			; (mov r8, r8)
    2814:	00002681 	.word	0x00002681

00002818 <hri_tc_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tc_write_EVCTRL_reg(const void *const hw, hri_tc_evctrl_reg_t data)
{
    2818:	b580      	push	{r7, lr}
    281a:	b082      	sub	sp, #8
    281c:	af00      	add	r7, sp, #0
    281e:	6078      	str	r0, [r7, #4]
    2820:	000a      	movs	r2, r1
    2822:	1cbb      	adds	r3, r7, #2
    2824:	801a      	strh	r2, [r3, #0]
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
    2826:	687b      	ldr	r3, [r7, #4]
    2828:	1cba      	adds	r2, r7, #2
    282a:	8812      	ldrh	r2, [r2, #0]
    282c:	80da      	strh	r2, [r3, #6]
	TC_CRITICAL_SECTION_LEAVE();
}
    282e:	46c0      	nop			; (mov r8, r8)
    2830:	46bd      	mov	sp, r7
    2832:	b002      	add	sp, #8
    2834:	bd80      	pop	{r7, pc}

00002836 <hri_tc_write_WAVE_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tc_write_WAVE_reg(const void *const hw, hri_tc_wave_reg_t data)
{
    2836:	b580      	push	{r7, lr}
    2838:	b082      	sub	sp, #8
    283a:	af00      	add	r7, sp, #0
    283c:	6078      	str	r0, [r7, #4]
    283e:	000a      	movs	r2, r1
    2840:	1cfb      	adds	r3, r7, #3
    2842:	701a      	strb	r2, [r3, #0]
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.WAVE.reg = data;
    2844:	687b      	ldr	r3, [r7, #4]
    2846:	1cfa      	adds	r2, r7, #3
    2848:	7812      	ldrb	r2, [r2, #0]
    284a:	731a      	strb	r2, [r3, #12]
	TC_CRITICAL_SECTION_LEAVE();
}
    284c:	46c0      	nop			; (mov r8, r8)
    284e:	46bd      	mov	sp, r7
    2850:	b002      	add	sp, #8
    2852:	bd80      	pop	{r7, pc}

00002854 <hri_tc_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
    2854:	b580      	push	{r7, lr}
    2856:	b082      	sub	sp, #8
    2858:	af00      	add	r7, sp, #0
    285a:	6078      	str	r0, [r7, #4]
    285c:	000a      	movs	r2, r1
    285e:	1cfb      	adds	r3, r7, #3
    2860:	701a      	strb	r2, [r3, #0]
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
    2862:	687b      	ldr	r3, [r7, #4]
    2864:	1cfa      	adds	r2, r7, #3
    2866:	7812      	ldrb	r2, [r2, #0]
    2868:	73da      	strb	r2, [r3, #15]
	TC_CRITICAL_SECTION_LEAVE();
}
    286a:	46c0      	nop			; (mov r8, r8)
    286c:	46bd      	mov	sp, r7
    286e:	b002      	add	sp, #8
    2870:	bd80      	pop	{r7, pc}
	...

00002874 <hri_tccount16_write_CC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tccount16_write_CC_reg(const void *const hw, uint8_t index, hri_tccount16_cc_reg_t data)
{
    2874:	b580      	push	{r7, lr}
    2876:	b082      	sub	sp, #8
    2878:	af00      	add	r7, sp, #0
    287a:	6078      	str	r0, [r7, #4]
    287c:	0008      	movs	r0, r1
    287e:	0011      	movs	r1, r2
    2880:	1cfb      	adds	r3, r7, #3
    2882:	1c02      	adds	r2, r0, #0
    2884:	701a      	strb	r2, [r3, #0]
    2886:	003b      	movs	r3, r7
    2888:	1c0a      	adds	r2, r1, #0
    288a:	801a      	strh	r2, [r3, #0]
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    288c:	1cfb      	adds	r3, r7, #3
    288e:	781b      	ldrb	r3, [r3, #0]
    2890:	687a      	ldr	r2, [r7, #4]
    2892:	330c      	adds	r3, #12
    2894:	005b      	lsls	r3, r3, #1
    2896:	18d3      	adds	r3, r2, r3
    2898:	3304      	adds	r3, #4
    289a:	003a      	movs	r2, r7
    289c:	8812      	ldrh	r2, [r2, #0]
    289e:	801a      	strh	r2, [r3, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
    28a0:	687b      	ldr	r3, [r7, #4]
    28a2:	21c0      	movs	r1, #192	; 0xc0
    28a4:	0018      	movs	r0, r3
    28a6:	4b03      	ldr	r3, [pc, #12]	; (28b4 <hri_tccount16_write_CC_reg+0x40>)
    28a8:	4798      	blx	r3
	TC_CRITICAL_SECTION_LEAVE();
}
    28aa:	46c0      	nop			; (mov r8, r8)
    28ac:	46bd      	mov	sp, r7
    28ae:	b002      	add	sp, #8
    28b0:	bd80      	pop	{r7, pc}
    28b2:	46c0      	nop			; (mov r8, r8)
    28b4:	00002681 	.word	0x00002681

000028b8 <hri_tccount32_write_CC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
    28b8:	b580      	push	{r7, lr}
    28ba:	b084      	sub	sp, #16
    28bc:	af00      	add	r7, sp, #0
    28be:	60f8      	str	r0, [r7, #12]
    28c0:	607a      	str	r2, [r7, #4]
    28c2:	230b      	movs	r3, #11
    28c4:	18fb      	adds	r3, r7, r3
    28c6:	1c0a      	adds	r2, r1, #0
    28c8:	701a      	strb	r2, [r3, #0]
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    28ca:	230b      	movs	r3, #11
    28cc:	18fb      	adds	r3, r7, r3
    28ce:	781b      	ldrb	r3, [r3, #0]
    28d0:	68fa      	ldr	r2, [r7, #12]
    28d2:	3306      	adds	r3, #6
    28d4:	009b      	lsls	r3, r3, #2
    28d6:	18d3      	adds	r3, r2, r3
    28d8:	3304      	adds	r3, #4
    28da:	687a      	ldr	r2, [r7, #4]
    28dc:	601a      	str	r2, [r3, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
    28de:	68fb      	ldr	r3, [r7, #12]
    28e0:	21c0      	movs	r1, #192	; 0xc0
    28e2:	0018      	movs	r0, r3
    28e4:	4b02      	ldr	r3, [pc, #8]	; (28f0 <hri_tccount32_write_CC_reg+0x38>)
    28e6:	4798      	blx	r3
	TC_CRITICAL_SECTION_LEAVE();
}
    28e8:	46c0      	nop			; (mov r8, r8)
    28ea:	46bd      	mov	sp, r7
    28ec:	b004      	add	sp, #16
    28ee:	bd80      	pop	{r7, pc}
    28f0:	00002681 	.word	0x00002681

000028f4 <_pwm_init>:
static inline uint8_t _get_hardware_offset(const void *const hw);
/**
 * \brief Initialize TC for PWM mode
 */
int32_t _pwm_init(struct _pwm_device *const device, void *const hw)
{
    28f4:	b590      	push	{r4, r7, lr}
    28f6:	b085      	sub	sp, #20
    28f8:	af00      	add	r7, sp, #0
    28fa:	6078      	str	r0, [r7, #4]
    28fc:	6039      	str	r1, [r7, #0]
	int8_t i   = get_tc_index(hw);
    28fe:	230f      	movs	r3, #15
    2900:	18fc      	adds	r4, r7, r3
    2902:	683b      	ldr	r3, [r7, #0]
    2904:	0018      	movs	r0, r3
    2906:	4b85      	ldr	r3, [pc, #532]	; (2b1c <_pwm_init+0x228>)
    2908:	4798      	blx	r3
    290a:	0003      	movs	r3, r0
    290c:	7023      	strb	r3, [r4, #0]
	device->hw = hw;
    290e:	687b      	ldr	r3, [r7, #4]
    2910:	683a      	ldr	r2, [r7, #0]
    2912:	611a      	str	r2, [r3, #16]

	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
    2914:	683b      	ldr	r3, [r7, #0]
    2916:	2101      	movs	r1, #1
    2918:	0018      	movs	r0, r3
    291a:	4b81      	ldr	r3, [pc, #516]	; (2b20 <_pwm_init+0x22c>)
    291c:	4798      	blx	r3
    291e:	0003      	movs	r3, r0
    2920:	001a      	movs	r2, r3
    2922:	2301      	movs	r3, #1
    2924:	4053      	eors	r3, r2
    2926:	b2db      	uxtb	r3, r3
    2928:	2b00      	cmp	r3, #0
    292a:	d014      	beq.n	2956 <_pwm_init+0x62>
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
    292c:	683b      	ldr	r3, [r7, #0]
    292e:	2102      	movs	r1, #2
    2930:	0018      	movs	r0, r3
    2932:	4b7c      	ldr	r3, [pc, #496]	; (2b24 <_pwm_init+0x230>)
    2934:	4798      	blx	r3
    2936:	1e03      	subs	r3, r0, #0
    2938:	d008      	beq.n	294c <_pwm_init+0x58>
			hri_tc_clear_CTRLA_ENABLE_bit(hw);
    293a:	683b      	ldr	r3, [r7, #0]
    293c:	0018      	movs	r0, r3
    293e:	4b7a      	ldr	r3, [pc, #488]	; (2b28 <_pwm_init+0x234>)
    2940:	4798      	blx	r3
			hri_tc_wait_for_sync(hw, TC_SYNCBUSY_ENABLE);
    2942:	683b      	ldr	r3, [r7, #0]
    2944:	2102      	movs	r1, #2
    2946:	0018      	movs	r0, r3
    2948:	4b78      	ldr	r3, [pc, #480]	; (2b2c <_pwm_init+0x238>)
    294a:	4798      	blx	r3
		}
		hri_tc_write_CTRLA_reg(hw, TC_CTRLA_SWRST);
    294c:	683b      	ldr	r3, [r7, #0]
    294e:	2101      	movs	r1, #1
    2950:	0018      	movs	r0, r3
    2952:	4b77      	ldr	r3, [pc, #476]	; (2b30 <_pwm_init+0x23c>)
    2954:	4798      	blx	r3
	}
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
    2956:	683b      	ldr	r3, [r7, #0]
    2958:	2101      	movs	r1, #1
    295a:	0018      	movs	r0, r3
    295c:	4b73      	ldr	r3, [pc, #460]	; (2b2c <_pwm_init+0x238>)
    295e:	4798      	blx	r3

	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
    2960:	230f      	movs	r3, #15
    2962:	18fb      	adds	r3, r7, r3
    2964:	2200      	movs	r2, #0
    2966:	569a      	ldrsb	r2, [r3, r2]
    2968:	4972      	ldr	r1, [pc, #456]	; (2b34 <_pwm_init+0x240>)
    296a:	0013      	movs	r3, r2
    296c:	009b      	lsls	r3, r3, #2
    296e:	189b      	adds	r3, r3, r2
    2970:	009b      	lsls	r3, r3, #2
    2972:	18cb      	adds	r3, r1, r3
    2974:	3304      	adds	r3, #4
    2976:	681a      	ldr	r2, [r3, #0]
    2978:	683b      	ldr	r3, [r7, #0]
    297a:	0011      	movs	r1, r2
    297c:	0018      	movs	r0, r3
    297e:	4b6c      	ldr	r3, [pc, #432]	; (2b30 <_pwm_init+0x23c>)
    2980:	4798      	blx	r3
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
    2982:	230f      	movs	r3, #15
    2984:	18fb      	adds	r3, r7, r3
    2986:	2200      	movs	r2, #0
    2988:	569a      	ldrsb	r2, [r3, r2]
    298a:	496a      	ldr	r1, [pc, #424]	; (2b34 <_pwm_init+0x240>)
    298c:	0013      	movs	r3, r2
    298e:	009b      	lsls	r3, r3, #2
    2990:	189b      	adds	r3, r3, r2
    2992:	009b      	lsls	r3, r3, #2
    2994:	18cb      	adds	r3, r1, r3
    2996:	330a      	adds	r3, #10
    2998:	781a      	ldrb	r2, [r3, #0]
    299a:	683b      	ldr	r3, [r7, #0]
    299c:	0011      	movs	r1, r2
    299e:	0018      	movs	r0, r3
    29a0:	4b65      	ldr	r3, [pc, #404]	; (2b38 <_pwm_init+0x244>)
    29a2:	4798      	blx	r3
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
    29a4:	230f      	movs	r3, #15
    29a6:	18fb      	adds	r3, r7, r3
    29a8:	2200      	movs	r2, #0
    29aa:	569a      	ldrsb	r2, [r3, r2]
    29ac:	4961      	ldr	r1, [pc, #388]	; (2b34 <_pwm_init+0x240>)
    29ae:	0013      	movs	r3, r2
    29b0:	009b      	lsls	r3, r3, #2
    29b2:	189b      	adds	r3, r3, r2
    29b4:	009b      	lsls	r3, r3, #2
    29b6:	18cb      	adds	r3, r1, r3
    29b8:	3308      	adds	r3, #8
    29ba:	881a      	ldrh	r2, [r3, #0]
    29bc:	683b      	ldr	r3, [r7, #0]
    29be:	0011      	movs	r1, r2
    29c0:	0018      	movs	r0, r3
    29c2:	4b5e      	ldr	r3, [pc, #376]	; (2b3c <_pwm_init+0x248>)
    29c4:	4798      	blx	r3
	hri_tc_write_WAVE_reg(hw, TC_WAVE_WAVEGEN_MPWM_Val);
    29c6:	683b      	ldr	r3, [r7, #0]
    29c8:	2103      	movs	r1, #3
    29ca:	0018      	movs	r0, r3
    29cc:	4b5c      	ldr	r3, [pc, #368]	; (2b40 <_pwm_init+0x24c>)
    29ce:	4798      	blx	r3

	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    29d0:	230f      	movs	r3, #15
    29d2:	18fb      	adds	r3, r7, r3
    29d4:	2200      	movs	r2, #0
    29d6:	569a      	ldrsb	r2, [r3, r2]
    29d8:	4956      	ldr	r1, [pc, #344]	; (2b34 <_pwm_init+0x240>)
    29da:	0013      	movs	r3, r2
    29dc:	009b      	lsls	r3, r3, #2
    29de:	189b      	adds	r3, r3, r2
    29e0:	009b      	lsls	r3, r3, #2
    29e2:	18cb      	adds	r3, r1, r3
    29e4:	3304      	adds	r3, #4
    29e6:	681b      	ldr	r3, [r3, #0]
    29e8:	220c      	movs	r2, #12
    29ea:	4013      	ands	r3, r2
    29ec:	2b08      	cmp	r3, #8
    29ee:	d122      	bne.n	2a36 <_pwm_init+0x142>
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    29f0:	230f      	movs	r3, #15
    29f2:	18fb      	adds	r3, r7, r3
    29f4:	2200      	movs	r2, #0
    29f6:	569a      	ldrsb	r2, [r3, r2]
    29f8:	494e      	ldr	r1, [pc, #312]	; (2b34 <_pwm_init+0x240>)
    29fa:	0013      	movs	r3, r2
    29fc:	009b      	lsls	r3, r3, #2
    29fe:	189b      	adds	r3, r3, r2
    2a00:	009b      	lsls	r3, r3, #2
    2a02:	18cb      	adds	r3, r1, r3
    2a04:	330c      	adds	r3, #12
    2a06:	681a      	ldr	r2, [r3, #0]
    2a08:	683b      	ldr	r3, [r7, #0]
    2a0a:	2100      	movs	r1, #0
    2a0c:	0018      	movs	r0, r3
    2a0e:	4b4d      	ldr	r3, [pc, #308]	; (2b44 <_pwm_init+0x250>)
    2a10:	4798      	blx	r3
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
    2a12:	230f      	movs	r3, #15
    2a14:	18fb      	adds	r3, r7, r3
    2a16:	2200      	movs	r2, #0
    2a18:	569a      	ldrsb	r2, [r3, r2]
    2a1a:	4946      	ldr	r1, [pc, #280]	; (2b34 <_pwm_init+0x240>)
    2a1c:	0013      	movs	r3, r2
    2a1e:	009b      	lsls	r3, r3, #2
    2a20:	189b      	adds	r3, r3, r2
    2a22:	009b      	lsls	r3, r3, #2
    2a24:	18cb      	adds	r3, r1, r3
    2a26:	3310      	adds	r3, #16
    2a28:	681a      	ldr	r2, [r3, #0]
    2a2a:	683b      	ldr	r3, [r7, #0]
    2a2c:	2101      	movs	r1, #1
    2a2e:	0018      	movs	r0, r3
    2a30:	4b44      	ldr	r3, [pc, #272]	; (2b44 <_pwm_init+0x250>)
    2a32:	4798      	blx	r3
    2a34:	e036      	b.n	2aa4 <_pwm_init+0x1b0>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
    2a36:	230f      	movs	r3, #15
    2a38:	18fb      	adds	r3, r7, r3
    2a3a:	2200      	movs	r2, #0
    2a3c:	569a      	ldrsb	r2, [r3, r2]
    2a3e:	493d      	ldr	r1, [pc, #244]	; (2b34 <_pwm_init+0x240>)
    2a40:	0013      	movs	r3, r2
    2a42:	009b      	lsls	r3, r3, #2
    2a44:	189b      	adds	r3, r3, r2
    2a46:	009b      	lsls	r3, r3, #2
    2a48:	18cb      	adds	r3, r1, r3
    2a4a:	3304      	adds	r3, #4
    2a4c:	681b      	ldr	r3, [r3, #0]
    2a4e:	220c      	movs	r2, #12
    2a50:	4013      	ands	r3, r2
    2a52:	d124      	bne.n	2a9e <_pwm_init+0x1aa>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
    2a54:	230f      	movs	r3, #15
    2a56:	18fb      	adds	r3, r7, r3
    2a58:	2200      	movs	r2, #0
    2a5a:	569a      	ldrsb	r2, [r3, r2]
    2a5c:	4935      	ldr	r1, [pc, #212]	; (2b34 <_pwm_init+0x240>)
    2a5e:	0013      	movs	r3, r2
    2a60:	009b      	lsls	r3, r3, #2
    2a62:	189b      	adds	r3, r3, r2
    2a64:	009b      	lsls	r3, r3, #2
    2a66:	18cb      	adds	r3, r1, r3
    2a68:	330c      	adds	r3, #12
    2a6a:	681b      	ldr	r3, [r3, #0]
    2a6c:	b29a      	uxth	r2, r3
    2a6e:	683b      	ldr	r3, [r7, #0]
    2a70:	2100      	movs	r1, #0
    2a72:	0018      	movs	r0, r3
    2a74:	4b34      	ldr	r3, [pc, #208]	; (2b48 <_pwm_init+0x254>)
    2a76:	4798      	blx	r3
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
    2a78:	230f      	movs	r3, #15
    2a7a:	18fb      	adds	r3, r7, r3
    2a7c:	2200      	movs	r2, #0
    2a7e:	569a      	ldrsb	r2, [r3, r2]
    2a80:	492c      	ldr	r1, [pc, #176]	; (2b34 <_pwm_init+0x240>)
    2a82:	0013      	movs	r3, r2
    2a84:	009b      	lsls	r3, r3, #2
    2a86:	189b      	adds	r3, r3, r2
    2a88:	009b      	lsls	r3, r3, #2
    2a8a:	18cb      	adds	r3, r1, r3
    2a8c:	3310      	adds	r3, #16
    2a8e:	681b      	ldr	r3, [r3, #0]
    2a90:	b29a      	uxth	r2, r3
    2a92:	683b      	ldr	r3, [r7, #0]
    2a94:	2101      	movs	r1, #1
    2a96:	0018      	movs	r0, r3
    2a98:	4b2b      	ldr	r3, [pc, #172]	; (2b48 <_pwm_init+0x254>)
    2a9a:	4798      	blx	r3
    2a9c:	e002      	b.n	2aa4 <_pwm_init+0x1b0>
	} else {
		/* 8-bit resolution is not accepted by duty cycle control */
		return -1;
    2a9e:	2301      	movs	r3, #1
    2aa0:	425b      	negs	r3, r3
    2aa2:	e036      	b.n	2b12 <_pwm_init+0x21e>
	}

	_tc_init_irq_param(hw, (void *)device);
    2aa4:	687a      	ldr	r2, [r7, #4]
    2aa6:	683b      	ldr	r3, [r7, #0]
    2aa8:	0011      	movs	r1, r2
    2aaa:	0018      	movs	r0, r3
    2aac:	4b27      	ldr	r3, [pc, #156]	; (2b4c <_pwm_init+0x258>)
    2aae:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
    2ab0:	230f      	movs	r3, #15
    2ab2:	18fb      	adds	r3, r7, r3
    2ab4:	2200      	movs	r2, #0
    2ab6:	569a      	ldrsb	r2, [r3, r2]
    2ab8:	491e      	ldr	r1, [pc, #120]	; (2b34 <_pwm_init+0x240>)
    2aba:	0013      	movs	r3, r2
    2abc:	009b      	lsls	r3, r3, #2
    2abe:	189b      	adds	r3, r3, r2
    2ac0:	009b      	lsls	r3, r3, #2
    2ac2:	18cb      	adds	r3, r1, r3
    2ac4:	3301      	adds	r3, #1
    2ac6:	781b      	ldrb	r3, [r3, #0]
    2ac8:	b25b      	sxtb	r3, r3
    2aca:	0018      	movs	r0, r3
    2acc:	4b20      	ldr	r3, [pc, #128]	; (2b50 <_pwm_init+0x25c>)
    2ace:	4798      	blx	r3
	NVIC_ClearPendingIRQ(_tcs[i].irq);
    2ad0:	230f      	movs	r3, #15
    2ad2:	18fb      	adds	r3, r7, r3
    2ad4:	2200      	movs	r2, #0
    2ad6:	569a      	ldrsb	r2, [r3, r2]
    2ad8:	4916      	ldr	r1, [pc, #88]	; (2b34 <_pwm_init+0x240>)
    2ada:	0013      	movs	r3, r2
    2adc:	009b      	lsls	r3, r3, #2
    2ade:	189b      	adds	r3, r3, r2
    2ae0:	009b      	lsls	r3, r3, #2
    2ae2:	18cb      	adds	r3, r1, r3
    2ae4:	3301      	adds	r3, #1
    2ae6:	781b      	ldrb	r3, [r3, #0]
    2ae8:	b25b      	sxtb	r3, r3
    2aea:	0018      	movs	r0, r3
    2aec:	4b19      	ldr	r3, [pc, #100]	; (2b54 <_pwm_init+0x260>)
    2aee:	4798      	blx	r3
	NVIC_EnableIRQ(_tcs[i].irq);
    2af0:	230f      	movs	r3, #15
    2af2:	18fb      	adds	r3, r7, r3
    2af4:	2200      	movs	r2, #0
    2af6:	569a      	ldrsb	r2, [r3, r2]
    2af8:	490e      	ldr	r1, [pc, #56]	; (2b34 <_pwm_init+0x240>)
    2afa:	0013      	movs	r3, r2
    2afc:	009b      	lsls	r3, r3, #2
    2afe:	189b      	adds	r3, r3, r2
    2b00:	009b      	lsls	r3, r3, #2
    2b02:	18cb      	adds	r3, r1, r3
    2b04:	3301      	adds	r3, #1
    2b06:	781b      	ldrb	r3, [r3, #0]
    2b08:	b25b      	sxtb	r3, r3
    2b0a:	0018      	movs	r0, r3
    2b0c:	4b12      	ldr	r3, [pc, #72]	; (2b58 <_pwm_init+0x264>)
    2b0e:	4798      	blx	r3

	return 0;
    2b10:	2300      	movs	r3, #0
}
    2b12:	0018      	movs	r0, r3
    2b14:	46bd      	mov	sp, r7
    2b16:	b005      	add	sp, #20
    2b18:	bd90      	pop	{r4, r7, pc}
    2b1a:	46c0      	nop			; (mov r8, r8)
    2b1c:	00002d75 	.word	0x00002d75
    2b20:	0000269f 	.word	0x0000269f
    2b24:	000027c1 	.word	0x000027c1
    2b28:	00002795 	.word	0x00002795
    2b2c:	00002681 	.word	0x00002681
    2b30:	000027f1 	.word	0x000027f1
    2b34:	20000014 	.word	0x20000014
    2b38:	00002855 	.word	0x00002855
    2b3c:	00002819 	.word	0x00002819
    2b40:	00002837 	.word	0x00002837
    2b44:	000028b9 	.word	0x000028b9
    2b48:	00002875 	.word	0x00002875
    2b4c:	00002e01 	.word	0x00002e01
    2b50:	00002609 	.word	0x00002609
    2b54:	00002649 	.word	0x00002649
    2b58:	000025d5 	.word	0x000025d5

00002b5c <_pwm_enable>:
}
/**
 * \brief Start PWM
 */
void _pwm_enable(struct _pwm_device *const device)
{
    2b5c:	b580      	push	{r7, lr}
    2b5e:	b082      	sub	sp, #8
    2b60:	af00      	add	r7, sp, #0
    2b62:	6078      	str	r0, [r7, #4]
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
    2b64:	687b      	ldr	r3, [r7, #4]
    2b66:	691b      	ldr	r3, [r3, #16]
    2b68:	0018      	movs	r0, r3
    2b6a:	4b03      	ldr	r3, [pc, #12]	; (2b78 <_pwm_enable+0x1c>)
    2b6c:	4798      	blx	r3
}
    2b6e:	46c0      	nop			; (mov r8, r8)
    2b70:	46bd      	mov	sp, r7
    2b72:	b002      	add	sp, #8
    2b74:	bd80      	pop	{r7, pc}
    2b76:	46c0      	nop			; (mov r8, r8)
    2b78:	00002731 	.word	0x00002731

00002b7c <_pwm_disable>:
/**
 * \brief Stop PWM
 */
void _pwm_disable(struct _pwm_device *const device)
{
    2b7c:	b580      	push	{r7, lr}
    2b7e:	b082      	sub	sp, #8
    2b80:	af00      	add	r7, sp, #0
    2b82:	6078      	str	r0, [r7, #4]
	hri_tc_clear_CTRLA_ENABLE_bit(device->hw);
    2b84:	687b      	ldr	r3, [r7, #4]
    2b86:	691b      	ldr	r3, [r3, #16]
    2b88:	0018      	movs	r0, r3
    2b8a:	4b03      	ldr	r3, [pc, #12]	; (2b98 <_pwm_disable+0x1c>)
    2b8c:	4798      	blx	r3
}
    2b8e:	46c0      	nop			; (mov r8, r8)
    2b90:	46bd      	mov	sp, r7
    2b92:	b002      	add	sp, #8
    2b94:	bd80      	pop	{r7, pc}
    2b96:	46c0      	nop			; (mov r8, r8)
    2b98:	00002795 	.word	0x00002795

00002b9c <_pwm_set_param>:
/**
 * \brief Set PWM parameter
 */
void _pwm_set_param(struct _pwm_device *const device, const pwm_period_t period, const pwm_period_t duty_cycle)
{
    2b9c:	b590      	push	{r4, r7, lr}
    2b9e:	b087      	sub	sp, #28
    2ba0:	af00      	add	r7, sp, #0
    2ba2:	60f8      	str	r0, [r7, #12]
    2ba4:	60b9      	str	r1, [r7, #8]
    2ba6:	607a      	str	r2, [r7, #4]
	void *const hw = device->hw;
    2ba8:	68fb      	ldr	r3, [r7, #12]
    2baa:	691b      	ldr	r3, [r3, #16]
    2bac:	617b      	str	r3, [r7, #20]
	int8_t      i  = get_tc_index(hw);
    2bae:	2313      	movs	r3, #19
    2bb0:	18fc      	adds	r4, r7, r3
    2bb2:	697b      	ldr	r3, [r7, #20]
    2bb4:	0018      	movs	r0, r3
    2bb6:	4b3c      	ldr	r3, [pc, #240]	; (2ca8 <_pwm_set_param+0x10c>)
    2bb8:	4798      	blx	r3
    2bba:	0003      	movs	r3, r0
    2bbc:	7023      	strb	r3, [r4, #0]

	_tcs[i].cc0 = period;
    2bbe:	2313      	movs	r3, #19
    2bc0:	18fb      	adds	r3, r7, r3
    2bc2:	2200      	movs	r2, #0
    2bc4:	569a      	ldrsb	r2, [r3, r2]
    2bc6:	4939      	ldr	r1, [pc, #228]	; (2cac <_pwm_set_param+0x110>)
    2bc8:	0013      	movs	r3, r2
    2bca:	009b      	lsls	r3, r3, #2
    2bcc:	189b      	adds	r3, r3, r2
    2bce:	009b      	lsls	r3, r3, #2
    2bd0:	18cb      	adds	r3, r1, r3
    2bd2:	330c      	adds	r3, #12
    2bd4:	68ba      	ldr	r2, [r7, #8]
    2bd6:	601a      	str	r2, [r3, #0]
	_tcs[i].cc1 = duty_cycle;
    2bd8:	2313      	movs	r3, #19
    2bda:	18fb      	adds	r3, r7, r3
    2bdc:	2200      	movs	r2, #0
    2bde:	569a      	ldrsb	r2, [r3, r2]
    2be0:	4932      	ldr	r1, [pc, #200]	; (2cac <_pwm_set_param+0x110>)
    2be2:	0013      	movs	r3, r2
    2be4:	009b      	lsls	r3, r3, #2
    2be6:	189b      	adds	r3, r3, r2
    2be8:	009b      	lsls	r3, r3, #2
    2bea:	18cb      	adds	r3, r1, r3
    2bec:	3310      	adds	r3, #16
    2bee:	687a      	ldr	r2, [r7, #4]
    2bf0:	601a      	str	r2, [r3, #0]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    2bf2:	2313      	movs	r3, #19
    2bf4:	18fb      	adds	r3, r7, r3
    2bf6:	2200      	movs	r2, #0
    2bf8:	569a      	ldrsb	r2, [r3, r2]
    2bfa:	492c      	ldr	r1, [pc, #176]	; (2cac <_pwm_set_param+0x110>)
    2bfc:	0013      	movs	r3, r2
    2bfe:	009b      	lsls	r3, r3, #2
    2c00:	189b      	adds	r3, r3, r2
    2c02:	009b      	lsls	r3, r3, #2
    2c04:	18cb      	adds	r3, r1, r3
    2c06:	3304      	adds	r3, #4
    2c08:	681b      	ldr	r3, [r3, #0]
    2c0a:	220c      	movs	r2, #12
    2c0c:	4013      	ands	r3, r2
    2c0e:	2b08      	cmp	r3, #8
    2c10:	d122      	bne.n	2c58 <_pwm_set_param+0xbc>
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    2c12:	2313      	movs	r3, #19
    2c14:	18fb      	adds	r3, r7, r3
    2c16:	2200      	movs	r2, #0
    2c18:	569a      	ldrsb	r2, [r3, r2]
    2c1a:	4924      	ldr	r1, [pc, #144]	; (2cac <_pwm_set_param+0x110>)
    2c1c:	0013      	movs	r3, r2
    2c1e:	009b      	lsls	r3, r3, #2
    2c20:	189b      	adds	r3, r3, r2
    2c22:	009b      	lsls	r3, r3, #2
    2c24:	18cb      	adds	r3, r1, r3
    2c26:	330c      	adds	r3, #12
    2c28:	681a      	ldr	r2, [r3, #0]
    2c2a:	697b      	ldr	r3, [r7, #20]
    2c2c:	2100      	movs	r1, #0
    2c2e:	0018      	movs	r0, r3
    2c30:	4b1f      	ldr	r3, [pc, #124]	; (2cb0 <_pwm_set_param+0x114>)
    2c32:	4798      	blx	r3
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
    2c34:	2313      	movs	r3, #19
    2c36:	18fb      	adds	r3, r7, r3
    2c38:	2200      	movs	r2, #0
    2c3a:	569a      	ldrsb	r2, [r3, r2]
    2c3c:	491b      	ldr	r1, [pc, #108]	; (2cac <_pwm_set_param+0x110>)
    2c3e:	0013      	movs	r3, r2
    2c40:	009b      	lsls	r3, r3, #2
    2c42:	189b      	adds	r3, r3, r2
    2c44:	009b      	lsls	r3, r3, #2
    2c46:	18cb      	adds	r3, r1, r3
    2c48:	3310      	adds	r3, #16
    2c4a:	681a      	ldr	r2, [r3, #0]
    2c4c:	697b      	ldr	r3, [r7, #20]
    2c4e:	2101      	movs	r1, #1
    2c50:	0018      	movs	r0, r3
    2c52:	4b17      	ldr	r3, [pc, #92]	; (2cb0 <_pwm_set_param+0x114>)
    2c54:	4798      	blx	r3
	} else {
		hri_tccount16_write_CC_reg(hw, 0, _tcs[i].cc0);
		hri_tccount16_write_CC_reg(hw, 1, _tcs[i].cc1);
	}
}
    2c56:	e023      	b.n	2ca0 <_pwm_set_param+0x104>
		hri_tccount16_write_CC_reg(hw, 0, _tcs[i].cc0);
    2c58:	2313      	movs	r3, #19
    2c5a:	18fb      	adds	r3, r7, r3
    2c5c:	2200      	movs	r2, #0
    2c5e:	569a      	ldrsb	r2, [r3, r2]
    2c60:	4912      	ldr	r1, [pc, #72]	; (2cac <_pwm_set_param+0x110>)
    2c62:	0013      	movs	r3, r2
    2c64:	009b      	lsls	r3, r3, #2
    2c66:	189b      	adds	r3, r3, r2
    2c68:	009b      	lsls	r3, r3, #2
    2c6a:	18cb      	adds	r3, r1, r3
    2c6c:	330c      	adds	r3, #12
    2c6e:	681b      	ldr	r3, [r3, #0]
    2c70:	b29a      	uxth	r2, r3
    2c72:	697b      	ldr	r3, [r7, #20]
    2c74:	2100      	movs	r1, #0
    2c76:	0018      	movs	r0, r3
    2c78:	4b0e      	ldr	r3, [pc, #56]	; (2cb4 <_pwm_set_param+0x118>)
    2c7a:	4798      	blx	r3
		hri_tccount16_write_CC_reg(hw, 1, _tcs[i].cc1);
    2c7c:	2313      	movs	r3, #19
    2c7e:	18fb      	adds	r3, r7, r3
    2c80:	2200      	movs	r2, #0
    2c82:	569a      	ldrsb	r2, [r3, r2]
    2c84:	4909      	ldr	r1, [pc, #36]	; (2cac <_pwm_set_param+0x110>)
    2c86:	0013      	movs	r3, r2
    2c88:	009b      	lsls	r3, r3, #2
    2c8a:	189b      	adds	r3, r3, r2
    2c8c:	009b      	lsls	r3, r3, #2
    2c8e:	18cb      	adds	r3, r1, r3
    2c90:	3310      	adds	r3, #16
    2c92:	681b      	ldr	r3, [r3, #0]
    2c94:	b29a      	uxth	r2, r3
    2c96:	697b      	ldr	r3, [r7, #20]
    2c98:	2101      	movs	r1, #1
    2c9a:	0018      	movs	r0, r3
    2c9c:	4b05      	ldr	r3, [pc, #20]	; (2cb4 <_pwm_set_param+0x118>)
    2c9e:	4798      	blx	r3
}
    2ca0:	46c0      	nop			; (mov r8, r8)
    2ca2:	46bd      	mov	sp, r7
    2ca4:	b007      	add	sp, #28
    2ca6:	bd90      	pop	{r4, r7, pc}
    2ca8:	00002d75 	.word	0x00002d75
    2cac:	20000014 	.word	0x20000014
    2cb0:	000028b9 	.word	0x000028b9
    2cb4:	00002875 	.word	0x00002875

00002cb8 <_pwm_is_enabled>:
}
/**
 * \brief Check if PWM is running
 */
bool _pwm_is_enabled(const struct _pwm_device *const device)
{
    2cb8:	b580      	push	{r7, lr}
    2cba:	b082      	sub	sp, #8
    2cbc:	af00      	add	r7, sp, #0
    2cbe:	6078      	str	r0, [r7, #4]
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
    2cc0:	687b      	ldr	r3, [r7, #4]
    2cc2:	691b      	ldr	r3, [r3, #16]
    2cc4:	0018      	movs	r0, r3
    2cc6:	4b03      	ldr	r3, [pc, #12]	; (2cd4 <_pwm_is_enabled+0x1c>)
    2cc8:	4798      	blx	r3
    2cca:	0003      	movs	r3, r0
}
    2ccc:	0018      	movs	r0, r3
    2cce:	46bd      	mov	sp, r7
    2cd0:	b002      	add	sp, #8
    2cd2:	bd80      	pop	{r7, pc}
    2cd4:	0000275d 	.word	0x0000275d

00002cd8 <_tc_get_pwm>:

/**
 * \brief Retrieve pwm helper functions
 */
struct _pwm_hpl_interface *_tc_get_pwm(void)
{
    2cd8:	b580      	push	{r7, lr}
    2cda:	af00      	add	r7, sp, #0
	return NULL;
    2cdc:	2300      	movs	r3, #0
}
    2cde:	0018      	movs	r0, r3
    2ce0:	46bd      	mov	sp, r7
    2ce2:	bd80      	pop	{r7, pc}

00002ce4 <tc_pwm_interrupt_handler>:
 * \internal TC interrupt handler for PWM
 *
 * \param[in] instance TC instance number
 */
static void tc_pwm_interrupt_handler(struct _pwm_device *device)
{
    2ce4:	b580      	push	{r7, lr}
    2ce6:	b084      	sub	sp, #16
    2ce8:	af00      	add	r7, sp, #0
    2cea:	6078      	str	r0, [r7, #4]
	void *const hw = device->hw;
    2cec:	687b      	ldr	r3, [r7, #4]
    2cee:	691b      	ldr	r3, [r3, #16]
    2cf0:	60fb      	str	r3, [r7, #12]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    2cf2:	68fb      	ldr	r3, [r7, #12]
    2cf4:	0018      	movs	r0, r3
    2cf6:	4b14      	ldr	r3, [pc, #80]	; (2d48 <tc_pwm_interrupt_handler+0x64>)
    2cf8:	4798      	blx	r3
    2cfa:	1e03      	subs	r3, r0, #0
    2cfc:	d00c      	beq.n	2d18 <tc_pwm_interrupt_handler+0x34>
		hri_tc_clear_interrupt_OVF_bit(hw);
    2cfe:	68fb      	ldr	r3, [r7, #12]
    2d00:	0018      	movs	r0, r3
    2d02:	4b12      	ldr	r3, [pc, #72]	; (2d4c <tc_pwm_interrupt_handler+0x68>)
    2d04:	4798      	blx	r3
		if (NULL != device->callback.pwm_period_cb) {
    2d06:	687b      	ldr	r3, [r7, #4]
    2d08:	681b      	ldr	r3, [r3, #0]
    2d0a:	2b00      	cmp	r3, #0
    2d0c:	d004      	beq.n	2d18 <tc_pwm_interrupt_handler+0x34>
			device->callback.pwm_period_cb(device);
    2d0e:	687b      	ldr	r3, [r7, #4]
    2d10:	681b      	ldr	r3, [r3, #0]
    2d12:	687a      	ldr	r2, [r7, #4]
    2d14:	0010      	movs	r0, r2
    2d16:	4798      	blx	r3
		}
	}
	if (hri_tc_get_INTEN_ERR_bit(hw)) {
    2d18:	68fb      	ldr	r3, [r7, #12]
    2d1a:	0018      	movs	r0, r3
    2d1c:	4b0c      	ldr	r3, [pc, #48]	; (2d50 <tc_pwm_interrupt_handler+0x6c>)
    2d1e:	4798      	blx	r3
    2d20:	1e03      	subs	r3, r0, #0
    2d22:	d00c      	beq.n	2d3e <tc_pwm_interrupt_handler+0x5a>
		hri_tc_clear_interrupt_ERR_bit(hw);
    2d24:	68fb      	ldr	r3, [r7, #12]
    2d26:	0018      	movs	r0, r3
    2d28:	4b0a      	ldr	r3, [pc, #40]	; (2d54 <tc_pwm_interrupt_handler+0x70>)
    2d2a:	4798      	blx	r3
		if (NULL != device->callback.pwm_error_cb) {
    2d2c:	687b      	ldr	r3, [r7, #4]
    2d2e:	685b      	ldr	r3, [r3, #4]
    2d30:	2b00      	cmp	r3, #0
    2d32:	d004      	beq.n	2d3e <tc_pwm_interrupt_handler+0x5a>
			device->callback.pwm_error_cb(device);
    2d34:	687b      	ldr	r3, [r7, #4]
    2d36:	685b      	ldr	r3, [r3, #4]
    2d38:	687a      	ldr	r2, [r7, #4]
    2d3a:	0010      	movs	r0, r2
    2d3c:	4798      	blx	r3
		}
	}
}
    2d3e:	46c0      	nop			; (mov r8, r8)
    2d40:	46bd      	mov	sp, r7
    2d42:	b004      	add	sp, #16
    2d44:	bd80      	pop	{r7, pc}
    2d46:	46c0      	nop			; (mov r8, r8)
    2d48:	000026bf 	.word	0x000026bf
    2d4c:	000026e1 	.word	0x000026e1
    2d50:	0000270d 	.word	0x0000270d
    2d54:	000026f7 	.word	0x000026f7

00002d58 <TC0_Handler>:

/**
 * \brief TC interrupt handler
 */
void TC0_Handler(void)
{
    2d58:	b580      	push	{r7, lr}
    2d5a:	af00      	add	r7, sp, #0
	tc_pwm_interrupt_handler(_tc0_dev);
    2d5c:	4b03      	ldr	r3, [pc, #12]	; (2d6c <TC0_Handler+0x14>)
    2d5e:	681b      	ldr	r3, [r3, #0]
    2d60:	0018      	movs	r0, r3
    2d62:	4b03      	ldr	r3, [pc, #12]	; (2d70 <TC0_Handler+0x18>)
    2d64:	4798      	blx	r3
}
    2d66:	46c0      	nop			; (mov r8, r8)
    2d68:	46bd      	mov	sp, r7
    2d6a:	bd80      	pop	{r7, pc}
    2d6c:	20000048 	.word	0x20000048
    2d70:	00002ce5 	.word	0x00002ce5

00002d74 <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
    2d74:	b590      	push	{r4, r7, lr}
    2d76:	b085      	sub	sp, #20
    2d78:	af00      	add	r7, sp, #0
    2d7a:	6078      	str	r0, [r7, #4]
	uint8_t index = _get_hardware_offset(hw);
    2d7c:	230e      	movs	r3, #14
    2d7e:	18fc      	adds	r4, r7, r3
    2d80:	687b      	ldr	r3, [r7, #4]
    2d82:	0018      	movs	r0, r3
    2d84:	4b1a      	ldr	r3, [pc, #104]	; (2df0 <get_tc_index+0x7c>)
    2d86:	4798      	blx	r3
    2d88:	0003      	movs	r3, r0
    2d8a:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    2d8c:	230f      	movs	r3, #15
    2d8e:	18fb      	adds	r3, r7, r3
    2d90:	2200      	movs	r2, #0
    2d92:	701a      	strb	r2, [r3, #0]
    2d94:	e019      	b.n	2dca <get_tc_index+0x56>
		if (_tcs[i].number == index) {
    2d96:	230f      	movs	r3, #15
    2d98:	18fb      	adds	r3, r7, r3
    2d9a:	781a      	ldrb	r2, [r3, #0]
    2d9c:	4915      	ldr	r1, [pc, #84]	; (2df4 <get_tc_index+0x80>)
    2d9e:	0013      	movs	r3, r2
    2da0:	009b      	lsls	r3, r3, #2
    2da2:	189b      	adds	r3, r3, r2
    2da4:	009b      	lsls	r3, r3, #2
    2da6:	5c5b      	ldrb	r3, [r3, r1]
    2da8:	220e      	movs	r2, #14
    2daa:	18ba      	adds	r2, r7, r2
    2dac:	7812      	ldrb	r2, [r2, #0]
    2dae:	429a      	cmp	r2, r3
    2db0:	d104      	bne.n	2dbc <get_tc_index+0x48>
			return i;
    2db2:	230f      	movs	r3, #15
    2db4:	18fb      	adds	r3, r7, r3
    2db6:	781b      	ldrb	r3, [r3, #0]
    2db8:	b25b      	sxtb	r3, r3
    2dba:	e014      	b.n	2de6 <get_tc_index+0x72>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    2dbc:	230f      	movs	r3, #15
    2dbe:	18fb      	adds	r3, r7, r3
    2dc0:	781a      	ldrb	r2, [r3, #0]
    2dc2:	230f      	movs	r3, #15
    2dc4:	18fb      	adds	r3, r7, r3
    2dc6:	3201      	adds	r2, #1
    2dc8:	701a      	strb	r2, [r3, #0]
    2dca:	230f      	movs	r3, #15
    2dcc:	18fb      	adds	r3, r7, r3
    2dce:	781b      	ldrb	r3, [r3, #0]
    2dd0:	2b00      	cmp	r3, #0
    2dd2:	d0e0      	beq.n	2d96 <get_tc_index+0x22>
		}
	}

	ASSERT(false);
    2dd4:	23a9      	movs	r3, #169	; 0xa9
    2dd6:	005a      	lsls	r2, r3, #1
    2dd8:	4b07      	ldr	r3, [pc, #28]	; (2df8 <get_tc_index+0x84>)
    2dda:	0019      	movs	r1, r3
    2ddc:	2000      	movs	r0, #0
    2dde:	4b07      	ldr	r3, [pc, #28]	; (2dfc <get_tc_index+0x88>)
    2de0:	4798      	blx	r3
	return -1;
    2de2:	2301      	movs	r3, #1
    2de4:	425b      	negs	r3, r3
}
    2de6:	0018      	movs	r0, r3
    2de8:	46bd      	mov	sp, r7
    2dea:	b005      	add	sp, #20
    2dec:	bd90      	pop	{r4, r7, pc}
    2dee:	46c0      	nop			; (mov r8, r8)
    2df0:	00002e29 	.word	0x00002e29
    2df4:	20000014 	.word	0x20000014
    2df8:	00005ec0 	.word	0x00005ec0
    2dfc:	00001331 	.word	0x00001331

00002e00 <_tc_init_irq_param>:

/**
 * \brief Init irq param with the given tc hardware instance
 */
static void _tc_init_irq_param(const void *const hw, void *dev)
{
    2e00:	b580      	push	{r7, lr}
    2e02:	b082      	sub	sp, #8
    2e04:	af00      	add	r7, sp, #0
    2e06:	6078      	str	r0, [r7, #4]
    2e08:	6039      	str	r1, [r7, #0]
	if (hw == TC0) {
    2e0a:	687b      	ldr	r3, [r7, #4]
    2e0c:	4a04      	ldr	r2, [pc, #16]	; (2e20 <_tc_init_irq_param+0x20>)
    2e0e:	4293      	cmp	r3, r2
    2e10:	d102      	bne.n	2e18 <_tc_init_irq_param+0x18>
		_tc0_dev = (struct _pwm_device *)dev;
    2e12:	4b04      	ldr	r3, [pc, #16]	; (2e24 <_tc_init_irq_param+0x24>)
    2e14:	683a      	ldr	r2, [r7, #0]
    2e16:	601a      	str	r2, [r3, #0]
	}
}
    2e18:	46c0      	nop			; (mov r8, r8)
    2e1a:	46bd      	mov	sp, r7
    2e1c:	b002      	add	sp, #8
    2e1e:	bd80      	pop	{r7, pc}
    2e20:	42003000 	.word	0x42003000
    2e24:	20000048 	.word	0x20000048

00002e28 <_get_hardware_offset>:
 * \internal Retrieve TC hardware index
 *
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
    2e28:	b580      	push	{r7, lr}
    2e2a:	b082      	sub	sp, #8
    2e2c:	af00      	add	r7, sp, #0
    2e2e:	6078      	str	r0, [r7, #4]
	if ((uint32_t)TC4 == (uint32_t)hw) {
    2e30:	687b      	ldr	r3, [r7, #4]
    2e32:	4a07      	ldr	r2, [pc, #28]	; (2e50 <_get_hardware_offset+0x28>)
    2e34:	4293      	cmp	r3, r2
    2e36:	d101      	bne.n	2e3c <_get_hardware_offset+0x14>
		return 4;
    2e38:	2304      	movs	r3, #4
    2e3a:	e005      	b.n	2e48 <_get_hardware_offset+0x20>
	}
	return (((uint32_t)hw - (uint32_t)TC0) >> 10);
    2e3c:	687b      	ldr	r3, [r7, #4]
    2e3e:	4a05      	ldr	r2, [pc, #20]	; (2e54 <_get_hardware_offset+0x2c>)
    2e40:	4694      	mov	ip, r2
    2e42:	4463      	add	r3, ip
    2e44:	0a9b      	lsrs	r3, r3, #10
    2e46:	b2db      	uxtb	r3, r3
}
    2e48:	0018      	movs	r0, r3
    2e4a:	46bd      	mov	sp, r7
    2e4c:	b002      	add	sp, #8
    2e4e:	bd80      	pop	{r7, pc}
    2e50:	42004000 	.word	0x42004000
    2e54:	bdffd000 	.word	0xbdffd000

00002e58 <main>:
#include <atmel_start.h>
#include "mytasks.h"
int main(void)
{
    2e58:	b580      	push	{r7, lr}
    2e5a:	af00      	add	r7, sp, #0
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    2e5c:	4b02      	ldr	r3, [pc, #8]	; (2e68 <main+0x10>)
    2e5e:	4798      	blx	r3
	Create_all_tasks();
    2e60:	4b02      	ldr	r3, [pc, #8]	; (2e6c <main+0x14>)
    2e62:	4798      	blx	r3
	/* Replace with your application code */
	while (1) {
    2e64:	e7fe      	b.n	2e64 <main+0xc>
    2e66:	46c0      	nop			; (mov r8, r8)
    2e68:	0000011d 	.word	0x0000011d
    2e6c:	00003451 	.word	0x00003451

00002e70 <hri_port_read_DIR_reg>:
{
    2e70:	b580      	push	{r7, lr}
    2e72:	b082      	sub	sp, #8
    2e74:	af00      	add	r7, sp, #0
    2e76:	6078      	str	r0, [r7, #4]
    2e78:	000a      	movs	r2, r1
    2e7a:	1cfb      	adds	r3, r7, #3
    2e7c:	701a      	strb	r2, [r3, #0]
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    2e7e:	1cfb      	adds	r3, r7, #3
    2e80:	781a      	ldrb	r2, [r3, #0]
    2e82:	687b      	ldr	r3, [r7, #4]
    2e84:	01d2      	lsls	r2, r2, #7
    2e86:	58d3      	ldr	r3, [r2, r3]
}
    2e88:	0018      	movs	r0, r3
    2e8a:	46bd      	mov	sp, r7
    2e8c:	b002      	add	sp, #8
    2e8e:	bd80      	pop	{r7, pc}

00002e90 <hri_port_set_OUT_reg>:
{
    2e90:	b580      	push	{r7, lr}
    2e92:	b084      	sub	sp, #16
    2e94:	af00      	add	r7, sp, #0
    2e96:	60f8      	str	r0, [r7, #12]
    2e98:	607a      	str	r2, [r7, #4]
    2e9a:	230b      	movs	r3, #11
    2e9c:	18fb      	adds	r3, r7, r3
    2e9e:	1c0a      	adds	r2, r1, #0
    2ea0:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    2ea2:	230b      	movs	r3, #11
    2ea4:	18fb      	adds	r3, r7, r3
    2ea6:	781b      	ldrb	r3, [r3, #0]
    2ea8:	68fa      	ldr	r2, [r7, #12]
    2eaa:	01db      	lsls	r3, r3, #7
    2eac:	18d3      	adds	r3, r2, r3
    2eae:	3318      	adds	r3, #24
    2eb0:	687a      	ldr	r2, [r7, #4]
    2eb2:	601a      	str	r2, [r3, #0]
}
    2eb4:	46c0      	nop			; (mov r8, r8)
    2eb6:	46bd      	mov	sp, r7
    2eb8:	b004      	add	sp, #16
    2eba:	bd80      	pop	{r7, pc}

00002ebc <hri_port_read_OUT_reg>:
{
    2ebc:	b580      	push	{r7, lr}
    2ebe:	b082      	sub	sp, #8
    2ec0:	af00      	add	r7, sp, #0
    2ec2:	6078      	str	r0, [r7, #4]
    2ec4:	000a      	movs	r2, r1
    2ec6:	1cfb      	adds	r3, r7, #3
    2ec8:	701a      	strb	r2, [r3, #0]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    2eca:	1cfb      	adds	r3, r7, #3
    2ecc:	781b      	ldrb	r3, [r3, #0]
    2ece:	687a      	ldr	r2, [r7, #4]
    2ed0:	01db      	lsls	r3, r3, #7
    2ed2:	18d3      	adds	r3, r2, r3
    2ed4:	3310      	adds	r3, #16
    2ed6:	681b      	ldr	r3, [r3, #0]
}
    2ed8:	0018      	movs	r0, r3
    2eda:	46bd      	mov	sp, r7
    2edc:	b002      	add	sp, #8
    2ede:	bd80      	pop	{r7, pc}

00002ee0 <hri_port_clear_OUT_reg>:
{
    2ee0:	b580      	push	{r7, lr}
    2ee2:	b084      	sub	sp, #16
    2ee4:	af00      	add	r7, sp, #0
    2ee6:	60f8      	str	r0, [r7, #12]
    2ee8:	607a      	str	r2, [r7, #4]
    2eea:	230b      	movs	r3, #11
    2eec:	18fb      	adds	r3, r7, r3
    2eee:	1c0a      	adds	r2, r1, #0
    2ef0:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    2ef2:	230b      	movs	r3, #11
    2ef4:	18fb      	adds	r3, r7, r3
    2ef6:	781b      	ldrb	r3, [r3, #0]
    2ef8:	68fa      	ldr	r2, [r7, #12]
    2efa:	01db      	lsls	r3, r3, #7
    2efc:	18d3      	adds	r3, r2, r3
    2efe:	3314      	adds	r3, #20
    2f00:	687a      	ldr	r2, [r7, #4]
    2f02:	601a      	str	r2, [r3, #0]
}
    2f04:	46c0      	nop			; (mov r8, r8)
    2f06:	46bd      	mov	sp, r7
    2f08:	b004      	add	sp, #16
    2f0a:	bd80      	pop	{r7, pc}

00002f0c <hri_port_toggle_OUT_reg>:
{
    2f0c:	b580      	push	{r7, lr}
    2f0e:	b084      	sub	sp, #16
    2f10:	af00      	add	r7, sp, #0
    2f12:	60f8      	str	r0, [r7, #12]
    2f14:	607a      	str	r2, [r7, #4]
    2f16:	230b      	movs	r3, #11
    2f18:	18fb      	adds	r3, r7, r3
    2f1a:	1c0a      	adds	r2, r1, #0
    2f1c:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    2f1e:	230b      	movs	r3, #11
    2f20:	18fb      	adds	r3, r7, r3
    2f22:	781b      	ldrb	r3, [r3, #0]
    2f24:	68fa      	ldr	r2, [r7, #12]
    2f26:	01db      	lsls	r3, r3, #7
    2f28:	18d3      	adds	r3, r2, r3
    2f2a:	331c      	adds	r3, #28
    2f2c:	687a      	ldr	r2, [r7, #4]
    2f2e:	601a      	str	r2, [r3, #0]
}
    2f30:	46c0      	nop			; (mov r8, r8)
    2f32:	46bd      	mov	sp, r7
    2f34:	b004      	add	sp, #16
    2f36:	bd80      	pop	{r7, pc}

00002f38 <hri_port_read_IN_reg>:
{
    2f38:	b580      	push	{r7, lr}
    2f3a:	b082      	sub	sp, #8
    2f3c:	af00      	add	r7, sp, #0
    2f3e:	6078      	str	r0, [r7, #4]
    2f40:	000a      	movs	r2, r1
    2f42:	1cfb      	adds	r3, r7, #3
    2f44:	701a      	strb	r2, [r3, #0]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    2f46:	1cfb      	adds	r3, r7, #3
    2f48:	781b      	ldrb	r3, [r3, #0]
    2f4a:	687a      	ldr	r2, [r7, #4]
    2f4c:	01db      	lsls	r3, r3, #7
    2f4e:	18d3      	adds	r3, r2, r3
    2f50:	3320      	adds	r3, #32
    2f52:	681b      	ldr	r3, [r3, #0]
}
    2f54:	0018      	movs	r0, r3
    2f56:	46bd      	mov	sp, r7
    2f58:	b002      	add	sp, #8
    2f5a:	bd80      	pop	{r7, pc}

00002f5c <_gpio_set_level>:
{
    2f5c:	b580      	push	{r7, lr}
    2f5e:	b082      	sub	sp, #8
    2f60:	af00      	add	r7, sp, #0
    2f62:	6039      	str	r1, [r7, #0]
    2f64:	0011      	movs	r1, r2
    2f66:	1dfb      	adds	r3, r7, #7
    2f68:	1c02      	adds	r2, r0, #0
    2f6a:	701a      	strb	r2, [r3, #0]
    2f6c:	1dbb      	adds	r3, r7, #6
    2f6e:	1c0a      	adds	r2, r1, #0
    2f70:	701a      	strb	r2, [r3, #0]
	if (level) {
    2f72:	1dbb      	adds	r3, r7, #6
    2f74:	781b      	ldrb	r3, [r3, #0]
    2f76:	2b00      	cmp	r3, #0
    2f78:	d008      	beq.n	2f8c <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    2f7a:	683a      	ldr	r2, [r7, #0]
    2f7c:	1dfb      	adds	r3, r7, #7
    2f7e:	7819      	ldrb	r1, [r3, #0]
    2f80:	23c0      	movs	r3, #192	; 0xc0
    2f82:	05db      	lsls	r3, r3, #23
    2f84:	0018      	movs	r0, r3
    2f86:	4b07      	ldr	r3, [pc, #28]	; (2fa4 <_gpio_set_level+0x48>)
    2f88:	4798      	blx	r3
}
    2f8a:	e007      	b.n	2f9c <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    2f8c:	683a      	ldr	r2, [r7, #0]
    2f8e:	1dfb      	adds	r3, r7, #7
    2f90:	7819      	ldrb	r1, [r3, #0]
    2f92:	23c0      	movs	r3, #192	; 0xc0
    2f94:	05db      	lsls	r3, r3, #23
    2f96:	0018      	movs	r0, r3
    2f98:	4b03      	ldr	r3, [pc, #12]	; (2fa8 <_gpio_set_level+0x4c>)
    2f9a:	4798      	blx	r3
}
    2f9c:	46c0      	nop			; (mov r8, r8)
    2f9e:	46bd      	mov	sp, r7
    2fa0:	b002      	add	sp, #8
    2fa2:	bd80      	pop	{r7, pc}
    2fa4:	00002e91 	.word	0x00002e91
    2fa8:	00002ee1 	.word	0x00002ee1

00002fac <_gpio_toggle_level>:
{
    2fac:	b580      	push	{r7, lr}
    2fae:	b082      	sub	sp, #8
    2fb0:	af00      	add	r7, sp, #0
    2fb2:	0002      	movs	r2, r0
    2fb4:	6039      	str	r1, [r7, #0]
    2fb6:	1dfb      	adds	r3, r7, #7
    2fb8:	701a      	strb	r2, [r3, #0]
	hri_port_toggle_OUT_reg(PORT_IOBUS, port, mask);
    2fba:	683a      	ldr	r2, [r7, #0]
    2fbc:	1dfb      	adds	r3, r7, #7
    2fbe:	7819      	ldrb	r1, [r3, #0]
    2fc0:	23c0      	movs	r3, #192	; 0xc0
    2fc2:	05db      	lsls	r3, r3, #23
    2fc4:	0018      	movs	r0, r3
    2fc6:	4b03      	ldr	r3, [pc, #12]	; (2fd4 <_gpio_toggle_level+0x28>)
    2fc8:	4798      	blx	r3
}
    2fca:	46c0      	nop			; (mov r8, r8)
    2fcc:	46bd      	mov	sp, r7
    2fce:	b002      	add	sp, #8
    2fd0:	bd80      	pop	{r7, pc}
    2fd2:	46c0      	nop			; (mov r8, r8)
    2fd4:	00002f0d 	.word	0x00002f0d

00002fd8 <_gpio_get_level>:
{
    2fd8:	b580      	push	{r7, lr}
    2fda:	b086      	sub	sp, #24
    2fdc:	af00      	add	r7, sp, #0
    2fde:	0002      	movs	r2, r0
    2fe0:	1dfb      	adds	r3, r7, #7
    2fe2:	701a      	strb	r2, [r3, #0]
	CRITICAL_SECTION_ENTER();
    2fe4:	230c      	movs	r3, #12
    2fe6:	18fb      	adds	r3, r7, r3
    2fe8:	0018      	movs	r0, r3
    2fea:	4b18      	ldr	r3, [pc, #96]	; (304c <_gpio_get_level+0x74>)
    2fec:	4798      	blx	r3
	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT_IOBUS, port);
    2fee:	1dfb      	adds	r3, r7, #7
    2ff0:	781a      	ldrb	r2, [r3, #0]
    2ff2:	23c0      	movs	r3, #192	; 0xc0
    2ff4:	05db      	lsls	r3, r3, #23
    2ff6:	0011      	movs	r1, r2
    2ff8:	0018      	movs	r0, r3
    2ffa:	4b15      	ldr	r3, [pc, #84]	; (3050 <_gpio_get_level+0x78>)
    2ffc:	4798      	blx	r3
    2ffe:	0003      	movs	r3, r0
    3000:	617b      	str	r3, [r7, #20]
	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
    3002:	1dfb      	adds	r3, r7, #7
    3004:	781a      	ldrb	r2, [r3, #0]
    3006:	2382      	movs	r3, #130	; 0x82
    3008:	05db      	lsls	r3, r3, #23
    300a:	0011      	movs	r1, r2
    300c:	0018      	movs	r0, r3
    300e:	4b11      	ldr	r3, [pc, #68]	; (3054 <_gpio_get_level+0x7c>)
    3010:	4798      	blx	r3
    3012:	0002      	movs	r2, r0
    3014:	697b      	ldr	r3, [r7, #20]
    3016:	43db      	mvns	r3, r3
    3018:	4013      	ands	r3, r2
    301a:	613b      	str	r3, [r7, #16]
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    301c:	1dfb      	adds	r3, r7, #7
    301e:	781a      	ldrb	r2, [r3, #0]
    3020:	23c0      	movs	r3, #192	; 0xc0
    3022:	05db      	lsls	r3, r3, #23
    3024:	0011      	movs	r1, r2
    3026:	0018      	movs	r0, r3
    3028:	4b0b      	ldr	r3, [pc, #44]	; (3058 <_gpio_get_level+0x80>)
    302a:	4798      	blx	r3
    302c:	0002      	movs	r2, r0
    302e:	697b      	ldr	r3, [r7, #20]
    3030:	4013      	ands	r3, r2
    3032:	693a      	ldr	r2, [r7, #16]
    3034:	4313      	orrs	r3, r2
    3036:	613b      	str	r3, [r7, #16]
	CRITICAL_SECTION_LEAVE();
    3038:	230c      	movs	r3, #12
    303a:	18fb      	adds	r3, r7, r3
    303c:	0018      	movs	r0, r3
    303e:	4b07      	ldr	r3, [pc, #28]	; (305c <_gpio_get_level+0x84>)
    3040:	4798      	blx	r3
	return tmp;
    3042:	693b      	ldr	r3, [r7, #16]
}
    3044:	0018      	movs	r0, r3
    3046:	46bd      	mov	sp, r7
    3048:	b006      	add	sp, #24
    304a:	bd80      	pop	{r7, pc}
    304c:	00000e01 	.word	0x00000e01
    3050:	00002e71 	.word	0x00002e71
    3054:	00002f39 	.word	0x00002f39
    3058:	00002ebd 	.word	0x00002ebd
    305c:	00000e23 	.word	0x00000e23

00003060 <gpio_set_pin_level>:
{
    3060:	b580      	push	{r7, lr}
    3062:	b082      	sub	sp, #8
    3064:	af00      	add	r7, sp, #0
    3066:	0002      	movs	r2, r0
    3068:	1dfb      	adds	r3, r7, #7
    306a:	701a      	strb	r2, [r3, #0]
    306c:	1dbb      	adds	r3, r7, #6
    306e:	1c0a      	adds	r2, r1, #0
    3070:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    3072:	1dfb      	adds	r3, r7, #7
    3074:	781b      	ldrb	r3, [r3, #0]
    3076:	095b      	lsrs	r3, r3, #5
    3078:	b2d8      	uxtb	r0, r3
    307a:	1dfb      	adds	r3, r7, #7
    307c:	781b      	ldrb	r3, [r3, #0]
    307e:	221f      	movs	r2, #31
    3080:	4013      	ands	r3, r2
    3082:	2201      	movs	r2, #1
    3084:	409a      	lsls	r2, r3
    3086:	0011      	movs	r1, r2
    3088:	1dbb      	adds	r3, r7, #6
    308a:	781b      	ldrb	r3, [r3, #0]
    308c:	001a      	movs	r2, r3
    308e:	4b03      	ldr	r3, [pc, #12]	; (309c <gpio_set_pin_level+0x3c>)
    3090:	4798      	blx	r3
}
    3092:	46c0      	nop			; (mov r8, r8)
    3094:	46bd      	mov	sp, r7
    3096:	b002      	add	sp, #8
    3098:	bd80      	pop	{r7, pc}
    309a:	46c0      	nop			; (mov r8, r8)
    309c:	00002f5d 	.word	0x00002f5d

000030a0 <gpio_toggle_pin_level>:
 * Toggle the pin levels on pins defined by bit mask
 *
 * \param[in] pin       The pin number for device
 */
static inline void gpio_toggle_pin_level(const uint8_t pin)
{
    30a0:	b580      	push	{r7, lr}
    30a2:	b082      	sub	sp, #8
    30a4:	af00      	add	r7, sp, #0
    30a6:	0002      	movs	r2, r0
    30a8:	1dfb      	adds	r3, r7, #7
    30aa:	701a      	strb	r2, [r3, #0]
	_gpio_toggle_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin));
    30ac:	1dfb      	adds	r3, r7, #7
    30ae:	781b      	ldrb	r3, [r3, #0]
    30b0:	095b      	lsrs	r3, r3, #5
    30b2:	b2d8      	uxtb	r0, r3
    30b4:	1dfb      	adds	r3, r7, #7
    30b6:	781b      	ldrb	r3, [r3, #0]
    30b8:	221f      	movs	r2, #31
    30ba:	4013      	ands	r3, r2
    30bc:	2201      	movs	r2, #1
    30be:	409a      	lsls	r2, r3
    30c0:	0013      	movs	r3, r2
    30c2:	0019      	movs	r1, r3
    30c4:	4b02      	ldr	r3, [pc, #8]	; (30d0 <gpio_toggle_pin_level+0x30>)
    30c6:	4798      	blx	r3
}
    30c8:	46c0      	nop			; (mov r8, r8)
    30ca:	46bd      	mov	sp, r7
    30cc:	b002      	add	sp, #8
    30ce:	bd80      	pop	{r7, pc}
    30d0:	00002fad 	.word	0x00002fad

000030d4 <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
    30d4:	b580      	push	{r7, lr}
    30d6:	b082      	sub	sp, #8
    30d8:	af00      	add	r7, sp, #0
    30da:	0002      	movs	r2, r0
    30dc:	1dfb      	adds	r3, r7, #7
    30de:	701a      	strb	r2, [r3, #0]
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    30e0:	1dfb      	adds	r3, r7, #7
    30e2:	781b      	ldrb	r3, [r3, #0]
    30e4:	095b      	lsrs	r3, r3, #5
    30e6:	b2db      	uxtb	r3, r3
    30e8:	0018      	movs	r0, r3
    30ea:	4b09      	ldr	r3, [pc, #36]	; (3110 <gpio_get_pin_level+0x3c>)
    30ec:	4798      	blx	r3
    30ee:	0001      	movs	r1, r0
    30f0:	1dfb      	adds	r3, r7, #7
    30f2:	781b      	ldrb	r3, [r3, #0]
    30f4:	221f      	movs	r2, #31
    30f6:	4013      	ands	r3, r2
    30f8:	2201      	movs	r2, #1
    30fa:	409a      	lsls	r2, r3
    30fc:	0013      	movs	r3, r2
    30fe:	400b      	ands	r3, r1
    3100:	1e5a      	subs	r2, r3, #1
    3102:	4193      	sbcs	r3, r2
    3104:	b2db      	uxtb	r3, r3
}
    3106:	0018      	movs	r0, r3
    3108:	46bd      	mov	sp, r7
    310a:	b002      	add	sp, #8
    310c:	bd80      	pop	{r7, pc}
    310e:	46c0      	nop			; (mov r8, r8)
    3110:	00002fd9 	.word	0x00002fd9

00003114 <STATE_task>:
uint8_t UART_Buffer[100];
uint8_t UART_Send_Buffer[100];
int UART_Length = 0;

void STATE_task(void *p)
{
    3114:	b580      	push	{r7, lr}
    3116:	b086      	sub	sp, #24
    3118:	af00      	add	r7, sp, #0
    311a:	6078      	str	r0, [r7, #4]
	int total_moves = 0;
    311c:	2300      	movs	r3, #0
    311e:	617b      	str	r3, [r7, #20]
	//setup
	usart_sync_get_io_descriptor(&UART, &io);
    3120:	4abb      	ldr	r2, [pc, #748]	; (3410 <STATE_task+0x2fc>)
    3122:	4bbc      	ldr	r3, [pc, #752]	; (3414 <STATE_task+0x300>)
    3124:	0011      	movs	r1, r2
    3126:	0018      	movs	r0, r3
    3128:	4bbb      	ldr	r3, [pc, #748]	; (3418 <STATE_task+0x304>)
    312a:	4798      	blx	r3
	usart_sync_enable(&UART);
    312c:	4bb9      	ldr	r3, [pc, #740]	; (3414 <STATE_task+0x300>)
    312e:	0018      	movs	r0, r3
    3130:	4bba      	ldr	r3, [pc, #744]	; (341c <STATE_task+0x308>)
    3132:	4798      	blx	r3
	6 = move up infinite
	7 = move down infinite
	8 = full stop

*/
	UART_Send_Buffer[0] = 's';
    3134:	4bba      	ldr	r3, [pc, #744]	; (3420 <STATE_task+0x30c>)
    3136:	2273      	movs	r2, #115	; 0x73
    3138:	701a      	strb	r2, [r3, #0]
	UART_Send_Buffer[1] = '0';
    313a:	4bb9      	ldr	r3, [pc, #740]	; (3420 <STATE_task+0x30c>)
    313c:	2230      	movs	r2, #48	; 0x30
    313e:	705a      	strb	r2, [r3, #1]
	UART_Send_Buffer[2] = '\0';
    3140:	4bb7      	ldr	r3, [pc, #732]	; (3420 <STATE_task+0x30c>)
    3142:	2200      	movs	r2, #0
    3144:	709a      	strb	r2, [r3, #2]
	send_message(3);
    3146:	2003      	movs	r0, #3
    3148:	4bb6      	ldr	r3, [pc, #728]	; (3424 <STATE_task+0x310>)
    314a:	4798      	blx	r3

	while(1)
	{
		if(gpio_get_pin_level(down) == 0 ||gpio_get_pin_level(up) == 0 )
    314c:	2015      	movs	r0, #21
    314e:	4bb6      	ldr	r3, [pc, #728]	; (3428 <STATE_task+0x314>)
    3150:	4798      	blx	r3
    3152:	0003      	movs	r3, r0
    3154:	001a      	movs	r2, r3
    3156:	2301      	movs	r3, #1
    3158:	4053      	eors	r3, r2
    315a:	b2db      	uxtb	r3, r3
    315c:	2b00      	cmp	r3, #0
    315e:	d109      	bne.n	3174 <STATE_task+0x60>
    3160:	2014      	movs	r0, #20
    3162:	4bb1      	ldr	r3, [pc, #708]	; (3428 <STATE_task+0x314>)
    3164:	4798      	blx	r3
    3166:	0003      	movs	r3, r0
    3168:	001a      	movs	r2, r3
    316a:	2301      	movs	r3, #1
    316c:	4053      	eors	r3, r2
    316e:	b2db      	uxtb	r3, r3
    3170:	2b00      	cmp	r3, #0
    3172:	d002      	beq.n	317a <STATE_task+0x66>
		{
			pwm(OFF);			
    3174:	2002      	movs	r0, #2
    3176:	4bad      	ldr	r3, [pc, #692]	; (342c <STATE_task+0x318>)
    3178:	4798      	blx	r3
		}
		wait_for_responce();
    317a:	4bad      	ldr	r3, [pc, #692]	; (3430 <STATE_task+0x31c>)
    317c:	4798      	blx	r3
		if(gpio_get_pin_level(down) == 0 ||gpio_get_pin_level(up) == 0 )
    317e:	2015      	movs	r0, #21
    3180:	4ba9      	ldr	r3, [pc, #676]	; (3428 <STATE_task+0x314>)
    3182:	4798      	blx	r3
    3184:	0003      	movs	r3, r0
    3186:	001a      	movs	r2, r3
    3188:	2301      	movs	r3, #1
    318a:	4053      	eors	r3, r2
    318c:	b2db      	uxtb	r3, r3
    318e:	2b00      	cmp	r3, #0
    3190:	d109      	bne.n	31a6 <STATE_task+0x92>
    3192:	2014      	movs	r0, #20
    3194:	4ba4      	ldr	r3, [pc, #656]	; (3428 <STATE_task+0x314>)
    3196:	4798      	blx	r3
    3198:	0003      	movs	r3, r0
    319a:	001a      	movs	r2, r3
    319c:	2301      	movs	r3, #1
    319e:	4053      	eors	r3, r2
    31a0:	b2db      	uxtb	r3, r3
    31a2:	2b00      	cmp	r3, #0
    31a4:	d002      	beq.n	31ac <STATE_task+0x98>
		{
			pwm(OFF);
    31a6:	2002      	movs	r0, #2
    31a8:	4ba0      	ldr	r3, [pc, #640]	; (342c <STATE_task+0x318>)
    31aa:	4798      	blx	r3
		}
		if(UART_Buffer[0] == '1')
    31ac:	4ba1      	ldr	r3, [pc, #644]	; (3434 <STATE_task+0x320>)
    31ae:	781b      	ldrb	r3, [r3, #0]
    31b0:	2b31      	cmp	r3, #49	; 0x31
    31b2:	d11f      	bne.n	31f4 <STATE_task+0xe0>
		{
			gpio_set_pin_level(Motor_ON_OFF, 1);
    31b4:	2101      	movs	r1, #1
    31b6:	202f      	movs	r0, #47	; 0x2f
    31b8:	4b9f      	ldr	r3, [pc, #636]	; (3438 <STATE_task+0x324>)
    31ba:	4798      	blx	r3
			os_sleep(1000);
    31bc:	23fa      	movs	r3, #250	; 0xfa
    31be:	009b      	lsls	r3, r3, #2
    31c0:	0018      	movs	r0, r3
    31c2:	4b9e      	ldr	r3, [pc, #632]	; (343c <STATE_task+0x328>)
    31c4:	4798      	blx	r3
			pwm(DOWN);
    31c6:	2001      	movs	r0, #1
    31c8:	4b98      	ldr	r3, [pc, #608]	; (342c <STATE_task+0x318>)
    31ca:	4798      	blx	r3
			os_sleep(18460*2);
    31cc:	4b9c      	ldr	r3, [pc, #624]	; (3440 <STATE_task+0x32c>)
    31ce:	0018      	movs	r0, r3
    31d0:	4b9a      	ldr	r3, [pc, #616]	; (343c <STATE_task+0x328>)
    31d2:	4798      	blx	r3
			pwm(OFF); 
    31d4:	2002      	movs	r0, #2
    31d6:	4b95      	ldr	r3, [pc, #596]	; (342c <STATE_task+0x318>)
    31d8:	4798      	blx	r3
			UART_Send_Buffer[0] = 's';
    31da:	4b91      	ldr	r3, [pc, #580]	; (3420 <STATE_task+0x30c>)
    31dc:	2273      	movs	r2, #115	; 0x73
    31de:	701a      	strb	r2, [r3, #0]
			UART_Send_Buffer[1] = '1';
    31e0:	4b8f      	ldr	r3, [pc, #572]	; (3420 <STATE_task+0x30c>)
    31e2:	2231      	movs	r2, #49	; 0x31
    31e4:	705a      	strb	r2, [r3, #1]
			UART_Send_Buffer[2] = '\0';
    31e6:	4b8e      	ldr	r3, [pc, #568]	; (3420 <STATE_task+0x30c>)
    31e8:	2200      	movs	r2, #0
    31ea:	709a      	strb	r2, [r3, #2]
			send_message(3);
    31ec:	2003      	movs	r0, #3
    31ee:	4b8d      	ldr	r3, [pc, #564]	; (3424 <STATE_task+0x310>)
    31f0:	4798      	blx	r3
    31f2:	e0f7      	b.n	33e4 <STATE_task+0x2d0>
		}
		else if(UART_Buffer[0] == '2')
    31f4:	4b8f      	ldr	r3, [pc, #572]	; (3434 <STATE_task+0x320>)
    31f6:	781b      	ldrb	r3, [r3, #0]
    31f8:	2b32      	cmp	r3, #50	; 0x32
    31fa:	d10f      	bne.n	321c <STATE_task+0x108>
		{
			gpio_toggle_pin_level(Motor_ON_OFF);
    31fc:	202f      	movs	r0, #47	; 0x2f
    31fe:	4b91      	ldr	r3, [pc, #580]	; (3444 <STATE_task+0x330>)
    3200:	4798      	blx	r3
			UART_Send_Buffer[0] = 's';
    3202:	4b87      	ldr	r3, [pc, #540]	; (3420 <STATE_task+0x30c>)
    3204:	2273      	movs	r2, #115	; 0x73
    3206:	701a      	strb	r2, [r3, #0]
			UART_Send_Buffer[1] = '1';
    3208:	4b85      	ldr	r3, [pc, #532]	; (3420 <STATE_task+0x30c>)
    320a:	2231      	movs	r2, #49	; 0x31
    320c:	705a      	strb	r2, [r3, #1]
			UART_Send_Buffer[2] = '\0';
    320e:	4b84      	ldr	r3, [pc, #528]	; (3420 <STATE_task+0x30c>)
    3210:	2200      	movs	r2, #0
    3212:	709a      	strb	r2, [r3, #2]
			send_message(3);
    3214:	2003      	movs	r0, #3
    3216:	4b83      	ldr	r3, [pc, #524]	; (3424 <STATE_task+0x310>)
    3218:	4798      	blx	r3
    321a:	e0e3      	b.n	33e4 <STATE_task+0x2d0>
		}
		else if(UART_Buffer[0] == '3')
    321c:	4b85      	ldr	r3, [pc, #532]	; (3434 <STATE_task+0x320>)
    321e:	781b      	ldrb	r3, [r3, #0]
    3220:	2b33      	cmp	r3, #51	; 0x33
    3222:	d118      	bne.n	3256 <STATE_task+0x142>
		{
			pwm(DOWN);
    3224:	2001      	movs	r0, #1
    3226:	4b81      	ldr	r3, [pc, #516]	; (342c <STATE_task+0x318>)
    3228:	4798      	blx	r3
			os_sleep(12308*total_moves*2);
    322a:	697b      	ldr	r3, [r7, #20]
    322c:	4a86      	ldr	r2, [pc, #536]	; (3448 <STATE_task+0x334>)
    322e:	4353      	muls	r3, r2
    3230:	0018      	movs	r0, r3
    3232:	4b82      	ldr	r3, [pc, #520]	; (343c <STATE_task+0x328>)
    3234:	4798      	blx	r3
			pwm(OFF);
    3236:	2002      	movs	r0, #2
    3238:	4b7c      	ldr	r3, [pc, #496]	; (342c <STATE_task+0x318>)
    323a:	4798      	blx	r3
			UART_Send_Buffer[0] = 's';
    323c:	4b78      	ldr	r3, [pc, #480]	; (3420 <STATE_task+0x30c>)
    323e:	2273      	movs	r2, #115	; 0x73
    3240:	701a      	strb	r2, [r3, #0]
			UART_Send_Buffer[1] = '1';
    3242:	4b77      	ldr	r3, [pc, #476]	; (3420 <STATE_task+0x30c>)
    3244:	2231      	movs	r2, #49	; 0x31
    3246:	705a      	strb	r2, [r3, #1]
			UART_Send_Buffer[2] = '\0';
    3248:	4b75      	ldr	r3, [pc, #468]	; (3420 <STATE_task+0x30c>)
    324a:	2200      	movs	r2, #0
    324c:	709a      	strb	r2, [r3, #2]
			send_message(3);
    324e:	2003      	movs	r0, #3
    3250:	4b74      	ldr	r3, [pc, #464]	; (3424 <STATE_task+0x310>)
    3252:	4798      	blx	r3
    3254:	e0c6      	b.n	33e4 <STATE_task+0x2d0>
		}
		else if(UART_Buffer[0] == '4')
    3256:	4b77      	ldr	r3, [pc, #476]	; (3434 <STATE_task+0x320>)
    3258:	781b      	ldrb	r3, [r3, #0]
    325a:	2b34      	cmp	r3, #52	; 0x34
    325c:	d14e      	bne.n	32fc <STATE_task+0x1e8>
		{
			pwm(DOWN);
    325e:	2001      	movs	r0, #1
    3260:	4b72      	ldr	r3, [pc, #456]	; (342c <STATE_task+0x318>)
    3262:	4798      	blx	r3
			for(int i = 0; i < 246 ; i++)
    3264:	2300      	movs	r3, #0
    3266:	613b      	str	r3, [r7, #16]
    3268:	e01e      	b.n	32a8 <STATE_task+0x194>
			{
				os_sleep(100);
    326a:	2064      	movs	r0, #100	; 0x64
    326c:	4b73      	ldr	r3, [pc, #460]	; (343c <STATE_task+0x328>)
    326e:	4798      	blx	r3
				if(gpio_get_pin_level(down) == 0 ||gpio_get_pin_level(up) == 0 )
    3270:	2015      	movs	r0, #21
    3272:	4b6d      	ldr	r3, [pc, #436]	; (3428 <STATE_task+0x314>)
    3274:	4798      	blx	r3
    3276:	0003      	movs	r3, r0
    3278:	001a      	movs	r2, r3
    327a:	2301      	movs	r3, #1
    327c:	4053      	eors	r3, r2
    327e:	b2db      	uxtb	r3, r3
    3280:	2b00      	cmp	r3, #0
    3282:	d109      	bne.n	3298 <STATE_task+0x184>
    3284:	2014      	movs	r0, #20
    3286:	4b68      	ldr	r3, [pc, #416]	; (3428 <STATE_task+0x314>)
    3288:	4798      	blx	r3
    328a:	0003      	movs	r3, r0
    328c:	001a      	movs	r2, r3
    328e:	2301      	movs	r3, #1
    3290:	4053      	eors	r3, r2
    3292:	b2db      	uxtb	r3, r3
    3294:	2b00      	cmp	r3, #0
    3296:	d004      	beq.n	32a2 <STATE_task+0x18e>
				{
					pwm(OFF);
    3298:	2002      	movs	r0, #2
    329a:	4b64      	ldr	r3, [pc, #400]	; (342c <STATE_task+0x318>)
    329c:	4798      	blx	r3
					i=246;
    329e:	23f6      	movs	r3, #246	; 0xf6
    32a0:	613b      	str	r3, [r7, #16]
			for(int i = 0; i < 246 ; i++)
    32a2:	693b      	ldr	r3, [r7, #16]
    32a4:	3301      	adds	r3, #1
    32a6:	613b      	str	r3, [r7, #16]
    32a8:	693b      	ldr	r3, [r7, #16]
    32aa:	2bf5      	cmp	r3, #245	; 0xf5
    32ac:	dddd      	ble.n	326a <STATE_task+0x156>
				}
			}
			pwm(OFF);
    32ae:	2002      	movs	r0, #2
    32b0:	4b5e      	ldr	r3, [pc, #376]	; (342c <STATE_task+0x318>)
    32b2:	4798      	blx	r3
			if(gpio_get_pin_level(down) == 0)
    32b4:	2015      	movs	r0, #21
    32b6:	4b5c      	ldr	r3, [pc, #368]	; (3428 <STATE_task+0x314>)
    32b8:	4798      	blx	r3
    32ba:	0003      	movs	r3, r0
    32bc:	001a      	movs	r2, r3
    32be:	2301      	movs	r3, #1
    32c0:	4053      	eors	r3, r2
    32c2:	b2db      	uxtb	r3, r3
    32c4:	2b00      	cmp	r3, #0
    32c6:	d009      	beq.n	32dc <STATE_task+0x1c8>
			{
				UART_Send_Buffer[0] = 's';
    32c8:	4b55      	ldr	r3, [pc, #340]	; (3420 <STATE_task+0x30c>)
    32ca:	2273      	movs	r2, #115	; 0x73
    32cc:	701a      	strb	r2, [r3, #0]
				UART_Send_Buffer[1] = '2';
    32ce:	4b54      	ldr	r3, [pc, #336]	; (3420 <STATE_task+0x30c>)
    32d0:	2232      	movs	r2, #50	; 0x32
    32d2:	705a      	strb	r2, [r3, #1]
				UART_Send_Buffer[2] = '\0';
    32d4:	4b52      	ldr	r3, [pc, #328]	; (3420 <STATE_task+0x30c>)
    32d6:	2200      	movs	r2, #0
    32d8:	709a      	strb	r2, [r3, #2]
    32da:	e008      	b.n	32ee <STATE_task+0x1da>
			}
			else
			{	UART_Send_Buffer[0] = 's';
    32dc:	4b50      	ldr	r3, [pc, #320]	; (3420 <STATE_task+0x30c>)
    32de:	2273      	movs	r2, #115	; 0x73
    32e0:	701a      	strb	r2, [r3, #0]
				UART_Send_Buffer[1] = '1';
    32e2:	4b4f      	ldr	r3, [pc, #316]	; (3420 <STATE_task+0x30c>)
    32e4:	2231      	movs	r2, #49	; 0x31
    32e6:	705a      	strb	r2, [r3, #1]
				UART_Send_Buffer[2] = '\0';
    32e8:	4b4d      	ldr	r3, [pc, #308]	; (3420 <STATE_task+0x30c>)
    32ea:	2200      	movs	r2, #0
    32ec:	709a      	strb	r2, [r3, #2]
			}
			send_message(3);
    32ee:	2003      	movs	r0, #3
    32f0:	4b4c      	ldr	r3, [pc, #304]	; (3424 <STATE_task+0x310>)
    32f2:	4798      	blx	r3
			total_moves = total_moves + 1;
    32f4:	697b      	ldr	r3, [r7, #20]
    32f6:	3301      	adds	r3, #1
    32f8:	617b      	str	r3, [r7, #20]
    32fa:	e073      	b.n	33e4 <STATE_task+0x2d0>
		}
		else if(UART_Buffer[0] == '5')
    32fc:	4b4d      	ldr	r3, [pc, #308]	; (3434 <STATE_task+0x320>)
    32fe:	781b      	ldrb	r3, [r3, #0]
    3300:	2b35      	cmp	r3, #53	; 0x35
    3302:	d118      	bne.n	3336 <STATE_task+0x222>
		{
			pwm(UP);
    3304:	2000      	movs	r0, #0
    3306:	4b49      	ldr	r3, [pc, #292]	; (342c <STATE_task+0x318>)
    3308:	4798      	blx	r3
			while(gpio_get_pin_level(up) == 1);
    330a:	46c0      	nop			; (mov r8, r8)
    330c:	2014      	movs	r0, #20
    330e:	4b46      	ldr	r3, [pc, #280]	; (3428 <STATE_task+0x314>)
    3310:	4798      	blx	r3
    3312:	1e03      	subs	r3, r0, #0
    3314:	d1fa      	bne.n	330c <STATE_task+0x1f8>
			pwm(OFF);
    3316:	2002      	movs	r0, #2
    3318:	4b44      	ldr	r3, [pc, #272]	; (342c <STATE_task+0x318>)
    331a:	4798      	blx	r3
			UART_Send_Buffer[0] = 's';
    331c:	4b40      	ldr	r3, [pc, #256]	; (3420 <STATE_task+0x30c>)
    331e:	2273      	movs	r2, #115	; 0x73
    3320:	701a      	strb	r2, [r3, #0]
			UART_Send_Buffer[1] = '1';
    3322:	4b3f      	ldr	r3, [pc, #252]	; (3420 <STATE_task+0x30c>)
    3324:	2231      	movs	r2, #49	; 0x31
    3326:	705a      	strb	r2, [r3, #1]
			UART_Send_Buffer[2] = '\0';
    3328:	4b3d      	ldr	r3, [pc, #244]	; (3420 <STATE_task+0x30c>)
    332a:	2200      	movs	r2, #0
    332c:	709a      	strb	r2, [r3, #2]
			send_message(3);
    332e:	2003      	movs	r0, #3
    3330:	4b3c      	ldr	r3, [pc, #240]	; (3424 <STATE_task+0x310>)
    3332:	4798      	blx	r3
    3334:	e056      	b.n	33e4 <STATE_task+0x2d0>
		}
		else if(UART_Buffer[0] == '6')
    3336:	4b3f      	ldr	r3, [pc, #252]	; (3434 <STATE_task+0x320>)
    3338:	781b      	ldrb	r3, [r3, #0]
    333a:	2b36      	cmp	r3, #54	; 0x36
    333c:	d125      	bne.n	338a <STATE_task+0x276>
		{
			int m_break = 0;
    333e:	2300      	movs	r3, #0
    3340:	60fb      	str	r3, [r7, #12]
			pwm(UP);
    3342:	2000      	movs	r0, #0
    3344:	4b39      	ldr	r3, [pc, #228]	; (342c <STATE_task+0x318>)
    3346:	4798      	blx	r3
			UART_Send_Buffer[0] = 's';
    3348:	4b35      	ldr	r3, [pc, #212]	; (3420 <STATE_task+0x30c>)
    334a:	2273      	movs	r2, #115	; 0x73
    334c:	701a      	strb	r2, [r3, #0]
			UART_Send_Buffer[1] = '1';
    334e:	4b34      	ldr	r3, [pc, #208]	; (3420 <STATE_task+0x30c>)
    3350:	2231      	movs	r2, #49	; 0x31
    3352:	705a      	strb	r2, [r3, #1]
			UART_Send_Buffer[2] = '\0';
    3354:	4b32      	ldr	r3, [pc, #200]	; (3420 <STATE_task+0x30c>)
    3356:	2200      	movs	r2, #0
    3358:	709a      	strb	r2, [r3, #2]
			send_message(3);
    335a:	2003      	movs	r0, #3
    335c:	4b31      	ldr	r3, [pc, #196]	; (3424 <STATE_task+0x310>)
    335e:	4798      	blx	r3
			while(gpio_get_pin_level(up) == 1 && m_break == 0)
    3360:	e007      	b.n	3372 <STATE_task+0x25e>
			{
				wait_for_responce();
    3362:	4b33      	ldr	r3, [pc, #204]	; (3430 <STATE_task+0x31c>)
    3364:	4798      	blx	r3
				if(UART_Buffer[0] == '0')
    3366:	4b33      	ldr	r3, [pc, #204]	; (3434 <STATE_task+0x320>)
    3368:	781b      	ldrb	r3, [r3, #0]
    336a:	2b30      	cmp	r3, #48	; 0x30
    336c:	d101      	bne.n	3372 <STATE_task+0x25e>
				{
					m_break = 1;
    336e:	2301      	movs	r3, #1
    3370:	60fb      	str	r3, [r7, #12]
			while(gpio_get_pin_level(up) == 1 && m_break == 0)
    3372:	2014      	movs	r0, #20
    3374:	4b2c      	ldr	r3, [pc, #176]	; (3428 <STATE_task+0x314>)
    3376:	4798      	blx	r3
    3378:	1e03      	subs	r3, r0, #0
    337a:	d002      	beq.n	3382 <STATE_task+0x26e>
    337c:	68fb      	ldr	r3, [r7, #12]
    337e:	2b00      	cmp	r3, #0
    3380:	d0ef      	beq.n	3362 <STATE_task+0x24e>
				}
			}
			pwm(OFF);
    3382:	2002      	movs	r0, #2
    3384:	4b29      	ldr	r3, [pc, #164]	; (342c <STATE_task+0x318>)
    3386:	4798      	blx	r3
    3388:	e02c      	b.n	33e4 <STATE_task+0x2d0>
		}
		else if(UART_Buffer[0] == '7')
    338a:	4b2a      	ldr	r3, [pc, #168]	; (3434 <STATE_task+0x320>)
    338c:	781b      	ldrb	r3, [r3, #0]
    338e:	2b37      	cmp	r3, #55	; 0x37
    3390:	d125      	bne.n	33de <STATE_task+0x2ca>
		{
			int m_break = 0;
    3392:	2300      	movs	r3, #0
    3394:	60bb      	str	r3, [r7, #8]
			pwm(DOWN);
    3396:	2001      	movs	r0, #1
    3398:	4b24      	ldr	r3, [pc, #144]	; (342c <STATE_task+0x318>)
    339a:	4798      	blx	r3
			UART_Send_Buffer[0] = 's';
    339c:	4b20      	ldr	r3, [pc, #128]	; (3420 <STATE_task+0x30c>)
    339e:	2273      	movs	r2, #115	; 0x73
    33a0:	701a      	strb	r2, [r3, #0]
			UART_Send_Buffer[1] = '1';
    33a2:	4b1f      	ldr	r3, [pc, #124]	; (3420 <STATE_task+0x30c>)
    33a4:	2231      	movs	r2, #49	; 0x31
    33a6:	705a      	strb	r2, [r3, #1]
			UART_Send_Buffer[2] = '\0';
    33a8:	4b1d      	ldr	r3, [pc, #116]	; (3420 <STATE_task+0x30c>)
    33aa:	2200      	movs	r2, #0
    33ac:	709a      	strb	r2, [r3, #2]
			send_message(3);
    33ae:	2003      	movs	r0, #3
    33b0:	4b1c      	ldr	r3, [pc, #112]	; (3424 <STATE_task+0x310>)
    33b2:	4798      	blx	r3
			while(gpio_get_pin_level(down) == 1 && m_break == 0)
    33b4:	e007      	b.n	33c6 <STATE_task+0x2b2>
			{
				wait_for_responce();
    33b6:	4b1e      	ldr	r3, [pc, #120]	; (3430 <STATE_task+0x31c>)
    33b8:	4798      	blx	r3
				if(UART_Buffer[0] == '0')
    33ba:	4b1e      	ldr	r3, [pc, #120]	; (3434 <STATE_task+0x320>)
    33bc:	781b      	ldrb	r3, [r3, #0]
    33be:	2b30      	cmp	r3, #48	; 0x30
    33c0:	d101      	bne.n	33c6 <STATE_task+0x2b2>
				{
					m_break = 1;
    33c2:	2301      	movs	r3, #1
    33c4:	60bb      	str	r3, [r7, #8]
			while(gpio_get_pin_level(down) == 1 && m_break == 0)
    33c6:	2015      	movs	r0, #21
    33c8:	4b17      	ldr	r3, [pc, #92]	; (3428 <STATE_task+0x314>)
    33ca:	4798      	blx	r3
    33cc:	1e03      	subs	r3, r0, #0
    33ce:	d002      	beq.n	33d6 <STATE_task+0x2c2>
    33d0:	68bb      	ldr	r3, [r7, #8]
    33d2:	2b00      	cmp	r3, #0
    33d4:	d0ef      	beq.n	33b6 <STATE_task+0x2a2>
				}
			}
			pwm(OFF);
    33d6:	2002      	movs	r0, #2
    33d8:	4b14      	ldr	r3, [pc, #80]	; (342c <STATE_task+0x318>)
    33da:	4798      	blx	r3
    33dc:	e002      	b.n	33e4 <STATE_task+0x2d0>
		}
		else
		{
			pwm(OFF);
    33de:	2002      	movs	r0, #2
    33e0:	4b12      	ldr	r3, [pc, #72]	; (342c <STATE_task+0x318>)
    33e2:	4798      	blx	r3
		}
		if(read_battery() == 1)
    33e4:	4b19      	ldr	r3, [pc, #100]	; (344c <STATE_task+0x338>)
    33e6:	4798      	blx	r3
    33e8:	0003      	movs	r3, r0
    33ea:	2b01      	cmp	r3, #1
    33ec:	d10b      	bne.n	3406 <STATE_task+0x2f2>
		{
			UART_Send_Buffer[0] = 's';
    33ee:	4b0c      	ldr	r3, [pc, #48]	; (3420 <STATE_task+0x30c>)
    33f0:	2273      	movs	r2, #115	; 0x73
    33f2:	701a      	strb	r2, [r3, #0]
			UART_Send_Buffer[1] = '3';
    33f4:	4b0a      	ldr	r3, [pc, #40]	; (3420 <STATE_task+0x30c>)
    33f6:	2233      	movs	r2, #51	; 0x33
    33f8:	705a      	strb	r2, [r3, #1]
			UART_Send_Buffer[2] = '\0';
    33fa:	4b09      	ldr	r3, [pc, #36]	; (3420 <STATE_task+0x30c>)
    33fc:	2200      	movs	r2, #0
    33fe:	709a      	strb	r2, [r3, #2]
			send_message(3);
    3400:	2003      	movs	r0, #3
    3402:	4b08      	ldr	r3, [pc, #32]	; (3424 <STATE_task+0x310>)
    3404:	4798      	blx	r3
		}
		os_sleep(100);
    3406:	2064      	movs	r0, #100	; 0x64
    3408:	4b0c      	ldr	r3, [pc, #48]	; (343c <STATE_task+0x328>)
    340a:	4798      	blx	r3
		if(gpio_get_pin_level(down) == 0 ||gpio_get_pin_level(up) == 0 )
    340c:	e69e      	b.n	314c <STATE_task+0x38>
    340e:	46c0      	nop			; (mov r8, r8)
    3410:	2000276c 	.word	0x2000276c
    3414:	20002740 	.word	0x20002740
    3418:	0000113d 	.word	0x0000113d
    341c:	00001101 	.word	0x00001101
    3420:	200027d4 	.word	0x200027d4
    3424:	00003499 	.word	0x00003499
    3428:	000030d5 	.word	0x000030d5
    342c:	000036bd 	.word	0x000036bd
    3430:	00003559 	.word	0x00003559
    3434:	20002770 	.word	0x20002770
    3438:	00003061 	.word	0x00003061
    343c:	000048d9 	.word	0x000048d9
    3440:	00009038 	.word	0x00009038
    3444:	000030a1 	.word	0x000030a1
    3448:	00006028 	.word	0x00006028
    344c:	00003779 	.word	0x00003779

00003450 <Create_all_tasks>:
	
	
}

void Create_all_tasks()
{
    3450:	b590      	push	{r4, r7, lr}
    3452:	b083      	sub	sp, #12
    3454:	af02      	add	r7, sp, #8
		
		if (xTaskCreate(
		STATE_task, "STATE", TASK_STACK_SIZE*20, NULL, TASK_STACK_PRIORITY, xCreatedTask[3])
    3456:	4b0b      	ldr	r3, [pc, #44]	; (3484 <Create_all_tasks+0x34>)
    3458:	68db      	ldr	r3, [r3, #12]
		if (xTaskCreate(
    345a:	22a0      	movs	r2, #160	; 0xa0
    345c:	0092      	lsls	r2, r2, #2
    345e:	490a      	ldr	r1, [pc, #40]	; (3488 <Create_all_tasks+0x38>)
    3460:	480a      	ldr	r0, [pc, #40]	; (348c <Create_all_tasks+0x3c>)
    3462:	9301      	str	r3, [sp, #4]
    3464:	2301      	movs	r3, #1
    3466:	9300      	str	r3, [sp, #0]
    3468:	2300      	movs	r3, #0
    346a:	4c09      	ldr	r4, [pc, #36]	; (3490 <Create_all_tasks+0x40>)
    346c:	47a0      	blx	r4
    346e:	0003      	movs	r3, r0
    3470:	2b01      	cmp	r3, #1
    3472:	d000      	beq.n	3476 <Create_all_tasks+0x26>
		!= pdPASS) {
			while (1) {
    3474:	e7fe      	b.n	3474 <Create_all_tasks+0x24>
				;
			}
		}

		vTaskStartScheduler();
    3476:	4b07      	ldr	r3, [pc, #28]	; (3494 <Create_all_tasks+0x44>)
    3478:	4798      	blx	r3

		return;
    347a:	46c0      	nop			; (mov r8, r8)
}
    347c:	46bd      	mov	sp, r7
    347e:	b001      	add	sp, #4
    3480:	bd90      	pop	{r4, r7, pc}
    3482:	46c0      	nop			; (mov r8, r8)
    3484:	2000004c 	.word	0x2000004c
    3488:	00005ed4 	.word	0x00005ed4
    348c:	00003115 	.word	0x00003115
    3490:	00004651 	.word	0x00004651
    3494:	00004935 	.word	0x00004935

00003498 <send_message>:

void send_message(int length)
{
    3498:	b580      	push	{r7, lr}
    349a:	b082      	sub	sp, #8
    349c:	af00      	add	r7, sp, #0
    349e:	6078      	str	r0, [r7, #4]
	io_write(io, (uint8_t *)&UART_Send_Buffer, length);
    34a0:	4b21      	ldr	r3, [pc, #132]	; (3528 <send_message+0x90>)
    34a2:	681b      	ldr	r3, [r3, #0]
    34a4:	687a      	ldr	r2, [r7, #4]
    34a6:	b292      	uxth	r2, r2
    34a8:	4920      	ldr	r1, [pc, #128]	; (352c <send_message+0x94>)
    34aa:	0018      	movs	r0, r3
    34ac:	4b20      	ldr	r3, [pc, #128]	; (3530 <send_message+0x98>)
    34ae:	4798      	blx	r3
	os_sleep(100);
    34b0:	2064      	movs	r0, #100	; 0x64
    34b2:	4b20      	ldr	r3, [pc, #128]	; (3534 <send_message+0x9c>)
    34b4:	4798      	blx	r3
	
	do 
	{
		
		if(gpio_get_pin_level(down) == 0 ||gpio_get_pin_level(up) == 0 )
    34b6:	2015      	movs	r0, #21
    34b8:	4b1f      	ldr	r3, [pc, #124]	; (3538 <send_message+0xa0>)
    34ba:	4798      	blx	r3
    34bc:	0003      	movs	r3, r0
    34be:	001a      	movs	r2, r3
    34c0:	2301      	movs	r3, #1
    34c2:	4053      	eors	r3, r2
    34c4:	b2db      	uxtb	r3, r3
    34c6:	2b00      	cmp	r3, #0
    34c8:	d109      	bne.n	34de <send_message+0x46>
    34ca:	2014      	movs	r0, #20
    34cc:	4b1a      	ldr	r3, [pc, #104]	; (3538 <send_message+0xa0>)
    34ce:	4798      	blx	r3
    34d0:	0003      	movs	r3, r0
    34d2:	001a      	movs	r2, r3
    34d4:	2301      	movs	r3, #1
    34d6:	4053      	eors	r3, r2
    34d8:	b2db      	uxtb	r3, r3
    34da:	2b00      	cmp	r3, #0
    34dc:	d002      	beq.n	34e4 <send_message+0x4c>
		{
			pwm(OFF);
    34de:	2002      	movs	r0, #2
    34e0:	4b16      	ldr	r3, [pc, #88]	; (353c <send_message+0xa4>)
    34e2:	4798      	blx	r3
		}
		if(usart_sync_is_rx_not_empty(&UART) !=0)
    34e4:	4b16      	ldr	r3, [pc, #88]	; (3540 <send_message+0xa8>)
    34e6:	0018      	movs	r0, r3
    34e8:	4b16      	ldr	r3, [pc, #88]	; (3544 <send_message+0xac>)
    34ea:	4798      	blx	r3
    34ec:	1e03      	subs	r3, r0, #0
    34ee:	d009      	beq.n	3504 <send_message+0x6c>
		{
			UART_Length = io_read(io, (uint8_t *)&UART_Buffer, 1);
    34f0:	4b0d      	ldr	r3, [pc, #52]	; (3528 <send_message+0x90>)
    34f2:	681b      	ldr	r3, [r3, #0]
    34f4:	4914      	ldr	r1, [pc, #80]	; (3548 <send_message+0xb0>)
    34f6:	2201      	movs	r2, #1
    34f8:	0018      	movs	r0, r3
    34fa:	4b14      	ldr	r3, [pc, #80]	; (354c <send_message+0xb4>)
    34fc:	4798      	blx	r3
    34fe:	0002      	movs	r2, r0
    3500:	4b13      	ldr	r3, [pc, #76]	; (3550 <send_message+0xb8>)
    3502:	601a      	str	r2, [r3, #0]
		}
		os_sleep(100);
    3504:	2064      	movs	r0, #100	; 0x64
    3506:	4b0b      	ldr	r3, [pc, #44]	; (3534 <send_message+0x9c>)
    3508:	4798      	blx	r3
	} while (UART_Buffer[0] != 's');
    350a:	4b0f      	ldr	r3, [pc, #60]	; (3548 <send_message+0xb0>)
    350c:	781b      	ldrb	r3, [r3, #0]
    350e:	2b73      	cmp	r3, #115	; 0x73
    3510:	d1d1      	bne.n	34b6 <send_message+0x1e>
	reset_buffer(UART_Buffer, UART_Length);
    3512:	4b0f      	ldr	r3, [pc, #60]	; (3550 <send_message+0xb8>)
    3514:	681a      	ldr	r2, [r3, #0]
    3516:	4b0c      	ldr	r3, [pc, #48]	; (3548 <send_message+0xb0>)
    3518:	0011      	movs	r1, r2
    351a:	0018      	movs	r0, r3
    351c:	4b0d      	ldr	r3, [pc, #52]	; (3554 <send_message+0xbc>)
    351e:	4798      	blx	r3
}
    3520:	46c0      	nop			; (mov r8, r8)
    3522:	46bd      	mov	sp, r7
    3524:	b002      	add	sp, #8
    3526:	bd80      	pop	{r7, pc}
    3528:	2000276c 	.word	0x2000276c
    352c:	200027d4 	.word	0x200027d4
    3530:	00000e45 	.word	0x00000e45
    3534:	000048d9 	.word	0x000048d9
    3538:	000030d5 	.word	0x000030d5
    353c:	000036bd 	.word	0x000036bd
    3540:	20002740 	.word	0x20002740
    3544:	00001185 	.word	0x00001185
    3548:	20002770 	.word	0x20002770
    354c:	00000e99 	.word	0x00000e99
    3550:	20000074 	.word	0x20000074
    3554:	00003749 	.word	0x00003749

00003558 <wait_for_responce>:
void wait_for_responce()
{
    3558:	b580      	push	{r7, lr}
    355a:	b084      	sub	sp, #16
    355c:	af00      	add	r7, sp, #0
	UART_Length = 0;
    355e:	4b4a      	ldr	r3, [pc, #296]	; (3688 <wait_for_responce+0x130>)
    3560:	2200      	movs	r2, #0
    3562:	601a      	str	r2, [r3, #0]
	int offset = 0;
    3564:	2300      	movs	r3, #0
    3566:	60fb      	str	r3, [r7, #12]
	UART_Buffer[0] = '0';
    3568:	4b48      	ldr	r3, [pc, #288]	; (368c <wait_for_responce+0x134>)
    356a:	2230      	movs	r2, #48	; 0x30
    356c:	701a      	strb	r2, [r3, #0]
	//while(UART_Buffer[0] == '0' || UART_Buffer[0] == '\0')
	//{
		uint8_t temp[2] = "r\0";
    356e:	1d3b      	adds	r3, r7, #4
    3570:	4a47      	ldr	r2, [pc, #284]	; (3690 <wait_for_responce+0x138>)
    3572:	8812      	ldrh	r2, [r2, #0]
    3574:	801a      	strh	r2, [r3, #0]
		io_write(io, (uint8_t *)&temp, 2);
    3576:	4b47      	ldr	r3, [pc, #284]	; (3694 <wait_for_responce+0x13c>)
    3578:	681b      	ldr	r3, [r3, #0]
    357a:	1d39      	adds	r1, r7, #4
    357c:	2202      	movs	r2, #2
    357e:	0018      	movs	r0, r3
    3580:	4b45      	ldr	r3, [pc, #276]	; (3698 <wait_for_responce+0x140>)
    3582:	4798      	blx	r3
		while(usart_sync_is_rx_not_empty(&UART) ==0)
    3584:	e016      	b.n	35b4 <wait_for_responce+0x5c>
		{
			if(gpio_get_pin_level(down) == 0 ||gpio_get_pin_level(up) == 0 )
    3586:	2015      	movs	r0, #21
    3588:	4b44      	ldr	r3, [pc, #272]	; (369c <wait_for_responce+0x144>)
    358a:	4798      	blx	r3
    358c:	0003      	movs	r3, r0
    358e:	001a      	movs	r2, r3
    3590:	2301      	movs	r3, #1
    3592:	4053      	eors	r3, r2
    3594:	b2db      	uxtb	r3, r3
    3596:	2b00      	cmp	r3, #0
    3598:	d109      	bne.n	35ae <wait_for_responce+0x56>
    359a:	2014      	movs	r0, #20
    359c:	4b3f      	ldr	r3, [pc, #252]	; (369c <wait_for_responce+0x144>)
    359e:	4798      	blx	r3
    35a0:	0003      	movs	r3, r0
    35a2:	001a      	movs	r2, r3
    35a4:	2301      	movs	r3, #1
    35a6:	4053      	eors	r3, r2
    35a8:	b2db      	uxtb	r3, r3
    35aa:	2b00      	cmp	r3, #0
    35ac:	d002      	beq.n	35b4 <wait_for_responce+0x5c>
			{
				pwm(OFF);			
    35ae:	2002      	movs	r0, #2
    35b0:	4b3b      	ldr	r3, [pc, #236]	; (36a0 <wait_for_responce+0x148>)
    35b2:	4798      	blx	r3
		while(usart_sync_is_rx_not_empty(&UART) ==0)
    35b4:	4b3b      	ldr	r3, [pc, #236]	; (36a4 <wait_for_responce+0x14c>)
    35b6:	0018      	movs	r0, r3
    35b8:	4b3b      	ldr	r3, [pc, #236]	; (36a8 <wait_for_responce+0x150>)
    35ba:	4798      	blx	r3
    35bc:	1e03      	subs	r3, r0, #0
    35be:	d0e2      	beq.n	3586 <wait_for_responce+0x2e>
			}
		} //ERROR Potential breaking loop if the command is not received by the website module
		for(int i = 0; i < 1000; i++)
    35c0:	2300      	movs	r3, #0
    35c2:	60bb      	str	r3, [r7, #8]
    35c4:	e04a      	b.n	365c <wait_for_responce+0x104>
		{
			if(usart_sync_is_rx_not_empty(&UART) !=0)
    35c6:	4b37      	ldr	r3, [pc, #220]	; (36a4 <wait_for_responce+0x14c>)
    35c8:	0018      	movs	r0, r3
    35ca:	4b37      	ldr	r3, [pc, #220]	; (36a8 <wait_for_responce+0x150>)
    35cc:	4798      	blx	r3
    35ce:	1e03      	subs	r3, r0, #0
    35d0:	d027      	beq.n	3622 <wait_for_responce+0xca>
			{
				UART_Length = io_read(io, (uint8_t *)&UART_Buffer + offset, 1);
    35d2:	4b30      	ldr	r3, [pc, #192]	; (3694 <wait_for_responce+0x13c>)
    35d4:	6818      	ldr	r0, [r3, #0]
    35d6:	68fa      	ldr	r2, [r7, #12]
    35d8:	4b2c      	ldr	r3, [pc, #176]	; (368c <wait_for_responce+0x134>)
    35da:	18d3      	adds	r3, r2, r3
    35dc:	2201      	movs	r2, #1
    35de:	0019      	movs	r1, r3
    35e0:	4b32      	ldr	r3, [pc, #200]	; (36ac <wait_for_responce+0x154>)
    35e2:	4798      	blx	r3
    35e4:	0002      	movs	r2, r0
    35e6:	4b28      	ldr	r3, [pc, #160]	; (3688 <wait_for_responce+0x130>)
    35e8:	601a      	str	r2, [r3, #0]
				offset++;
    35ea:	68fb      	ldr	r3, [r7, #12]
    35ec:	3301      	adds	r3, #1
    35ee:	60fb      	str	r3, [r7, #12]
				i = 0;
    35f0:	2300      	movs	r3, #0
    35f2:	60bb      	str	r3, [r7, #8]
				if(gpio_get_pin_level(down) == 0 ||gpio_get_pin_level(up) == 0 )
    35f4:	2015      	movs	r0, #21
    35f6:	4b29      	ldr	r3, [pc, #164]	; (369c <wait_for_responce+0x144>)
    35f8:	4798      	blx	r3
    35fa:	0003      	movs	r3, r0
    35fc:	001a      	movs	r2, r3
    35fe:	2301      	movs	r3, #1
    3600:	4053      	eors	r3, r2
    3602:	b2db      	uxtb	r3, r3
    3604:	2b00      	cmp	r3, #0
    3606:	d109      	bne.n	361c <wait_for_responce+0xc4>
    3608:	2014      	movs	r0, #20
    360a:	4b24      	ldr	r3, [pc, #144]	; (369c <wait_for_responce+0x144>)
    360c:	4798      	blx	r3
    360e:	0003      	movs	r3, r0
    3610:	001a      	movs	r2, r3
    3612:	2301      	movs	r3, #1
    3614:	4053      	eors	r3, r2
    3616:	b2db      	uxtb	r3, r3
    3618:	2b00      	cmp	r3, #0
    361a:	d002      	beq.n	3622 <wait_for_responce+0xca>
				{
					pwm(OFF);			
    361c:	2002      	movs	r0, #2
    361e:	4b20      	ldr	r3, [pc, #128]	; (36a0 <wait_for_responce+0x148>)
    3620:	4798      	blx	r3
				}
			}
			os_sleep(1);	
    3622:	2001      	movs	r0, #1
    3624:	4b22      	ldr	r3, [pc, #136]	; (36b0 <wait_for_responce+0x158>)
    3626:	4798      	blx	r3
			if(gpio_get_pin_level(down) == 0 ||gpio_get_pin_level(up) == 0 )
    3628:	2015      	movs	r0, #21
    362a:	4b1c      	ldr	r3, [pc, #112]	; (369c <wait_for_responce+0x144>)
    362c:	4798      	blx	r3
    362e:	0003      	movs	r3, r0
    3630:	001a      	movs	r2, r3
    3632:	2301      	movs	r3, #1
    3634:	4053      	eors	r3, r2
    3636:	b2db      	uxtb	r3, r3
    3638:	2b00      	cmp	r3, #0
    363a:	d109      	bne.n	3650 <wait_for_responce+0xf8>
    363c:	2014      	movs	r0, #20
    363e:	4b17      	ldr	r3, [pc, #92]	; (369c <wait_for_responce+0x144>)
    3640:	4798      	blx	r3
    3642:	0003      	movs	r3, r0
    3644:	001a      	movs	r2, r3
    3646:	2301      	movs	r3, #1
    3648:	4053      	eors	r3, r2
    364a:	b2db      	uxtb	r3, r3
    364c:	2b00      	cmp	r3, #0
    364e:	d002      	beq.n	3656 <wait_for_responce+0xfe>
			{
				pwm(OFF);			
    3650:	2002      	movs	r0, #2
    3652:	4b13      	ldr	r3, [pc, #76]	; (36a0 <wait_for_responce+0x148>)
    3654:	4798      	blx	r3
		for(int i = 0; i < 1000; i++)
    3656:	68bb      	ldr	r3, [r7, #8]
    3658:	3301      	adds	r3, #1
    365a:	60bb      	str	r3, [r7, #8]
    365c:	68bb      	ldr	r3, [r7, #8]
    365e:	4a15      	ldr	r2, [pc, #84]	; (36b4 <wait_for_responce+0x15c>)
    3660:	4293      	cmp	r3, r2
    3662:	ddb0      	ble.n	35c6 <wait_for_responce+0x6e>
			}		
		}
		offset = 0;
    3664:	2300      	movs	r3, #0
    3666:	60fb      	str	r3, [r7, #12]
		if(UART_Buffer[0] == '0')
    3668:	4b08      	ldr	r3, [pc, #32]	; (368c <wait_for_responce+0x134>)
    366a:	781b      	ldrb	r3, [r3, #0]
    366c:	2b30      	cmp	r3, #48	; 0x30
    366e:	d106      	bne.n	367e <wait_for_responce+0x126>
			reset_buffer(&UART_Buffer, UART_Length);
    3670:	4b05      	ldr	r3, [pc, #20]	; (3688 <wait_for_responce+0x130>)
    3672:	681a      	ldr	r2, [r3, #0]
    3674:	4b05      	ldr	r3, [pc, #20]	; (368c <wait_for_responce+0x134>)
    3676:	0011      	movs	r1, r2
    3678:	0018      	movs	r0, r3
    367a:	4b0f      	ldr	r3, [pc, #60]	; (36b8 <wait_for_responce+0x160>)
    367c:	4798      	blx	r3
	//}
}
    367e:	46c0      	nop			; (mov r8, r8)
    3680:	46bd      	mov	sp, r7
    3682:	b004      	add	sp, #16
    3684:	bd80      	pop	{r7, pc}
    3686:	46c0      	nop			; (mov r8, r8)
    3688:	20000074 	.word	0x20000074
    368c:	20002770 	.word	0x20002770
    3690:	00005edc 	.word	0x00005edc
    3694:	2000276c 	.word	0x2000276c
    3698:	00000e45 	.word	0x00000e45
    369c:	000030d5 	.word	0x000030d5
    36a0:	000036bd 	.word	0x000036bd
    36a4:	20002740 	.word	0x20002740
    36a8:	00001185 	.word	0x00001185
    36ac:	00000e99 	.word	0x00000e99
    36b0:	000048d9 	.word	0x000048d9
    36b4:	000003e7 	.word	0x000003e7
    36b8:	00003749 	.word	0x00003749

000036bc <pwm>:
void pwm(int dir)
{
    36bc:	b580      	push	{r7, lr}
    36be:	b082      	sub	sp, #8
    36c0:	af00      	add	r7, sp, #0
    36c2:	6078      	str	r0, [r7, #4]
	if(dir == 2)
    36c4:	687b      	ldr	r3, [r7, #4]
    36c6:	2b02      	cmp	r3, #2
    36c8:	d104      	bne.n	36d4 <pwm+0x18>
	{
		pwm_disable(&StepperDriver);
    36ca:	4b0c      	ldr	r3, [pc, #48]	; (36fc <pwm+0x40>)
    36cc:	0018      	movs	r0, r3
    36ce:	4b0c      	ldr	r3, [pc, #48]	; (3700 <pwm+0x44>)
    36d0:	4798      	blx	r3
		return;
    36d2:	e010      	b.n	36f6 <pwm+0x3a>
	}
		pwm_disable(&StepperDriver);
    36d4:	4b09      	ldr	r3, [pc, #36]	; (36fc <pwm+0x40>)
    36d6:	0018      	movs	r0, r3
    36d8:	4b09      	ldr	r3, [pc, #36]	; (3700 <pwm+0x44>)
    36da:	4798      	blx	r3
		os_sleep(100);
    36dc:	2064      	movs	r0, #100	; 0x64
    36de:	4b09      	ldr	r3, [pc, #36]	; (3704 <pwm+0x48>)
    36e0:	4798      	blx	r3
		gpio_set_pin_level(Direction, dir);
    36e2:	687b      	ldr	r3, [r7, #4]
    36e4:	1e5a      	subs	r2, r3, #1
    36e6:	4193      	sbcs	r3, r2
    36e8:	b2db      	uxtb	r3, r3
    36ea:	0019      	movs	r1, r3
    36ec:	202e      	movs	r0, #46	; 0x2e
    36ee:	4b06      	ldr	r3, [pc, #24]	; (3708 <pwm+0x4c>)
    36f0:	4798      	blx	r3
		pwm_ramp();
    36f2:	4b06      	ldr	r3, [pc, #24]	; (370c <pwm+0x50>)
    36f4:	4798      	blx	r3
}
    36f6:	46bd      	mov	sp, r7
    36f8:	b002      	add	sp, #8
    36fa:	bd80      	pop	{r7, pc}
    36fc:	20002750 	.word	0x20002750
    3700:	00000fa5 	.word	0x00000fa5
    3704:	000048d9 	.word	0x000048d9
    3708:	00003061 	.word	0x00003061
    370c:	00003711 	.word	0x00003711

00003710 <pwm_ramp>:
{
	return gpio_get_pin_level(btn);
	
}
void pwm_ramp()
{
    3710:	b580      	push	{r7, lr}
    3712:	af00      	add	r7, sp, #0
	
		pwm_set_parameters(&StepperDriver, 1600, 800);	
    3714:	23c8      	movs	r3, #200	; 0xc8
    3716:	009a      	lsls	r2, r3, #2
    3718:	23c8      	movs	r3, #200	; 0xc8
    371a:	00d9      	lsls	r1, r3, #3
    371c:	4b06      	ldr	r3, [pc, #24]	; (3738 <pwm_ramp+0x28>)
    371e:	0018      	movs	r0, r3
    3720:	4b06      	ldr	r3, [pc, #24]	; (373c <pwm_ramp+0x2c>)
    3722:	4798      	blx	r3
		pwm_enable(&StepperDriver);
    3724:	4b04      	ldr	r3, [pc, #16]	; (3738 <pwm_ramp+0x28>)
    3726:	0018      	movs	r0, r3
    3728:	4b05      	ldr	r3, [pc, #20]	; (3740 <pwm_ramp+0x30>)
    372a:	4798      	blx	r3
		os_sleep(10);
    372c:	200a      	movs	r0, #10
    372e:	4b05      	ldr	r3, [pc, #20]	; (3744 <pwm_ramp+0x34>)
    3730:	4798      	blx	r3
		
}
    3732:	46c0      	nop			; (mov r8, r8)
    3734:	46bd      	mov	sp, r7
    3736:	bd80      	pop	{r7, pc}
    3738:	20002750 	.word	0x20002750
    373c:	00000ffd 	.word	0x00000ffd
    3740:	00000f55 	.word	0x00000f55
    3744:	000048d9 	.word	0x000048d9

00003748 <reset_buffer>:

void reset_buffer(uint8_t *buffer, int length)
{
    3748:	b580      	push	{r7, lr}
    374a:	b084      	sub	sp, #16
    374c:	af00      	add	r7, sp, #0
    374e:	6078      	str	r0, [r7, #4]
    3750:	6039      	str	r1, [r7, #0]
	for(int i = 0; i < length; i++)
    3752:	2300      	movs	r3, #0
    3754:	60fb      	str	r3, [r7, #12]
    3756:	e007      	b.n	3768 <reset_buffer+0x20>
	{
		buffer[i] = '\0';
    3758:	68fb      	ldr	r3, [r7, #12]
    375a:	687a      	ldr	r2, [r7, #4]
    375c:	18d3      	adds	r3, r2, r3
    375e:	2200      	movs	r2, #0
    3760:	701a      	strb	r2, [r3, #0]
	for(int i = 0; i < length; i++)
    3762:	68fb      	ldr	r3, [r7, #12]
    3764:	3301      	adds	r3, #1
    3766:	60fb      	str	r3, [r7, #12]
    3768:	68fa      	ldr	r2, [r7, #12]
    376a:	683b      	ldr	r3, [r7, #0]
    376c:	429a      	cmp	r2, r3
    376e:	dbf3      	blt.n	3758 <reset_buffer+0x10>
	}
}
    3770:	46c0      	nop			; (mov r8, r8)
    3772:	46bd      	mov	sp, r7
    3774:	b004      	add	sp, #16
    3776:	bd80      	pop	{r7, pc}

00003778 <read_battery>:
int read_battery()
{
    3778:	b590      	push	{r4, r7, lr}
    377a:	b085      	sub	sp, #20
    377c:	af00      	add	r7, sp, #0
	uint8_t battery[2];
	
	adc_sync_enable_channel(&Battery_lvl, 0);
    377e:	4b29      	ldr	r3, [pc, #164]	; (3824 <read_battery+0xac>)
    3780:	2100      	movs	r1, #0
    3782:	0018      	movs	r0, r3
    3784:	4b28      	ldr	r3, [pc, #160]	; (3828 <read_battery+0xb0>)
    3786:	4798      	blx	r3
	adc_sync_read_channel(&Battery_lvl, 0, battery, 2);
    3788:	1d3a      	adds	r2, r7, #4
    378a:	4826      	ldr	r0, [pc, #152]	; (3824 <read_battery+0xac>)
    378c:	2302      	movs	r3, #2
    378e:	2100      	movs	r1, #0
    3790:	4c26      	ldr	r4, [pc, #152]	; (382c <read_battery+0xb4>)
    3792:	47a0      	blx	r4
	double battery_lvl = ((uint16_t)battery[1] << 8) | battery[0];
    3794:	1d3b      	adds	r3, r7, #4
    3796:	785b      	ldrb	r3, [r3, #1]
    3798:	021b      	lsls	r3, r3, #8
    379a:	1d3a      	adds	r2, r7, #4
    379c:	7812      	ldrb	r2, [r2, #0]
    379e:	431a      	orrs	r2, r3
    37a0:	4b23      	ldr	r3, [pc, #140]	; (3830 <read_battery+0xb8>)
    37a2:	0010      	movs	r0, r2
    37a4:	4798      	blx	r3
    37a6:	0003      	movs	r3, r0
    37a8:	000c      	movs	r4, r1
    37aa:	60bb      	str	r3, [r7, #8]
    37ac:	60fc      	str	r4, [r7, #12]
	adc_sync_disable_channel(&Battery_lvl, 0);
    37ae:	4b1d      	ldr	r3, [pc, #116]	; (3824 <read_battery+0xac>)
    37b0:	2100      	movs	r1, #0
    37b2:	0018      	movs	r0, r3
    37b4:	4b1f      	ldr	r3, [pc, #124]	; (3834 <read_battery+0xbc>)
    37b6:	4798      	blx	r3

	if(battery_lvl < 1365)
    37b8:	4c1f      	ldr	r4, [pc, #124]	; (3838 <read_battery+0xc0>)
    37ba:	2200      	movs	r2, #0
    37bc:	4b1f      	ldr	r3, [pc, #124]	; (383c <read_battery+0xc4>)
    37be:	68b8      	ldr	r0, [r7, #8]
    37c0:	68f9      	ldr	r1, [r7, #12]
    37c2:	47a0      	blx	r4
    37c4:	1e03      	subs	r3, r0, #0
    37c6:	d026      	beq.n	3816 <read_battery+0x9e>
	{	
		adc_sync_enable_channel(&Battery_lvl, 0);
    37c8:	4b16      	ldr	r3, [pc, #88]	; (3824 <read_battery+0xac>)
    37ca:	2100      	movs	r1, #0
    37cc:	0018      	movs	r0, r3
    37ce:	4b16      	ldr	r3, [pc, #88]	; (3828 <read_battery+0xb0>)
    37d0:	4798      	blx	r3
		adc_sync_read_channel(&Battery_lvl, 0, battery, 2);
    37d2:	1d3a      	adds	r2, r7, #4
    37d4:	4813      	ldr	r0, [pc, #76]	; (3824 <read_battery+0xac>)
    37d6:	2302      	movs	r3, #2
    37d8:	2100      	movs	r1, #0
    37da:	4c14      	ldr	r4, [pc, #80]	; (382c <read_battery+0xb4>)
    37dc:	47a0      	blx	r4
		battery_lvl = ((uint16_t)battery[1] << 8) | battery[0];
    37de:	1d3b      	adds	r3, r7, #4
    37e0:	785b      	ldrb	r3, [r3, #1]
    37e2:	021b      	lsls	r3, r3, #8
    37e4:	1d3a      	adds	r2, r7, #4
    37e6:	7812      	ldrb	r2, [r2, #0]
    37e8:	431a      	orrs	r2, r3
    37ea:	4b11      	ldr	r3, [pc, #68]	; (3830 <read_battery+0xb8>)
    37ec:	0010      	movs	r0, r2
    37ee:	4798      	blx	r3
    37f0:	0003      	movs	r3, r0
    37f2:	000c      	movs	r4, r1
    37f4:	60bb      	str	r3, [r7, #8]
    37f6:	60fc      	str	r4, [r7, #12]
		adc_sync_disable_channel(&Battery_lvl, 0);
    37f8:	4b0a      	ldr	r3, [pc, #40]	; (3824 <read_battery+0xac>)
    37fa:	2100      	movs	r1, #0
    37fc:	0018      	movs	r0, r3
    37fe:	4b0d      	ldr	r3, [pc, #52]	; (3834 <read_battery+0xbc>)
    3800:	4798      	blx	r3
		if(battery_lvl < 1365)
    3802:	4c0d      	ldr	r4, [pc, #52]	; (3838 <read_battery+0xc0>)
    3804:	2200      	movs	r2, #0
    3806:	4b0d      	ldr	r3, [pc, #52]	; (383c <read_battery+0xc4>)
    3808:	68b8      	ldr	r0, [r7, #8]
    380a:	68f9      	ldr	r1, [r7, #12]
    380c:	47a0      	blx	r4
    380e:	1e03      	subs	r3, r0, #0
    3810:	d003      	beq.n	381a <read_battery+0xa2>
			return 1;
    3812:	2301      	movs	r3, #1
    3814:	e001      	b.n	381a <read_battery+0xa2>
	}
	else
		return 0;
    3816:	2300      	movs	r3, #0
    3818:	e7ff      	b.n	381a <read_battery+0xa2>
}
    381a:	0018      	movs	r0, r3
    381c:	46bd      	mov	sp, r7
    381e:	b005      	add	sp, #20
    3820:	bd90      	pop	{r4, r7, pc}
    3822:	46c0      	nop			; (mov r8, r8)
    3824:	2000274c 	.word	0x2000274c
    3828:	00000c29 	.word	0x00000c29
    382c:	00000cb1 	.word	0x00000cb1
    3830:	00005cb1 	.word	0x00005cb1
    3834:	00000c6d 	.word	0x00000c6d
    3838:	00005a61 	.word	0x00005a61
    383c:	40955400 	.word	0x40955400

00003840 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise(List_t *const pxList)
{
    3840:	b580      	push	{r7, lr}
    3842:	b082      	sub	sp, #8
    3844:	af00      	add	r7, sp, #0
    3846:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    3848:	687b      	ldr	r3, [r7, #4]
    384a:	3308      	adds	r3, #8
    384c:	001a      	movs	r2, r3
    384e:	687b      	ldr	r3, [r7, #4]
    3850:	605a      	str	r2, [r3, #4]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    3852:	687b      	ldr	r3, [r7, #4]
    3854:	2201      	movs	r2, #1
    3856:	4252      	negs	r2, r2
    3858:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    385a:	687b      	ldr	r3, [r7, #4]
    385c:	3308      	adds	r3, #8
    385e:	001a      	movs	r2, r3
    3860:	687b      	ldr	r3, [r7, #4]
    3862:	60da      	str	r2, [r3, #12]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    3864:	687b      	ldr	r3, [r7, #4]
    3866:	3308      	adds	r3, #8
    3868:	001a      	movs	r2, r3
    386a:	687b      	ldr	r3, [r7, #4]
    386c:	611a      	str	r2, [r3, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    386e:	687b      	ldr	r3, [r7, #4]
    3870:	2200      	movs	r2, #0
    3872:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    3874:	46c0      	nop			; (mov r8, r8)
    3876:	46bd      	mov	sp, r7
    3878:	b002      	add	sp, #8
    387a:	bd80      	pop	{r7, pc}

0000387c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
    387c:	b580      	push	{r7, lr}
    387e:	b082      	sub	sp, #8
    3880:	af00      	add	r7, sp, #0
    3882:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    3884:	687b      	ldr	r3, [r7, #4]
    3886:	2200      	movs	r2, #0
    3888:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    388a:	46c0      	nop			; (mov r8, r8)
    388c:	46bd      	mov	sp, r7
    388e:	b002      	add	sp, #8
    3890:	bd80      	pop	{r7, pc}

00003892 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    3892:	b580      	push	{r7, lr}
    3894:	b084      	sub	sp, #16
    3896:	af00      	add	r7, sp, #0
    3898:	6078      	str	r0, [r7, #4]
    389a:	6039      	str	r1, [r7, #0]
	ListItem_t *const pxIndex = pxList->pxIndex;
    389c:	687b      	ldr	r3, [r7, #4]
    389e:	685b      	ldr	r3, [r3, #4]
    38a0:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    38a2:	683b      	ldr	r3, [r7, #0]
    38a4:	68fa      	ldr	r2, [r7, #12]
    38a6:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    38a8:	68fb      	ldr	r3, [r7, #12]
    38aa:	689a      	ldr	r2, [r3, #8]
    38ac:	683b      	ldr	r3, [r7, #0]
    38ae:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    38b0:	68fb      	ldr	r3, [r7, #12]
    38b2:	689b      	ldr	r3, [r3, #8]
    38b4:	683a      	ldr	r2, [r7, #0]
    38b6:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    38b8:	68fb      	ldr	r3, [r7, #12]
    38ba:	683a      	ldr	r2, [r7, #0]
    38bc:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
    38be:	683b      	ldr	r3, [r7, #0]
    38c0:	687a      	ldr	r2, [r7, #4]
    38c2:	611a      	str	r2, [r3, #16]

	(pxList->uxNumberOfItems)++;
    38c4:	687b      	ldr	r3, [r7, #4]
    38c6:	681b      	ldr	r3, [r3, #0]
    38c8:	1c5a      	adds	r2, r3, #1
    38ca:	687b      	ldr	r3, [r7, #4]
    38cc:	601a      	str	r2, [r3, #0]
}
    38ce:	46c0      	nop			; (mov r8, r8)
    38d0:	46bd      	mov	sp, r7
    38d2:	b004      	add	sp, #16
    38d4:	bd80      	pop	{r7, pc}

000038d6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    38d6:	b580      	push	{r7, lr}
    38d8:	b084      	sub	sp, #16
    38da:	af00      	add	r7, sp, #0
    38dc:	6078      	str	r0, [r7, #4]
    38de:	6039      	str	r1, [r7, #0]
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    38e0:	683b      	ldr	r3, [r7, #0]
    38e2:	681b      	ldr	r3, [r3, #0]
    38e4:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    38e6:	68bb      	ldr	r3, [r7, #8]
    38e8:	3301      	adds	r3, #1
    38ea:	d103      	bne.n	38f4 <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    38ec:	687b      	ldr	r3, [r7, #4]
    38ee:	691b      	ldr	r3, [r3, #16]
    38f0:	60fb      	str	r3, [r7, #12]
    38f2:	e00c      	b.n	390e <vListInsert+0x38>
		    4) Using a queue or semaphore before it has been initialised or
		       before the scheduler has been started (are interrupts firing
		       before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    38f4:	687b      	ldr	r3, [r7, #4]
    38f6:	3308      	adds	r3, #8
    38f8:	60fb      	str	r3, [r7, #12]
    38fa:	e002      	b.n	3902 <vListInsert+0x2c>
		     pxIterator
		     = pxIterator
    38fc:	68fb      	ldr	r3, [r7, #12]
    38fe:	685b      	ldr	r3, [r3, #4]
    3900:	60fb      	str	r3, [r7, #12]
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    3902:	68fb      	ldr	r3, [r7, #12]
    3904:	685b      	ldr	r3, [r3, #4]
    3906:	681a      	ldr	r2, [r3, #0]
    3908:	68bb      	ldr	r3, [r7, #8]
    390a:	429a      	cmp	r2, r3
    390c:	d9f6      	bls.n	38fc <vListInsert+0x26>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    390e:	68fb      	ldr	r3, [r7, #12]
    3910:	685a      	ldr	r2, [r3, #4]
    3912:	683b      	ldr	r3, [r7, #0]
    3914:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3916:	683b      	ldr	r3, [r7, #0]
    3918:	685b      	ldr	r3, [r3, #4]
    391a:	683a      	ldr	r2, [r7, #0]
    391c:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    391e:	683b      	ldr	r3, [r7, #0]
    3920:	68fa      	ldr	r2, [r7, #12]
    3922:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext                = pxNewListItem;
    3924:	68fb      	ldr	r3, [r7, #12]
    3926:	683a      	ldr	r2, [r7, #0]
    3928:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;
    392a:	683b      	ldr	r3, [r7, #0]
    392c:	687a      	ldr	r2, [r7, #4]
    392e:	611a      	str	r2, [r3, #16]

	(pxList->uxNumberOfItems)++;
    3930:	687b      	ldr	r3, [r7, #4]
    3932:	681b      	ldr	r3, [r3, #0]
    3934:	1c5a      	adds	r2, r3, #1
    3936:	687b      	ldr	r3, [r7, #4]
    3938:	601a      	str	r2, [r3, #0]
}
    393a:	46c0      	nop			; (mov r8, r8)
    393c:	46bd      	mov	sp, r7
    393e:	b004      	add	sp, #16
    3940:	bd80      	pop	{r7, pc}

00003942 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
    3942:	b580      	push	{r7, lr}
    3944:	b084      	sub	sp, #16
    3946:	af00      	add	r7, sp, #0
    3948:	6078      	str	r0, [r7, #4]
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    394a:	687b      	ldr	r3, [r7, #4]
    394c:	691b      	ldr	r3, [r3, #16]
    394e:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3950:	687b      	ldr	r3, [r7, #4]
    3952:	685b      	ldr	r3, [r3, #4]
    3954:	687a      	ldr	r2, [r7, #4]
    3956:	6892      	ldr	r2, [r2, #8]
    3958:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    395a:	687b      	ldr	r3, [r7, #4]
    395c:	689b      	ldr	r3, [r3, #8]
    395e:	687a      	ldr	r2, [r7, #4]
    3960:	6852      	ldr	r2, [r2, #4]
    3962:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    3964:	68fb      	ldr	r3, [r7, #12]
    3966:	685a      	ldr	r2, [r3, #4]
    3968:	687b      	ldr	r3, [r7, #4]
    396a:	429a      	cmp	r2, r3
    396c:	d103      	bne.n	3976 <uxListRemove+0x34>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    396e:	687b      	ldr	r3, [r7, #4]
    3970:	689a      	ldr	r2, [r3, #8]
    3972:	68fb      	ldr	r3, [r7, #12]
    3974:	605a      	str	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    3976:	687b      	ldr	r3, [r7, #4]
    3978:	2200      	movs	r2, #0
    397a:	611a      	str	r2, [r3, #16]
	(pxList->uxNumberOfItems)--;
    397c:	68fb      	ldr	r3, [r7, #12]
    397e:	681b      	ldr	r3, [r3, #0]
    3980:	1e5a      	subs	r2, r3, #1
    3982:	68fb      	ldr	r3, [r7, #12]
    3984:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    3986:	68fb      	ldr	r3, [r7, #12]
    3988:	681b      	ldr	r3, [r3, #0]
}
    398a:	0018      	movs	r0, r3
    398c:	46bd      	mov	sp, r7
    398e:	b004      	add	sp, #16
    3990:	bd80      	pop	{r7, pc}
	...

00003994 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack(StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters)
{
    3994:	b580      	push	{r7, lr}
    3996:	b084      	sub	sp, #16
    3998:	af00      	add	r7, sp, #0
    399a:	60f8      	str	r0, [r7, #12]
    399c:	60b9      	str	r1, [r7, #8]
    399e:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    39a0:	68fb      	ldr	r3, [r7, #12]
    39a2:	3b04      	subs	r3, #4
    39a4:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    39a6:	68fb      	ldr	r3, [r7, #12]
    39a8:	2280      	movs	r2, #128	; 0x80
    39aa:	0452      	lsls	r2, r2, #17
    39ac:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
    39ae:	68fb      	ldr	r3, [r7, #12]
    39b0:	3b04      	subs	r3, #4
    39b2:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
    39b4:	68ba      	ldr	r2, [r7, #8]
    39b6:	68fb      	ldr	r3, [r7, #12]
    39b8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
    39ba:	68fb      	ldr	r3, [r7, #12]
    39bc:	3b04      	subs	r3, #4
    39be:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    39c0:	4a08      	ldr	r2, [pc, #32]	; (39e4 <pxPortInitialiseStack+0x50>)
    39c2:	68fb      	ldr	r3, [r7, #12]
    39c4:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;                                    /* R12, R3, R2 and R1. */
    39c6:	68fb      	ldr	r3, [r7, #12]
    39c8:	3b14      	subs	r3, #20
    39ca:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = (StackType_t)pvParameters;            /* R0 */
    39cc:	687a      	ldr	r2, [r7, #4]
    39ce:	68fb      	ldr	r3, [r7, #12]
    39d0:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;                                    /* R11..R4. */
    39d2:	68fb      	ldr	r3, [r7, #12]
    39d4:	3b20      	subs	r3, #32
    39d6:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
    39d8:	68fb      	ldr	r3, [r7, #12]
}
    39da:	0018      	movs	r0, r3
    39dc:	46bd      	mov	sp, r7
    39de:	b004      	add	sp, #16
    39e0:	bd80      	pop	{r7, pc}
    39e2:	46c0      	nop			; (mov r8, r8)
    39e4:	000039e9 	.word	0x000039e9

000039e8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError(void)
{
    39e8:	b580      	push	{r7, lr}
    39ea:	b082      	sub	sp, #8
    39ec:	af00      	add	r7, sp, #0
	volatile uint32_t ulDummy = 0UL;
    39ee:	2300      	movs	r3, #0
    39f0:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
    39f2:	4b07      	ldr	r3, [pc, #28]	; (3a10 <prvTaskExitError+0x28>)
    39f4:	681b      	ldr	r3, [r3, #0]
    39f6:	3301      	adds	r3, #1
    39f8:	d001      	beq.n	39fe <prvTaskExitError+0x16>
    39fa:	b672      	cpsid	i
    39fc:	e7fe      	b.n	39fc <prvTaskExitError+0x14>
	portDISABLE_INTERRUPTS();
    39fe:	b672      	cpsid	i
	while (ulDummy == 0) {
    3a00:	46c0      	nop			; (mov r8, r8)
    3a02:	687b      	ldr	r3, [r7, #4]
    3a04:	2b00      	cmp	r3, #0
    3a06:	d0fc      	beq.n	3a02 <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
    3a08:	46c0      	nop			; (mov r8, r8)
    3a0a:	46bd      	mov	sp, r7
    3a0c:	b002      	add	sp, #8
    3a0e:	bd80      	pop	{r7, pc}
    3a10:	20000028 	.word	0x20000028

00003a14 <SVCall_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler(void)
{
    3a14:	b580      	push	{r7, lr}
    3a16:	af00      	add	r7, sp, #0
	/* This function is no longer used, but retained for backward
	compatibility. */
}
    3a18:	46c0      	nop			; (mov r8, r8)
    3a1a:	46bd      	mov	sp, r7
    3a1c:	bd80      	pop	{r7, pc}
	...

00003a20 <vPortStartFirstTask>:
void vPortStartFirstTask(void)
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
    3a20:	4a0b      	ldr	r2, [pc, #44]	; (3a50 <pxCurrentTCBConst2>)
    3a22:	6813      	ldr	r3, [r2, #0]
    3a24:	6818      	ldr	r0, [r3, #0]
    3a26:	3020      	adds	r0, #32
    3a28:	f380 8809 	msr	PSP, r0
    3a2c:	2002      	movs	r0, #2
    3a2e:	f380 8814 	msr	CONTROL, r0
    3a32:	f3bf 8f6f 	isb	sy
    3a36:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
    3a38:	46ae      	mov	lr, r5
    3a3a:	bc08      	pop	{r3}
    3a3c:	bc04      	pop	{r2}
    3a3e:	b662      	cpsie	i
    3a40:	4718      	bx	r3
    3a42:	46c0      	nop			; (mov r8, r8)
    3a44:	46c0      	nop			; (mov r8, r8)
    3a46:	46c0      	nop			; (mov r8, r8)
    3a48:	46c0      	nop			; (mov r8, r8)
    3a4a:	46c0      	nop			; (mov r8, r8)
    3a4c:	46c0      	nop			; (mov r8, r8)
    3a4e:	46c0      	nop			; (mov r8, r8)

00003a50 <pxCurrentTCBConst2>:
    3a50:	20002600 	.word	0x20002600
	    "	cpsie i						\n"     /* The first task has its context and interrupts can be enabled. */
	    "	bx   r3						\n"     /* Finally, jump to the user defined task code. */
	    "								\n"
	    "	.align 4					\n"
	    "pxCurrentTCBConst2: .word pxCurrentTCB	  ");
}
    3a54:	46c0      	nop			; (mov r8, r8)
    3a56:	46c0      	nop			; (mov r8, r8)

00003a58 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler(void)
{
    3a58:	b580      	push	{r7, lr}
    3a5a:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    3a5c:	4b0e      	ldr	r3, [pc, #56]	; (3a98 <xPortStartScheduler+0x40>)
    3a5e:	4a0e      	ldr	r2, [pc, #56]	; (3a98 <xPortStartScheduler+0x40>)
    3a60:	6812      	ldr	r2, [r2, #0]
    3a62:	21ff      	movs	r1, #255	; 0xff
    3a64:	0409      	lsls	r1, r1, #16
    3a66:	430a      	orrs	r2, r1
    3a68:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    3a6a:	4b0b      	ldr	r3, [pc, #44]	; (3a98 <xPortStartScheduler+0x40>)
    3a6c:	4a0a      	ldr	r2, [pc, #40]	; (3a98 <xPortStartScheduler+0x40>)
    3a6e:	6812      	ldr	r2, [r2, #0]
    3a70:	21ff      	movs	r1, #255	; 0xff
    3a72:	0609      	lsls	r1, r1, #24
    3a74:	430a      	orrs	r2, r1
    3a76:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
    3a78:	4b08      	ldr	r3, [pc, #32]	; (3a9c <xPortStartScheduler+0x44>)
    3a7a:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
    3a7c:	4b08      	ldr	r3, [pc, #32]	; (3aa0 <xPortStartScheduler+0x48>)
    3a7e:	2200      	movs	r2, #0
    3a80:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
    3a82:	4b08      	ldr	r3, [pc, #32]	; (3aa4 <xPortStartScheduler+0x4c>)
    3a84:	4798      	blx	r3
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
    3a86:	4b08      	ldr	r3, [pc, #32]	; (3aa8 <xPortStartScheduler+0x50>)
    3a88:	4798      	blx	r3
	prvTaskExitError();
    3a8a:	4b08      	ldr	r3, [pc, #32]	; (3aac <xPortStartScheduler+0x54>)
    3a8c:	4798      	blx	r3

	/* Should not get here! */
	return 0;
    3a8e:	2300      	movs	r3, #0
}
    3a90:	0018      	movs	r0, r3
    3a92:	46bd      	mov	sp, r7
    3a94:	bd80      	pop	{r7, pc}
    3a96:	46c0      	nop			; (mov r8, r8)
    3a98:	e000ed20 	.word	0xe000ed20
    3a9c:	00003bc9 	.word	0x00003bc9
    3aa0:	20000028 	.word	0x20000028
    3aa4:	00003a21 	.word	0x00003a21
    3aa8:	00004c99 	.word	0x00004c99
    3aac:	000039e9 	.word	0x000039e9

00003ab0 <vPortYield>:
	configASSERT(uxCriticalNesting == 1000UL);
}
/*-----------------------------------------------------------*/

void vPortYield(void)
{
    3ab0:	b580      	push	{r7, lr}
    3ab2:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    3ab4:	4b05      	ldr	r3, [pc, #20]	; (3acc <vPortYield+0x1c>)
    3ab6:	2280      	movs	r2, #128	; 0x80
    3ab8:	0552      	lsls	r2, r2, #21
    3aba:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile("dsb" ::: "memory");
    3abc:	f3bf 8f4f 	dsb	sy
	__asm volatile("isb");
    3ac0:	f3bf 8f6f 	isb	sy
}
    3ac4:	46c0      	nop			; (mov r8, r8)
    3ac6:	46bd      	mov	sp, r7
    3ac8:	bd80      	pop	{r7, pc}
    3aca:	46c0      	nop			; (mov r8, r8)
    3acc:	e000ed04 	.word	0xe000ed04

00003ad0 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical(void)
{
    3ad0:	b580      	push	{r7, lr}
    3ad2:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
    3ad4:	b672      	cpsid	i
	uxCriticalNesting++;
    3ad6:	4b06      	ldr	r3, [pc, #24]	; (3af0 <vPortEnterCritical+0x20>)
    3ad8:	681b      	ldr	r3, [r3, #0]
    3ada:	1c5a      	adds	r2, r3, #1
    3adc:	4b04      	ldr	r3, [pc, #16]	; (3af0 <vPortEnterCritical+0x20>)
    3ade:	601a      	str	r2, [r3, #0]
	__asm volatile("dsb" ::: "memory");
    3ae0:	f3bf 8f4f 	dsb	sy
	__asm volatile("isb");
    3ae4:	f3bf 8f6f 	isb	sy
}
    3ae8:	46c0      	nop			; (mov r8, r8)
    3aea:	46bd      	mov	sp, r7
    3aec:	bd80      	pop	{r7, pc}
    3aee:	46c0      	nop			; (mov r8, r8)
    3af0:	20000028 	.word	0x20000028

00003af4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical(void)
{
    3af4:	b580      	push	{r7, lr}
    3af6:	af00      	add	r7, sp, #0
	configASSERT(uxCriticalNesting);
    3af8:	4b09      	ldr	r3, [pc, #36]	; (3b20 <vPortExitCritical+0x2c>)
    3afa:	681b      	ldr	r3, [r3, #0]
    3afc:	2b00      	cmp	r3, #0
    3afe:	d101      	bne.n	3b04 <vPortExitCritical+0x10>
    3b00:	b672      	cpsid	i
    3b02:	e7fe      	b.n	3b02 <vPortExitCritical+0xe>
	uxCriticalNesting--;
    3b04:	4b06      	ldr	r3, [pc, #24]	; (3b20 <vPortExitCritical+0x2c>)
    3b06:	681b      	ldr	r3, [r3, #0]
    3b08:	1e5a      	subs	r2, r3, #1
    3b0a:	4b05      	ldr	r3, [pc, #20]	; (3b20 <vPortExitCritical+0x2c>)
    3b0c:	601a      	str	r2, [r3, #0]
	if (uxCriticalNesting == 0) {
    3b0e:	4b04      	ldr	r3, [pc, #16]	; (3b20 <vPortExitCritical+0x2c>)
    3b10:	681b      	ldr	r3, [r3, #0]
    3b12:	2b00      	cmp	r3, #0
    3b14:	d100      	bne.n	3b18 <vPortExitCritical+0x24>
		portENABLE_INTERRUPTS();
    3b16:	b662      	cpsie	i
	}
}
    3b18:	46c0      	nop			; (mov r8, r8)
    3b1a:	46bd      	mov	sp, r7
    3b1c:	bd80      	pop	{r7, pc}
    3b1e:	46c0      	nop			; (mov r8, r8)
    3b20:	20000028 	.word	0x20000028

00003b24 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR(void)
{
	__asm volatile(" mrs r0, PRIMASK	\n"
    3b24:	f3ef 8010 	mrs	r0, PRIMASK
    3b28:	b672      	cpsid	i
    3b2a:	4770      	bx	lr
	/* To avoid compiler warnings.  The return statement will nevere be reached,
	but some compilers warn if it is not included, while others won't compile if
	it is. */
	return 0;
#endif
}
    3b2c:	46c0      	nop			; (mov r8, r8)
    3b2e:	0018      	movs	r0, r3

00003b30 <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR(__attribute__((unused)) uint32_t ulMask)
{
	__asm volatile(" msr PRIMASK, r0	\n"
    3b30:	f380 8810 	msr	PRIMASK, r0
    3b34:	4770      	bx	lr
	/* Just to avoid compiler warning.  ulMask is used from the asm code but
	the compiler can't see that.  Some compilers generate warnings without the
	following line, while others generate warnings if the line is included. */
	(void)ulMask;
#endif
}
    3b36:	46c0      	nop			; (mov r8, r8)
	...

00003b40 <PendSV_Handler>:

void xPortPendSVHandler(void)
{
	/* This is a naked function. */

	__asm volatile(
    3b40:	f3ef 8009 	mrs	r0, PSP
    3b44:	4b0e      	ldr	r3, [pc, #56]	; (3b80 <pxCurrentTCBConst>)
    3b46:	681a      	ldr	r2, [r3, #0]
    3b48:	3820      	subs	r0, #32
    3b4a:	6010      	str	r0, [r2, #0]
    3b4c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    3b4e:	4644      	mov	r4, r8
    3b50:	464d      	mov	r5, r9
    3b52:	4656      	mov	r6, sl
    3b54:	465f      	mov	r7, fp
    3b56:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    3b58:	b508      	push	{r3, lr}
    3b5a:	b672      	cpsid	i
    3b5c:	f001 f89c 	bl	4c98 <vTaskSwitchContext>
    3b60:	b662      	cpsie	i
    3b62:	bc0c      	pop	{r2, r3}
    3b64:	6811      	ldr	r1, [r2, #0]
    3b66:	6808      	ldr	r0, [r1, #0]
    3b68:	3010      	adds	r0, #16
    3b6a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    3b6c:	46a0      	mov	r8, r4
    3b6e:	46a9      	mov	r9, r5
    3b70:	46b2      	mov	sl, r6
    3b72:	46bb      	mov	fp, r7
    3b74:	f380 8809 	msr	PSP, r0
    3b78:	3820      	subs	r0, #32
    3b7a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    3b7c:	4718      	bx	r3
    3b7e:	46c0      	nop			; (mov r8, r8)

00003b80 <pxCurrentTCBConst>:
    3b80:	20002600 	.word	0x20002600
	    "										\n"
	    "	bx r3								\n"
	    "										\n"
	    "	.align 4							\n"
	    "pxCurrentTCBConst: .word pxCurrentTCB	  ");
}
    3b84:	46c0      	nop			; (mov r8, r8)
    3b86:	46c0      	nop			; (mov r8, r8)

00003b88 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler(void)
{
    3b88:	b580      	push	{r7, lr}
    3b8a:	b082      	sub	sp, #8
    3b8c:	af00      	add	r7, sp, #0
	uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    3b8e:	4b0a      	ldr	r3, [pc, #40]	; (3bb8 <SysTick_Handler+0x30>)
    3b90:	4798      	blx	r3
    3b92:	0003      	movs	r3, r0
    3b94:	607b      	str	r3, [r7, #4]
	{
		/* Increment the RTOS tick. */
		if (xTaskIncrementTick() != pdFALSE) {
    3b96:	4b09      	ldr	r3, [pc, #36]	; (3bbc <SysTick_Handler+0x34>)
    3b98:	4798      	blx	r3
    3b9a:	1e03      	subs	r3, r0, #0
    3b9c:	d003      	beq.n	3ba6 <SysTick_Handler+0x1e>
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    3b9e:	4b08      	ldr	r3, [pc, #32]	; (3bc0 <SysTick_Handler+0x38>)
    3ba0:	2280      	movs	r2, #128	; 0x80
    3ba2:	0552      	lsls	r2, r2, #21
    3ba4:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
    3ba6:	687b      	ldr	r3, [r7, #4]
    3ba8:	0018      	movs	r0, r3
    3baa:	4b06      	ldr	r3, [pc, #24]	; (3bc4 <SysTick_Handler+0x3c>)
    3bac:	4798      	blx	r3
}
    3bae:	46c0      	nop			; (mov r8, r8)
    3bb0:	46bd      	mov	sp, r7
    3bb2:	b002      	add	sp, #8
    3bb4:	bd80      	pop	{r7, pc}
    3bb6:	46c0      	nop			; (mov r8, r8)
    3bb8:	00003b25 	.word	0x00003b25
    3bbc:	00004b25 	.word	0x00004b25
    3bc0:	e000ed04 	.word	0xe000ed04
    3bc4:	00003b31 	.word	0x00003b31

00003bc8 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt(void)
{
    3bc8:	b580      	push	{r7, lr}
    3bca:	af00      	add	r7, sp, #0
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL)          = 0UL;
    3bcc:	4b07      	ldr	r3, [pc, #28]	; (3bec <prvSetupTimerInterrupt+0x24>)
    3bce:	2200      	movs	r2, #0
    3bd0:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
    3bd2:	4b07      	ldr	r3, [pc, #28]	; (3bf0 <prvSetupTimerInterrupt+0x28>)
    3bd4:	2200      	movs	r2, #0
    3bd6:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = (configCPU_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    3bd8:	4b06      	ldr	r3, [pc, #24]	; (3bf4 <prvSetupTimerInterrupt+0x2c>)
    3bda:	4a07      	ldr	r2, [pc, #28]	; (3bf8 <prvSetupTimerInterrupt+0x30>)
    3bdc:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    3bde:	4b03      	ldr	r3, [pc, #12]	; (3bec <prvSetupTimerInterrupt+0x24>)
    3be0:	2207      	movs	r2, #7
    3be2:	601a      	str	r2, [r3, #0]
}
    3be4:	46c0      	nop			; (mov r8, r8)
    3be6:	46bd      	mov	sp, r7
    3be8:	bd80      	pop	{r7, pc}
    3bea:	46c0      	nop			; (mov r8, r8)
    3bec:	e000e010 	.word	0xe000e010
    3bf0:	e000e018 	.word	0xe000e018
    3bf4:	e000e014 	.word	0xe000e014
    3bf8:	00000f9f 	.word	0x00000f9f

00003bfc <pvPortMalloc>:
static size_t xNextFreeByte = (size_t)0;

/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    3bfc:	b580      	push	{r7, lr}
    3bfe:	b084      	sub	sp, #16
    3c00:	af00      	add	r7, sp, #0
    3c02:	6078      	str	r0, [r7, #4]
	void *          pvReturn       = NULL;
    3c04:	2300      	movs	r3, #0
    3c06:	60fb      	str	r3, [r7, #12]
	static uint8_t *pucAlignedHeap = NULL;

/* Ensure that blocks are always aligned to the required number of bytes. */
#if (portBYTE_ALIGNMENT != 1)
	{
		if (xWantedSize & portBYTE_ALIGNMENT_MASK) {
    3c08:	687b      	ldr	r3, [r7, #4]
    3c0a:	2207      	movs	r2, #7
    3c0c:	4013      	ands	r3, r2
    3c0e:	d004      	beq.n	3c1a <pvPortMalloc+0x1e>
			/* Byte alignment required. */
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    3c10:	687b      	ldr	r3, [r7, #4]
    3c12:	2207      	movs	r2, #7
    3c14:	4393      	bics	r3, r2
    3c16:	3308      	adds	r3, #8
    3c18:	607b      	str	r3, [r7, #4]
		}
	}
#endif

	vTaskSuspendAll();
    3c1a:	4b17      	ldr	r3, [pc, #92]	; (3c78 <pvPortMalloc+0x7c>)
    3c1c:	4798      	blx	r3
	{
		if (pucAlignedHeap == NULL) {
    3c1e:	4b17      	ldr	r3, [pc, #92]	; (3c7c <pvPortMalloc+0x80>)
    3c20:	681b      	ldr	r3, [r3, #0]
    3c22:	2b00      	cmp	r3, #0
    3c24:	d105      	bne.n	3c32 <pvPortMalloc+0x36>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    3c26:	4b16      	ldr	r3, [pc, #88]	; (3c80 <pvPortMalloc+0x84>)
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    3c28:	2207      	movs	r2, #7
    3c2a:	4393      	bics	r3, r2
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    3c2c:	001a      	movs	r2, r3
    3c2e:	4b13      	ldr	r3, [pc, #76]	; (3c7c <pvPortMalloc+0x80>)
    3c30:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if (((xNextFreeByte + xWantedSize) < configADJUSTED_HEAP_SIZE)
    3c32:	4b14      	ldr	r3, [pc, #80]	; (3c84 <pvPortMalloc+0x88>)
    3c34:	681a      	ldr	r2, [r3, #0]
    3c36:	687b      	ldr	r3, [r7, #4]
    3c38:	18d3      	adds	r3, r2, r3
    3c3a:	4a13      	ldr	r2, [pc, #76]	; (3c88 <pvPortMalloc+0x8c>)
    3c3c:	4293      	cmp	r3, r2
    3c3e:	d813      	bhi.n	3c68 <pvPortMalloc+0x6c>
		    && ((xNextFreeByte + xWantedSize) > xNextFreeByte)) /* Check for overflow. */
    3c40:	4b10      	ldr	r3, [pc, #64]	; (3c84 <pvPortMalloc+0x88>)
    3c42:	681a      	ldr	r2, [r3, #0]
    3c44:	687b      	ldr	r3, [r7, #4]
    3c46:	18d2      	adds	r2, r2, r3
    3c48:	4b0e      	ldr	r3, [pc, #56]	; (3c84 <pvPortMalloc+0x88>)
    3c4a:	681b      	ldr	r3, [r3, #0]
    3c4c:	429a      	cmp	r2, r3
    3c4e:	d90b      	bls.n	3c68 <pvPortMalloc+0x6c>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    3c50:	4b0a      	ldr	r3, [pc, #40]	; (3c7c <pvPortMalloc+0x80>)
    3c52:	681a      	ldr	r2, [r3, #0]
    3c54:	4b0b      	ldr	r3, [pc, #44]	; (3c84 <pvPortMalloc+0x88>)
    3c56:	681b      	ldr	r3, [r3, #0]
    3c58:	18d3      	adds	r3, r2, r3
    3c5a:	60fb      	str	r3, [r7, #12]
			xNextFreeByte += xWantedSize;
    3c5c:	4b09      	ldr	r3, [pc, #36]	; (3c84 <pvPortMalloc+0x88>)
    3c5e:	681a      	ldr	r2, [r3, #0]
    3c60:	687b      	ldr	r3, [r7, #4]
    3c62:	18d2      	adds	r2, r2, r3
    3c64:	4b07      	ldr	r3, [pc, #28]	; (3c84 <pvPortMalloc+0x88>)
    3c66:	601a      	str	r2, [r3, #0]
		}

		traceMALLOC(pvReturn, xWantedSize);
	}
	(void)xTaskResumeAll();
    3c68:	4b08      	ldr	r3, [pc, #32]	; (3c8c <pvPortMalloc+0x90>)
    3c6a:	4798      	blx	r3
			vApplicationMallocFailedHook();
		}
	}
#endif

	return pvReturn;
    3c6c:	68fb      	ldr	r3, [r7, #12]
}
    3c6e:	0018      	movs	r0, r3
    3c70:	46bd      	mov	sp, r7
    3c72:	b004      	add	sp, #16
    3c74:	bd80      	pop	{r7, pc}
    3c76:	46c0      	nop			; (mov r8, r8)
    3c78:	000049bd 	.word	0x000049bd
    3c7c:	200025fc 	.word	0x200025fc
    3c80:	20000080 	.word	0x20000080
    3c84:	200025f8 	.word	0x200025f8
    3c88:	00002577 	.word	0x00002577
    3c8c:	000049d5 	.word	0x000049d5

00003c90 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree(void *pv)
{
    3c90:	b580      	push	{r7, lr}
    3c92:	b082      	sub	sp, #8
    3c94:	af00      	add	r7, sp, #0
    3c96:	6078      	str	r0, [r7, #4]
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	(void)pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT(pv == NULL);
    3c98:	687b      	ldr	r3, [r7, #4]
    3c9a:	2b00      	cmp	r3, #0
    3c9c:	d001      	beq.n	3ca2 <vPortFree+0x12>
    3c9e:	b672      	cpsid	i
    3ca0:	e7fe      	b.n	3ca0 <vPortFree+0x10>
}
    3ca2:	46c0      	nop			; (mov r8, r8)
    3ca4:	46bd      	mov	sp, r7
    3ca6:	b002      	add	sp, #8
    3ca8:	bd80      	pop	{r7, pc}
	...

00003cac <xQueueGenericReset>:
	}                                                                                                                  \
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset(QueueHandle_t xQueue, BaseType_t xNewQueue)
{
    3cac:	b580      	push	{r7, lr}
    3cae:	b084      	sub	sp, #16
    3cb0:	af00      	add	r7, sp, #0
    3cb2:	6078      	str	r0, [r7, #4]
    3cb4:	6039      	str	r1, [r7, #0]
	Queue_t *const pxQueue = (Queue_t *)xQueue;
    3cb6:	687b      	ldr	r3, [r7, #4]
    3cb8:	60fb      	str	r3, [r7, #12]

	configASSERT(pxQueue);
    3cba:	68fb      	ldr	r3, [r7, #12]
    3cbc:	2b00      	cmp	r3, #0
    3cbe:	d101      	bne.n	3cc4 <xQueueGenericReset+0x18>
    3cc0:	b672      	cpsid	i
    3cc2:	e7fe      	b.n	3cc2 <xQueueGenericReset+0x16>

	taskENTER_CRITICAL();
    3cc4:	4b23      	ldr	r3, [pc, #140]	; (3d54 <xQueueGenericReset+0xa8>)
    3cc6:	4798      	blx	r3
	{
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    3cc8:	68fb      	ldr	r3, [r7, #12]
    3cca:	681a      	ldr	r2, [r3, #0]
    3ccc:	68fb      	ldr	r3, [r7, #12]
    3cce:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
    3cd0:	68fb      	ldr	r3, [r7, #12]
    3cd2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3cd4:	434b      	muls	r3, r1
    3cd6:	18d2      	adds	r2, r2, r3
    3cd8:	68fb      	ldr	r3, [r7, #12]
    3cda:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    3cdc:	68fb      	ldr	r3, [r7, #12]
    3cde:	2200      	movs	r2, #0
    3ce0:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    3ce2:	68fb      	ldr	r3, [r7, #12]
    3ce4:	681a      	ldr	r2, [r3, #0]
    3ce6:	68fb      	ldr	r3, [r7, #12]
    3ce8:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    3cea:	68fb      	ldr	r3, [r7, #12]
    3cec:	681a      	ldr	r2, [r3, #0]
    3cee:	68fb      	ldr	r3, [r7, #12]
    3cf0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3cf2:	1e59      	subs	r1, r3, #1
    3cf4:	68fb      	ldr	r3, [r7, #12]
    3cf6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3cf8:	434b      	muls	r3, r1
    3cfa:	18d2      	adds	r2, r2, r3
    3cfc:	68fb      	ldr	r3, [r7, #12]
    3cfe:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock           = queueUNLOCKED;
    3d00:	68fb      	ldr	r3, [r7, #12]
    3d02:	2244      	movs	r2, #68	; 0x44
    3d04:	21ff      	movs	r1, #255	; 0xff
    3d06:	5499      	strb	r1, [r3, r2]
		pxQueue->cTxLock           = queueUNLOCKED;
    3d08:	68fb      	ldr	r3, [r7, #12]
    3d0a:	2245      	movs	r2, #69	; 0x45
    3d0c:	21ff      	movs	r1, #255	; 0xff
    3d0e:	5499      	strb	r1, [r3, r2]

		if (xNewQueue == pdFALSE) {
    3d10:	683b      	ldr	r3, [r7, #0]
    3d12:	2b00      	cmp	r3, #0
    3d14:	d10d      	bne.n	3d32 <xQueueGenericReset+0x86>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    3d16:	68fb      	ldr	r3, [r7, #12]
    3d18:	691b      	ldr	r3, [r3, #16]
    3d1a:	2b00      	cmp	r3, #0
    3d1c:	d013      	beq.n	3d46 <xQueueGenericReset+0x9a>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    3d1e:	68fb      	ldr	r3, [r7, #12]
    3d20:	3310      	adds	r3, #16
    3d22:	0018      	movs	r0, r3
    3d24:	4b0c      	ldr	r3, [pc, #48]	; (3d58 <xQueueGenericReset+0xac>)
    3d26:	4798      	blx	r3
    3d28:	1e03      	subs	r3, r0, #0
    3d2a:	d00c      	beq.n	3d46 <xQueueGenericReset+0x9a>
					queueYIELD_IF_USING_PREEMPTION();
    3d2c:	4b0b      	ldr	r3, [pc, #44]	; (3d5c <xQueueGenericReset+0xb0>)
    3d2e:	4798      	blx	r3
    3d30:	e009      	b.n	3d46 <xQueueGenericReset+0x9a>
			} else {
				mtCOVERAGE_TEST_MARKER();
			}
		} else {
			/* Ensure the event queues start in the correct state. */
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    3d32:	68fb      	ldr	r3, [r7, #12]
    3d34:	3310      	adds	r3, #16
    3d36:	0018      	movs	r0, r3
    3d38:	4b09      	ldr	r3, [pc, #36]	; (3d60 <xQueueGenericReset+0xb4>)
    3d3a:	4798      	blx	r3
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    3d3c:	68fb      	ldr	r3, [r7, #12]
    3d3e:	3324      	adds	r3, #36	; 0x24
    3d40:	0018      	movs	r0, r3
    3d42:	4b07      	ldr	r3, [pc, #28]	; (3d60 <xQueueGenericReset+0xb4>)
    3d44:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
    3d46:	4b07      	ldr	r3, [pc, #28]	; (3d64 <xQueueGenericReset+0xb8>)
    3d48:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3d4a:	2301      	movs	r3, #1
}
    3d4c:	0018      	movs	r0, r3
    3d4e:	46bd      	mov	sp, r7
    3d50:	b004      	add	sp, #16
    3d52:	bd80      	pop	{r7, pc}
    3d54:	00003ad1 	.word	0x00003ad1
    3d58:	00004dd5 	.word	0x00004dd5
    3d5c:	00003ab1 	.word	0x00003ab1
    3d60:	00003841 	.word	0x00003841
    3d64:	00003af5 	.word	0x00003af5

00003d68 <xQueueGenericCreate>:

#if (configSUPPORT_DYNAMIC_ALLOCATION == 1)

QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize,
                                  const uint8_t ucQueueType)
{
    3d68:	b590      	push	{r4, r7, lr}
    3d6a:	b08b      	sub	sp, #44	; 0x2c
    3d6c:	af02      	add	r7, sp, #8
    3d6e:	60f8      	str	r0, [r7, #12]
    3d70:	60b9      	str	r1, [r7, #8]
    3d72:	1dfb      	adds	r3, r7, #7
    3d74:	701a      	strb	r2, [r3, #0]
	Queue_t *pxNewQueue;
	size_t   xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

	configASSERT(uxQueueLength > (UBaseType_t)0);
    3d76:	68fb      	ldr	r3, [r7, #12]
    3d78:	2b00      	cmp	r3, #0
    3d7a:	d101      	bne.n	3d80 <xQueueGenericCreate+0x18>
    3d7c:	b672      	cpsid	i
    3d7e:	e7fe      	b.n	3d7e <xQueueGenericCreate+0x16>

	if (uxItemSize == (UBaseType_t)0) {
    3d80:	68bb      	ldr	r3, [r7, #8]
    3d82:	2b00      	cmp	r3, #0
    3d84:	d102      	bne.n	3d8c <xQueueGenericCreate+0x24>
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = (size_t)0;
    3d86:	2300      	movs	r3, #0
    3d88:	61fb      	str	r3, [r7, #28]
    3d8a:	e003      	b.n	3d94 <xQueueGenericCreate+0x2c>
	} else {
		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time. */
		xQueueSizeInBytes = (size_t)(
    3d8c:	68fb      	ldr	r3, [r7, #12]
    3d8e:	68ba      	ldr	r2, [r7, #8]
    3d90:	4353      	muls	r3, r2
    3d92:	61fb      	str	r3, [r7, #28]
		    uxQueueLength * uxItemSize); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    3d94:	69fb      	ldr	r3, [r7, #28]
    3d96:	3354      	adds	r3, #84	; 0x54
    3d98:	0018      	movs	r0, r3
    3d9a:	4b0c      	ldr	r3, [pc, #48]	; (3dcc <xQueueGenericCreate+0x64>)
    3d9c:	4798      	blx	r3
    3d9e:	0003      	movs	r3, r0
    3da0:	61bb      	str	r3, [r7, #24]

	if (pxNewQueue != NULL) {
    3da2:	69bb      	ldr	r3, [r7, #24]
    3da4:	2b00      	cmp	r3, #0
    3da6:	d00c      	beq.n	3dc2 <xQueueGenericCreate+0x5a>
		/* Jump past the queue structure to find the location of the queue
		storage area. */
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    3da8:	69bb      	ldr	r3, [r7, #24]
    3daa:	3354      	adds	r3, #84	; 0x54
    3dac:	617b      	str	r3, [r7, #20]
			deleted. */
			pxNewQueue->ucStaticallyAllocated = pdFALSE;
		}
#endif /* configSUPPORT_STATIC_ALLOCATION */

		prvInitialiseNewQueue(uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue);
    3dae:	1dfb      	adds	r3, r7, #7
    3db0:	781c      	ldrb	r4, [r3, #0]
    3db2:	697a      	ldr	r2, [r7, #20]
    3db4:	68b9      	ldr	r1, [r7, #8]
    3db6:	68f8      	ldr	r0, [r7, #12]
    3db8:	69bb      	ldr	r3, [r7, #24]
    3dba:	9300      	str	r3, [sp, #0]
    3dbc:	0023      	movs	r3, r4
    3dbe:	4c04      	ldr	r4, [pc, #16]	; (3dd0 <xQueueGenericCreate+0x68>)
    3dc0:	47a0      	blx	r4
	} else {
		traceQUEUE_CREATE_FAILED(ucQueueType);
	}

	return pxNewQueue;
    3dc2:	69bb      	ldr	r3, [r7, #24]
}
    3dc4:	0018      	movs	r0, r3
    3dc6:	46bd      	mov	sp, r7
    3dc8:	b009      	add	sp, #36	; 0x24
    3dca:	bd90      	pop	{r4, r7, pc}
    3dcc:	00003bfd 	.word	0x00003bfd
    3dd0:	00003dd5 	.word	0x00003dd5

00003dd4 <prvInitialiseNewQueue>:
#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize,
                                  uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue)
{
    3dd4:	b580      	push	{r7, lr}
    3dd6:	b084      	sub	sp, #16
    3dd8:	af00      	add	r7, sp, #0
    3dda:	60f8      	str	r0, [r7, #12]
    3ddc:	60b9      	str	r1, [r7, #8]
    3dde:	607a      	str	r2, [r7, #4]
    3de0:	001a      	movs	r2, r3
    3de2:	1cfb      	adds	r3, r7, #3
    3de4:	701a      	strb	r2, [r3, #0]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	(void)ucQueueType;

	if (uxItemSize == (UBaseType_t)0) {
    3de6:	68bb      	ldr	r3, [r7, #8]
    3de8:	2b00      	cmp	r3, #0
    3dea:	d103      	bne.n	3df4 <prvInitialiseNewQueue+0x20>
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = (int8_t *)pxNewQueue;
    3dec:	69bb      	ldr	r3, [r7, #24]
    3dee:	69ba      	ldr	r2, [r7, #24]
    3df0:	601a      	str	r2, [r3, #0]
    3df2:	e002      	b.n	3dfa <prvInitialiseNewQueue+0x26>
	} else {
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    3df4:	69bb      	ldr	r3, [r7, #24]
    3df6:	687a      	ldr	r2, [r7, #4]
    3df8:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength   = uxQueueLength;
    3dfa:	69bb      	ldr	r3, [r7, #24]
    3dfc:	68fa      	ldr	r2, [r7, #12]
    3dfe:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    3e00:	69bb      	ldr	r3, [r7, #24]
    3e02:	68ba      	ldr	r2, [r7, #8]
    3e04:	641a      	str	r2, [r3, #64]	; 0x40
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    3e06:	69bb      	ldr	r3, [r7, #24]
    3e08:	2101      	movs	r1, #1
    3e0a:	0018      	movs	r0, r3
    3e0c:	4b06      	ldr	r3, [pc, #24]	; (3e28 <prvInitialiseNewQueue+0x54>)
    3e0e:	4798      	blx	r3

#if (configUSE_TRACE_FACILITY == 1)
	{
		pxNewQueue->ucQueueType = ucQueueType;
    3e10:	69bb      	ldr	r3, [r7, #24]
    3e12:	1cfa      	adds	r2, r7, #3
    3e14:	2150      	movs	r1, #80	; 0x50
    3e16:	7812      	ldrb	r2, [r2, #0]
    3e18:	545a      	strb	r2, [r3, r1]
	}
#endif /* configUSE_TRACE_FACILITY */

#if (configUSE_QUEUE_SETS == 1)
	{
		pxNewQueue->pxQueueSetContainer = NULL;
    3e1a:	69bb      	ldr	r3, [r7, #24]
    3e1c:	2200      	movs	r2, #0
    3e1e:	649a      	str	r2, [r3, #72]	; 0x48
	}
#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE(pxNewQueue);
}
    3e20:	46c0      	nop			; (mov r8, r8)
    3e22:	46bd      	mov	sp, r7
    3e24:	b004      	add	sp, #16
    3e26:	bd80      	pop	{r7, pc}
    3e28:	00003cad 	.word	0x00003cad

00003e2c <xQueueGenericSend>:
#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void *const pvItemToQueue, TickType_t xTicksToWait,
                             const BaseType_t xCopyPosition)
{
    3e2c:	b580      	push	{r7, lr}
    3e2e:	b08a      	sub	sp, #40	; 0x28
    3e30:	af00      	add	r7, sp, #0
    3e32:	60f8      	str	r0, [r7, #12]
    3e34:	60b9      	str	r1, [r7, #8]
    3e36:	607a      	str	r2, [r7, #4]
    3e38:	603b      	str	r3, [r7, #0]
	BaseType_t     xEntryTimeSet = pdFALSE, xYieldRequired;
    3e3a:	2300      	movs	r3, #0
    3e3c:	627b      	str	r3, [r7, #36]	; 0x24
	TimeOut_t      xTimeOut;
	Queue_t *const pxQueue = (Queue_t *)xQueue;
    3e3e:	68fb      	ldr	r3, [r7, #12]
    3e40:	623b      	str	r3, [r7, #32]

	configASSERT(pxQueue);
    3e42:	6a3b      	ldr	r3, [r7, #32]
    3e44:	2b00      	cmp	r3, #0
    3e46:	d101      	bne.n	3e4c <xQueueGenericSend+0x20>
    3e48:	b672      	cpsid	i
    3e4a:	e7fe      	b.n	3e4a <xQueueGenericSend+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    3e4c:	68bb      	ldr	r3, [r7, #8]
    3e4e:	2b00      	cmp	r3, #0
    3e50:	d103      	bne.n	3e5a <xQueueGenericSend+0x2e>
    3e52:	6a3b      	ldr	r3, [r7, #32]
    3e54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3e56:	2b00      	cmp	r3, #0
    3e58:	d101      	bne.n	3e5e <xQueueGenericSend+0x32>
    3e5a:	2301      	movs	r3, #1
    3e5c:	e000      	b.n	3e60 <xQueueGenericSend+0x34>
    3e5e:	2300      	movs	r3, #0
    3e60:	2b00      	cmp	r3, #0
    3e62:	d101      	bne.n	3e68 <xQueueGenericSend+0x3c>
    3e64:	b672      	cpsid	i
    3e66:	e7fe      	b.n	3e66 <xQueueGenericSend+0x3a>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    3e68:	683b      	ldr	r3, [r7, #0]
    3e6a:	2b02      	cmp	r3, #2
    3e6c:	d103      	bne.n	3e76 <xQueueGenericSend+0x4a>
    3e6e:	6a3b      	ldr	r3, [r7, #32]
    3e70:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3e72:	2b01      	cmp	r3, #1
    3e74:	d101      	bne.n	3e7a <xQueueGenericSend+0x4e>
    3e76:	2301      	movs	r3, #1
    3e78:	e000      	b.n	3e7c <xQueueGenericSend+0x50>
    3e7a:	2300      	movs	r3, #0
    3e7c:	2b00      	cmp	r3, #0
    3e7e:	d101      	bne.n	3e84 <xQueueGenericSend+0x58>
    3e80:	b672      	cpsid	i
    3e82:	e7fe      	b.n	3e82 <xQueueGenericSend+0x56>
#if ((INCLUDE_xTaskGetSchedulerState == 1) || (configUSE_TIMERS == 1))
	{
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    3e84:	4b53      	ldr	r3, [pc, #332]	; (3fd4 <xQueueGenericSend+0x1a8>)
    3e86:	4798      	blx	r3
    3e88:	1e03      	subs	r3, r0, #0
    3e8a:	d102      	bne.n	3e92 <xQueueGenericSend+0x66>
    3e8c:	687b      	ldr	r3, [r7, #4]
    3e8e:	2b00      	cmp	r3, #0
    3e90:	d101      	bne.n	3e96 <xQueueGenericSend+0x6a>
    3e92:	2301      	movs	r3, #1
    3e94:	e000      	b.n	3e98 <xQueueGenericSend+0x6c>
    3e96:	2300      	movs	r3, #0
    3e98:	2b00      	cmp	r3, #0
    3e9a:	d101      	bne.n	3ea0 <xQueueGenericSend+0x74>
    3e9c:	b672      	cpsid	i
    3e9e:	e7fe      	b.n	3e9e <xQueueGenericSend+0x72>

	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for (;;) {
		taskENTER_CRITICAL();
    3ea0:	4b4d      	ldr	r3, [pc, #308]	; (3fd8 <xQueueGenericSend+0x1ac>)
    3ea2:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    3ea4:	6a3b      	ldr	r3, [r7, #32]
    3ea6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3ea8:	6a3b      	ldr	r3, [r7, #32]
    3eaa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3eac:	429a      	cmp	r2, r3
    3eae:	d302      	bcc.n	3eb6 <xQueueGenericSend+0x8a>
    3eb0:	683b      	ldr	r3, [r7, #0]
    3eb2:	2b02      	cmp	r3, #2
    3eb4:	d12d      	bne.n	3f12 <xQueueGenericSend+0xe6>
				traceQUEUE_SEND(pxQueue);
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    3eb6:	683a      	ldr	r2, [r7, #0]
    3eb8:	68b9      	ldr	r1, [r7, #8]
    3eba:	6a3b      	ldr	r3, [r7, #32]
    3ebc:	0018      	movs	r0, r3
    3ebe:	4b47      	ldr	r3, [pc, #284]	; (3fdc <xQueueGenericSend+0x1b0>)
    3ec0:	4798      	blx	r3
    3ec2:	0003      	movs	r3, r0
    3ec4:	61fb      	str	r3, [r7, #28]

#if (configUSE_QUEUE_SETS == 1)
				{
					if (pxQueue->pxQueueSetContainer != NULL) {
    3ec6:	6a3b      	ldr	r3, [r7, #32]
    3ec8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3eca:	2b00      	cmp	r3, #0
    3ecc:	d00a      	beq.n	3ee4 <xQueueGenericSend+0xb8>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    3ece:	683a      	ldr	r2, [r7, #0]
    3ed0:	6a3b      	ldr	r3, [r7, #32]
    3ed2:	0011      	movs	r1, r2
    3ed4:	0018      	movs	r0, r3
    3ed6:	4b42      	ldr	r3, [pc, #264]	; (3fe0 <xQueueGenericSend+0x1b4>)
    3ed8:	4798      	blx	r3
    3eda:	1e03      	subs	r3, r0, #0
    3edc:	d015      	beq.n	3f0a <xQueueGenericSend+0xde>
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
    3ede:	4b41      	ldr	r3, [pc, #260]	; (3fe4 <xQueueGenericSend+0x1b8>)
    3ee0:	4798      	blx	r3
    3ee2:	e012      	b.n	3f0a <xQueueGenericSend+0xde>
							mtCOVERAGE_TEST_MARKER();
						}
					} else {
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    3ee4:	6a3b      	ldr	r3, [r7, #32]
    3ee6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3ee8:	2b00      	cmp	r3, #0
    3eea:	d009      	beq.n	3f00 <xQueueGenericSend+0xd4>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    3eec:	6a3b      	ldr	r3, [r7, #32]
    3eee:	3324      	adds	r3, #36	; 0x24
    3ef0:	0018      	movs	r0, r3
    3ef2:	4b3d      	ldr	r3, [pc, #244]	; (3fe8 <xQueueGenericSend+0x1bc>)
    3ef4:	4798      	blx	r3
    3ef6:	1e03      	subs	r3, r0, #0
    3ef8:	d007      	beq.n	3f0a <xQueueGenericSend+0xde>
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
    3efa:	4b3a      	ldr	r3, [pc, #232]	; (3fe4 <xQueueGenericSend+0x1b8>)
    3efc:	4798      	blx	r3
    3efe:	e004      	b.n	3f0a <xQueueGenericSend+0xde>
							} else {
								mtCOVERAGE_TEST_MARKER();
							}
						} else if (xYieldRequired != pdFALSE) {
    3f00:	69fb      	ldr	r3, [r7, #28]
    3f02:	2b00      	cmp	r3, #0
    3f04:	d001      	beq.n	3f0a <xQueueGenericSend+0xde>
							/* This path is a special case that will only get
							executed if the task was holding multiple mutexes
							and the mutexes were given back in an order that is
							different to that in which they were taken. */
							queueYIELD_IF_USING_PREEMPTION();
    3f06:	4b37      	ldr	r3, [pc, #220]	; (3fe4 <xQueueGenericSend+0x1b8>)
    3f08:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3f0a:	4b38      	ldr	r3, [pc, #224]	; (3fec <xQueueGenericSend+0x1c0>)
    3f0c:	4798      	blx	r3
				return pdPASS;
    3f0e:	2301      	movs	r3, #1
    3f10:	e05c      	b.n	3fcc <xQueueGenericSend+0x1a0>
			} else {
				if (xTicksToWait == (TickType_t)0) {
    3f12:	687b      	ldr	r3, [r7, #4]
    3f14:	2b00      	cmp	r3, #0
    3f16:	d103      	bne.n	3f20 <xQueueGenericSend+0xf4>
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3f18:	4b34      	ldr	r3, [pc, #208]	; (3fec <xQueueGenericSend+0x1c0>)
    3f1a:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED(pxQueue);
					return errQUEUE_FULL;
    3f1c:	2300      	movs	r3, #0
    3f1e:	e055      	b.n	3fcc <xQueueGenericSend+0x1a0>
				} else if (xEntryTimeSet == pdFALSE) {
    3f20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3f22:	2b00      	cmp	r3, #0
    3f24:	d106      	bne.n	3f34 <xQueueGenericSend+0x108>
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState(&xTimeOut);
    3f26:	2314      	movs	r3, #20
    3f28:	18fb      	adds	r3, r7, r3
    3f2a:	0018      	movs	r0, r3
    3f2c:	4b30      	ldr	r3, [pc, #192]	; (3ff0 <xQueueGenericSend+0x1c4>)
    3f2e:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    3f30:	2301      	movs	r3, #1
    3f32:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3f34:	4b2d      	ldr	r3, [pc, #180]	; (3fec <xQueueGenericSend+0x1c0>)
    3f36:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3f38:	4b2e      	ldr	r3, [pc, #184]	; (3ff4 <xQueueGenericSend+0x1c8>)
    3f3a:	4798      	blx	r3
		prvLockQueue(pxQueue);
    3f3c:	4b26      	ldr	r3, [pc, #152]	; (3fd8 <xQueueGenericSend+0x1ac>)
    3f3e:	4798      	blx	r3
    3f40:	6a3b      	ldr	r3, [r7, #32]
    3f42:	2244      	movs	r2, #68	; 0x44
    3f44:	5c9b      	ldrb	r3, [r3, r2]
    3f46:	b25b      	sxtb	r3, r3
    3f48:	3301      	adds	r3, #1
    3f4a:	d103      	bne.n	3f54 <xQueueGenericSend+0x128>
    3f4c:	6a3b      	ldr	r3, [r7, #32]
    3f4e:	2244      	movs	r2, #68	; 0x44
    3f50:	2100      	movs	r1, #0
    3f52:	5499      	strb	r1, [r3, r2]
    3f54:	6a3b      	ldr	r3, [r7, #32]
    3f56:	2245      	movs	r2, #69	; 0x45
    3f58:	5c9b      	ldrb	r3, [r3, r2]
    3f5a:	b25b      	sxtb	r3, r3
    3f5c:	3301      	adds	r3, #1
    3f5e:	d103      	bne.n	3f68 <xQueueGenericSend+0x13c>
    3f60:	6a3b      	ldr	r3, [r7, #32]
    3f62:	2245      	movs	r2, #69	; 0x45
    3f64:	2100      	movs	r1, #0
    3f66:	5499      	strb	r1, [r3, r2]
    3f68:	4b20      	ldr	r3, [pc, #128]	; (3fec <xQueueGenericSend+0x1c0>)
    3f6a:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    3f6c:	1d3a      	adds	r2, r7, #4
    3f6e:	2314      	movs	r3, #20
    3f70:	18fb      	adds	r3, r7, r3
    3f72:	0011      	movs	r1, r2
    3f74:	0018      	movs	r0, r3
    3f76:	4b20      	ldr	r3, [pc, #128]	; (3ff8 <xQueueGenericSend+0x1cc>)
    3f78:	4798      	blx	r3
    3f7a:	1e03      	subs	r3, r0, #0
    3f7c:	d11f      	bne.n	3fbe <xQueueGenericSend+0x192>
			if (prvIsQueueFull(pxQueue) != pdFALSE) {
    3f7e:	6a3b      	ldr	r3, [r7, #32]
    3f80:	0018      	movs	r0, r3
    3f82:	4b1e      	ldr	r3, [pc, #120]	; (3ffc <xQueueGenericSend+0x1d0>)
    3f84:	4798      	blx	r3
    3f86:	1e03      	subs	r3, r0, #0
    3f88:	d012      	beq.n	3fb0 <xQueueGenericSend+0x184>
				traceBLOCKING_ON_QUEUE_SEND(pxQueue);
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    3f8a:	6a3b      	ldr	r3, [r7, #32]
    3f8c:	3310      	adds	r3, #16
    3f8e:	687a      	ldr	r2, [r7, #4]
    3f90:	0011      	movs	r1, r2
    3f92:	0018      	movs	r0, r3
    3f94:	4b1a      	ldr	r3, [pc, #104]	; (4000 <xQueueGenericSend+0x1d4>)
    3f96:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue(pxQueue);
    3f98:	6a3b      	ldr	r3, [r7, #32]
    3f9a:	0018      	movs	r0, r3
    3f9c:	4b19      	ldr	r3, [pc, #100]	; (4004 <xQueueGenericSend+0x1d8>)
    3f9e:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if (xTaskResumeAll() == pdFALSE) {
    3fa0:	4b19      	ldr	r3, [pc, #100]	; (4008 <xQueueGenericSend+0x1dc>)
    3fa2:	4798      	blx	r3
    3fa4:	1e03      	subs	r3, r0, #0
    3fa6:	d000      	beq.n	3faa <xQueueGenericSend+0x17e>
    3fa8:	e77a      	b.n	3ea0 <xQueueGenericSend+0x74>
					portYIELD_WITHIN_API();
    3faa:	4b0e      	ldr	r3, [pc, #56]	; (3fe4 <xQueueGenericSend+0x1b8>)
    3fac:	4798      	blx	r3
    3fae:	e777      	b.n	3ea0 <xQueueGenericSend+0x74>
				}
			} else {
				/* Try again. */
				prvUnlockQueue(pxQueue);
    3fb0:	6a3b      	ldr	r3, [r7, #32]
    3fb2:	0018      	movs	r0, r3
    3fb4:	4b13      	ldr	r3, [pc, #76]	; (4004 <xQueueGenericSend+0x1d8>)
    3fb6:	4798      	blx	r3
				(void)xTaskResumeAll();
    3fb8:	4b13      	ldr	r3, [pc, #76]	; (4008 <xQueueGenericSend+0x1dc>)
    3fba:	4798      	blx	r3
    3fbc:	e770      	b.n	3ea0 <xQueueGenericSend+0x74>
			}
		} else {
			/* The timeout has expired. */
			prvUnlockQueue(pxQueue);
    3fbe:	6a3b      	ldr	r3, [r7, #32]
    3fc0:	0018      	movs	r0, r3
    3fc2:	4b10      	ldr	r3, [pc, #64]	; (4004 <xQueueGenericSend+0x1d8>)
    3fc4:	4798      	blx	r3
			(void)xTaskResumeAll();
    3fc6:	4b10      	ldr	r3, [pc, #64]	; (4008 <xQueueGenericSend+0x1dc>)
    3fc8:	4798      	blx	r3

			traceQUEUE_SEND_FAILED(pxQueue);
			return errQUEUE_FULL;
    3fca:	2300      	movs	r3, #0
		}
	}
}
    3fcc:	0018      	movs	r0, r3
    3fce:	46bd      	mov	sp, r7
    3fd0:	b00a      	add	sp, #40	; 0x28
    3fd2:	bd80      	pop	{r7, pc}
    3fd4:	0000510d 	.word	0x0000510d
    3fd8:	00003ad1 	.word	0x00003ad1
    3fdc:	000042cd 	.word	0x000042cd
    3fe0:	000045ad 	.word	0x000045ad
    3fe4:	00003ab1 	.word	0x00003ab1
    3fe8:	00004dd5 	.word	0x00004dd5
    3fec:	00003af5 	.word	0x00003af5
    3ff0:	00004e95 	.word	0x00004e95
    3ff4:	000049bd 	.word	0x000049bd
    3ff8:	00004ebd 	.word	0x00004ebd
    3ffc:	000044fd 	.word	0x000044fd
    4000:	00004d3d 	.word	0x00004d3d
    4004:	000043d9 	.word	0x000043d9
    4008:	000049d5 	.word	0x000049d5

0000400c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void *const pvItemToQueue,
                                    BaseType_t *const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition)
{
    400c:	b580      	push	{r7, lr}
    400e:	b088      	sub	sp, #32
    4010:	af00      	add	r7, sp, #0
    4012:	60f8      	str	r0, [r7, #12]
    4014:	60b9      	str	r1, [r7, #8]
    4016:	607a      	str	r2, [r7, #4]
    4018:	603b      	str	r3, [r7, #0]
	BaseType_t     xReturn;
	UBaseType_t    uxSavedInterruptStatus;
	Queue_t *const pxQueue = (Queue_t *)xQueue;
    401a:	68fb      	ldr	r3, [r7, #12]
    401c:	61bb      	str	r3, [r7, #24]

	configASSERT(pxQueue);
    401e:	69bb      	ldr	r3, [r7, #24]
    4020:	2b00      	cmp	r3, #0
    4022:	d101      	bne.n	4028 <xQueueGenericSendFromISR+0x1c>
    4024:	b672      	cpsid	i
    4026:	e7fe      	b.n	4026 <xQueueGenericSendFromISR+0x1a>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    4028:	68bb      	ldr	r3, [r7, #8]
    402a:	2b00      	cmp	r3, #0
    402c:	d103      	bne.n	4036 <xQueueGenericSendFromISR+0x2a>
    402e:	69bb      	ldr	r3, [r7, #24]
    4030:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4032:	2b00      	cmp	r3, #0
    4034:	d101      	bne.n	403a <xQueueGenericSendFromISR+0x2e>
    4036:	2301      	movs	r3, #1
    4038:	e000      	b.n	403c <xQueueGenericSendFromISR+0x30>
    403a:	2300      	movs	r3, #0
    403c:	2b00      	cmp	r3, #0
    403e:	d101      	bne.n	4044 <xQueueGenericSendFromISR+0x38>
    4040:	b672      	cpsid	i
    4042:	e7fe      	b.n	4042 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    4044:	683b      	ldr	r3, [r7, #0]
    4046:	2b02      	cmp	r3, #2
    4048:	d103      	bne.n	4052 <xQueueGenericSendFromISR+0x46>
    404a:	69bb      	ldr	r3, [r7, #24]
    404c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    404e:	2b01      	cmp	r3, #1
    4050:	d101      	bne.n	4056 <xQueueGenericSendFromISR+0x4a>
    4052:	2301      	movs	r3, #1
    4054:	e000      	b.n	4058 <xQueueGenericSendFromISR+0x4c>
    4056:	2300      	movs	r3, #0
    4058:	2b00      	cmp	r3, #0
    405a:	d101      	bne.n	4060 <xQueueGenericSendFromISR+0x54>
    405c:	b672      	cpsid	i
    405e:	e7fe      	b.n	405e <xQueueGenericSendFromISR+0x52>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4060:	4b2d      	ldr	r3, [pc, #180]	; (4118 <xQueueGenericSendFromISR+0x10c>)
    4062:	4798      	blx	r3
    4064:	0003      	movs	r3, r0
    4066:	617b      	str	r3, [r7, #20]
	{
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    4068:	69bb      	ldr	r3, [r7, #24]
    406a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    406c:	69bb      	ldr	r3, [r7, #24]
    406e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4070:	429a      	cmp	r2, r3
    4072:	d302      	bcc.n	407a <xQueueGenericSendFromISR+0x6e>
    4074:	683b      	ldr	r3, [r7, #0]
    4076:	2b02      	cmp	r3, #2
    4078:	d142      	bne.n	4100 <xQueueGenericSendFromISR+0xf4>
			const int8_t cTxLock = pxQueue->cTxLock;
    407a:	2313      	movs	r3, #19
    407c:	18fb      	adds	r3, r7, r3
    407e:	69ba      	ldr	r2, [r7, #24]
    4080:	2145      	movs	r1, #69	; 0x45
    4082:	5c52      	ldrb	r2, [r2, r1]
    4084:	701a      	strb	r2, [r3, #0]
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    4086:	683a      	ldr	r2, [r7, #0]
    4088:	68b9      	ldr	r1, [r7, #8]
    408a:	69bb      	ldr	r3, [r7, #24]
    408c:	0018      	movs	r0, r3
    408e:	4b23      	ldr	r3, [pc, #140]	; (411c <xQueueGenericSendFromISR+0x110>)
    4090:	4798      	blx	r3

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if (cTxLock == queueUNLOCKED) {
    4092:	2313      	movs	r3, #19
    4094:	18fb      	adds	r3, r7, r3
    4096:	781b      	ldrb	r3, [r3, #0]
    4098:	b25b      	sxtb	r3, r3
    409a:	3301      	adds	r3, #1
    409c:	d124      	bne.n	40e8 <xQueueGenericSendFromISR+0xdc>
#if (configUSE_QUEUE_SETS == 1)
				{
					if (pxQueue->pxQueueSetContainer != NULL) {
    409e:	69bb      	ldr	r3, [r7, #24]
    40a0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    40a2:	2b00      	cmp	r3, #0
    40a4:	d00e      	beq.n	40c4 <xQueueGenericSendFromISR+0xb8>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    40a6:	683a      	ldr	r2, [r7, #0]
    40a8:	69bb      	ldr	r3, [r7, #24]
    40aa:	0011      	movs	r1, r2
    40ac:	0018      	movs	r0, r3
    40ae:	4b1c      	ldr	r3, [pc, #112]	; (4120 <xQueueGenericSendFromISR+0x114>)
    40b0:	4798      	blx	r3
    40b2:	1e03      	subs	r3, r0, #0
    40b4:	d021      	beq.n	40fa <xQueueGenericSendFromISR+0xee>
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if (pxHigherPriorityTaskWoken != NULL) {
    40b6:	687b      	ldr	r3, [r7, #4]
    40b8:	2b00      	cmp	r3, #0
    40ba:	d01e      	beq.n	40fa <xQueueGenericSendFromISR+0xee>
								*pxHigherPriorityTaskWoken = pdTRUE;
    40bc:	687b      	ldr	r3, [r7, #4]
    40be:	2201      	movs	r2, #1
    40c0:	601a      	str	r2, [r3, #0]
    40c2:	e01a      	b.n	40fa <xQueueGenericSendFromISR+0xee>
							}
						} else {
							mtCOVERAGE_TEST_MARKER();
						}
					} else {
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    40c4:	69bb      	ldr	r3, [r7, #24]
    40c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    40c8:	2b00      	cmp	r3, #0
    40ca:	d016      	beq.n	40fa <xQueueGenericSendFromISR+0xee>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    40cc:	69bb      	ldr	r3, [r7, #24]
    40ce:	3324      	adds	r3, #36	; 0x24
    40d0:	0018      	movs	r0, r3
    40d2:	4b14      	ldr	r3, [pc, #80]	; (4124 <xQueueGenericSendFromISR+0x118>)
    40d4:	4798      	blx	r3
    40d6:	1e03      	subs	r3, r0, #0
    40d8:	d00f      	beq.n	40fa <xQueueGenericSendFromISR+0xee>
								/* The task waiting has a higher priority so
								record that a context switch is required. */
								if (pxHigherPriorityTaskWoken != NULL) {
    40da:	687b      	ldr	r3, [r7, #4]
    40dc:	2b00      	cmp	r3, #0
    40de:	d00c      	beq.n	40fa <xQueueGenericSendFromISR+0xee>
									*pxHigherPriorityTaskWoken = pdTRUE;
    40e0:	687b      	ldr	r3, [r7, #4]
    40e2:	2201      	movs	r2, #1
    40e4:	601a      	str	r2, [r3, #0]
    40e6:	e008      	b.n	40fa <xQueueGenericSendFromISR+0xee>
				}
#endif /* configUSE_QUEUE_SETS */
			} else {
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    40e8:	2313      	movs	r3, #19
    40ea:	18fb      	adds	r3, r7, r3
    40ec:	781b      	ldrb	r3, [r3, #0]
    40ee:	3301      	adds	r3, #1
    40f0:	b2db      	uxtb	r3, r3
    40f2:	b259      	sxtb	r1, r3
    40f4:	69bb      	ldr	r3, [r7, #24]
    40f6:	2245      	movs	r2, #69	; 0x45
    40f8:	5499      	strb	r1, [r3, r2]
			}

			xReturn = pdPASS;
    40fa:	2301      	movs	r3, #1
    40fc:	61fb      	str	r3, [r7, #28]
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    40fe:	e001      	b.n	4104 <xQueueGenericSendFromISR+0xf8>
		} else {
			traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue);
			xReturn = errQUEUE_FULL;
    4100:	2300      	movs	r3, #0
    4102:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
    4104:	697b      	ldr	r3, [r7, #20]
    4106:	0018      	movs	r0, r3
    4108:	4b07      	ldr	r3, [pc, #28]	; (4128 <xQueueGenericSendFromISR+0x11c>)
    410a:	4798      	blx	r3

	return xReturn;
    410c:	69fb      	ldr	r3, [r7, #28]
}
    410e:	0018      	movs	r0, r3
    4110:	46bd      	mov	sp, r7
    4112:	b008      	add	sp, #32
    4114:	bd80      	pop	{r7, pc}
    4116:	46c0      	nop			; (mov r8, r8)
    4118:	00003b25 	.word	0x00003b25
    411c:	000042cd 	.word	0x000042cd
    4120:	000045ad 	.word	0x000045ad
    4124:	00004dd5 	.word	0x00004dd5
    4128:	00003b31 	.word	0x00003b31

0000412c <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive(QueueHandle_t xQueue, void *const pvBuffer, TickType_t xTicksToWait)
{
    412c:	b580      	push	{r7, lr}
    412e:	b08a      	sub	sp, #40	; 0x28
    4130:	af00      	add	r7, sp, #0
    4132:	60f8      	str	r0, [r7, #12]
    4134:	60b9      	str	r1, [r7, #8]
    4136:	607a      	str	r2, [r7, #4]
	BaseType_t     xEntryTimeSet = pdFALSE;
    4138:	2300      	movs	r3, #0
    413a:	627b      	str	r3, [r7, #36]	; 0x24
	TimeOut_t      xTimeOut;
	Queue_t *const pxQueue = (Queue_t *)xQueue;
    413c:	68fb      	ldr	r3, [r7, #12]
    413e:	623b      	str	r3, [r7, #32]

	/* Check the pointer is not NULL. */
	configASSERT((pxQueue));
    4140:	6a3b      	ldr	r3, [r7, #32]
    4142:	2b00      	cmp	r3, #0
    4144:	d101      	bne.n	414a <xQueueReceive+0x1e>
    4146:	b672      	cpsid	i
    4148:	e7fe      	b.n	4148 <xQueueReceive+0x1c>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    414a:	68bb      	ldr	r3, [r7, #8]
    414c:	2b00      	cmp	r3, #0
    414e:	d103      	bne.n	4158 <xQueueReceive+0x2c>
    4150:	6a3b      	ldr	r3, [r7, #32]
    4152:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4154:	2b00      	cmp	r3, #0
    4156:	d101      	bne.n	415c <xQueueReceive+0x30>
    4158:	2301      	movs	r3, #1
    415a:	e000      	b.n	415e <xQueueReceive+0x32>
    415c:	2300      	movs	r3, #0
    415e:	2b00      	cmp	r3, #0
    4160:	d101      	bne.n	4166 <xQueueReceive+0x3a>
    4162:	b672      	cpsid	i
    4164:	e7fe      	b.n	4164 <xQueueReceive+0x38>

/* Cannot block if the scheduler is suspended. */
#if ((INCLUDE_xTaskGetSchedulerState == 1) || (configUSE_TIMERS == 1))
	{
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    4166:	4b4c      	ldr	r3, [pc, #304]	; (4298 <xQueueReceive+0x16c>)
    4168:	4798      	blx	r3
    416a:	1e03      	subs	r3, r0, #0
    416c:	d102      	bne.n	4174 <xQueueReceive+0x48>
    416e:	687b      	ldr	r3, [r7, #4]
    4170:	2b00      	cmp	r3, #0
    4172:	d101      	bne.n	4178 <xQueueReceive+0x4c>
    4174:	2301      	movs	r3, #1
    4176:	e000      	b.n	417a <xQueueReceive+0x4e>
    4178:	2300      	movs	r3, #0
    417a:	2b00      	cmp	r3, #0
    417c:	d101      	bne.n	4182 <xQueueReceive+0x56>
    417e:	b672      	cpsid	i
    4180:	e7fe      	b.n	4180 <xQueueReceive+0x54>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for (;;) {
		taskENTER_CRITICAL();
    4182:	4b46      	ldr	r3, [pc, #280]	; (429c <xQueueReceive+0x170>)
    4184:	4798      	blx	r3
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4186:	6a3b      	ldr	r3, [r7, #32]
    4188:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    418a:	61fb      	str	r3, [r7, #28]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if (uxMessagesWaiting > (UBaseType_t)0) {
    418c:	69fb      	ldr	r3, [r7, #28]
    418e:	2b00      	cmp	r3, #0
    4190:	d01a      	beq.n	41c8 <xQueueReceive+0x9c>
				/* Data available, remove one item. */
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    4192:	68ba      	ldr	r2, [r7, #8]
    4194:	6a3b      	ldr	r3, [r7, #32]
    4196:	0011      	movs	r1, r2
    4198:	0018      	movs	r0, r3
    419a:	4b41      	ldr	r3, [pc, #260]	; (42a0 <xQueueReceive+0x174>)
    419c:	4798      	blx	r3
				traceQUEUE_RECEIVE(pxQueue);
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    419e:	69fb      	ldr	r3, [r7, #28]
    41a0:	1e5a      	subs	r2, r3, #1
    41a2:	6a3b      	ldr	r3, [r7, #32]
    41a4:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    41a6:	6a3b      	ldr	r3, [r7, #32]
    41a8:	691b      	ldr	r3, [r3, #16]
    41aa:	2b00      	cmp	r3, #0
    41ac:	d008      	beq.n	41c0 <xQueueReceive+0x94>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    41ae:	6a3b      	ldr	r3, [r7, #32]
    41b0:	3310      	adds	r3, #16
    41b2:	0018      	movs	r0, r3
    41b4:	4b3b      	ldr	r3, [pc, #236]	; (42a4 <xQueueReceive+0x178>)
    41b6:	4798      	blx	r3
    41b8:	1e03      	subs	r3, r0, #0
    41ba:	d001      	beq.n	41c0 <xQueueReceive+0x94>
						queueYIELD_IF_USING_PREEMPTION();
    41bc:	4b3a      	ldr	r3, [pc, #232]	; (42a8 <xQueueReceive+0x17c>)
    41be:	4798      	blx	r3
					}
				} else {
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    41c0:	4b3a      	ldr	r3, [pc, #232]	; (42ac <xQueueReceive+0x180>)
    41c2:	4798      	blx	r3
				return pdPASS;
    41c4:	2301      	movs	r3, #1
    41c6:	e062      	b.n	428e <xQueueReceive+0x162>
			} else {
				if (xTicksToWait == (TickType_t)0) {
    41c8:	687b      	ldr	r3, [r7, #4]
    41ca:	2b00      	cmp	r3, #0
    41cc:	d103      	bne.n	41d6 <xQueueReceive+0xaa>
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    41ce:	4b37      	ldr	r3, [pc, #220]	; (42ac <xQueueReceive+0x180>)
    41d0:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED(pxQueue);
					return errQUEUE_EMPTY;
    41d2:	2300      	movs	r3, #0
    41d4:	e05b      	b.n	428e <xQueueReceive+0x162>
				} else if (xEntryTimeSet == pdFALSE) {
    41d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    41d8:	2b00      	cmp	r3, #0
    41da:	d106      	bne.n	41ea <xQueueReceive+0xbe>
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState(&xTimeOut);
    41dc:	2314      	movs	r3, #20
    41de:	18fb      	adds	r3, r7, r3
    41e0:	0018      	movs	r0, r3
    41e2:	4b33      	ldr	r3, [pc, #204]	; (42b0 <xQueueReceive+0x184>)
    41e4:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    41e6:	2301      	movs	r3, #1
    41e8:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    41ea:	4b30      	ldr	r3, [pc, #192]	; (42ac <xQueueReceive+0x180>)
    41ec:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    41ee:	4b31      	ldr	r3, [pc, #196]	; (42b4 <xQueueReceive+0x188>)
    41f0:	4798      	blx	r3
		prvLockQueue(pxQueue);
    41f2:	4b2a      	ldr	r3, [pc, #168]	; (429c <xQueueReceive+0x170>)
    41f4:	4798      	blx	r3
    41f6:	6a3b      	ldr	r3, [r7, #32]
    41f8:	2244      	movs	r2, #68	; 0x44
    41fa:	5c9b      	ldrb	r3, [r3, r2]
    41fc:	b25b      	sxtb	r3, r3
    41fe:	3301      	adds	r3, #1
    4200:	d103      	bne.n	420a <xQueueReceive+0xde>
    4202:	6a3b      	ldr	r3, [r7, #32]
    4204:	2244      	movs	r2, #68	; 0x44
    4206:	2100      	movs	r1, #0
    4208:	5499      	strb	r1, [r3, r2]
    420a:	6a3b      	ldr	r3, [r7, #32]
    420c:	2245      	movs	r2, #69	; 0x45
    420e:	5c9b      	ldrb	r3, [r3, r2]
    4210:	b25b      	sxtb	r3, r3
    4212:	3301      	adds	r3, #1
    4214:	d103      	bne.n	421e <xQueueReceive+0xf2>
    4216:	6a3b      	ldr	r3, [r7, #32]
    4218:	2245      	movs	r2, #69	; 0x45
    421a:	2100      	movs	r1, #0
    421c:	5499      	strb	r1, [r3, r2]
    421e:	4b23      	ldr	r3, [pc, #140]	; (42ac <xQueueReceive+0x180>)
    4220:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    4222:	1d3a      	adds	r2, r7, #4
    4224:	2314      	movs	r3, #20
    4226:	18fb      	adds	r3, r7, r3
    4228:	0011      	movs	r1, r2
    422a:	0018      	movs	r0, r3
    422c:	4b22      	ldr	r3, [pc, #136]	; (42b8 <xQueueReceive+0x18c>)
    422e:	4798      	blx	r3
    4230:	1e03      	subs	r3, r0, #0
    4232:	d11e      	bne.n	4272 <xQueueReceive+0x146>
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    4234:	6a3b      	ldr	r3, [r7, #32]
    4236:	0018      	movs	r0, r3
    4238:	4b20      	ldr	r3, [pc, #128]	; (42bc <xQueueReceive+0x190>)
    423a:	4798      	blx	r3
    423c:	1e03      	subs	r3, r0, #0
    423e:	d011      	beq.n	4264 <xQueueReceive+0x138>
				traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue);
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    4240:	6a3b      	ldr	r3, [r7, #32]
    4242:	3324      	adds	r3, #36	; 0x24
    4244:	687a      	ldr	r2, [r7, #4]
    4246:	0011      	movs	r1, r2
    4248:	0018      	movs	r0, r3
    424a:	4b1d      	ldr	r3, [pc, #116]	; (42c0 <xQueueReceive+0x194>)
    424c:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    424e:	6a3b      	ldr	r3, [r7, #32]
    4250:	0018      	movs	r0, r3
    4252:	4b1c      	ldr	r3, [pc, #112]	; (42c4 <xQueueReceive+0x198>)
    4254:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    4256:	4b1c      	ldr	r3, [pc, #112]	; (42c8 <xQueueReceive+0x19c>)
    4258:	4798      	blx	r3
    425a:	1e03      	subs	r3, r0, #0
    425c:	d191      	bne.n	4182 <xQueueReceive+0x56>
					portYIELD_WITHIN_API();
    425e:	4b12      	ldr	r3, [pc, #72]	; (42a8 <xQueueReceive+0x17c>)
    4260:	4798      	blx	r3
    4262:	e78e      	b.n	4182 <xQueueReceive+0x56>
					mtCOVERAGE_TEST_MARKER();
				}
			} else {
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue(pxQueue);
    4264:	6a3b      	ldr	r3, [r7, #32]
    4266:	0018      	movs	r0, r3
    4268:	4b16      	ldr	r3, [pc, #88]	; (42c4 <xQueueReceive+0x198>)
    426a:	4798      	blx	r3
				(void)xTaskResumeAll();
    426c:	4b16      	ldr	r3, [pc, #88]	; (42c8 <xQueueReceive+0x19c>)
    426e:	4798      	blx	r3
    4270:	e787      	b.n	4182 <xQueueReceive+0x56>
			}
		} else {
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue(pxQueue);
    4272:	6a3b      	ldr	r3, [r7, #32]
    4274:	0018      	movs	r0, r3
    4276:	4b13      	ldr	r3, [pc, #76]	; (42c4 <xQueueReceive+0x198>)
    4278:	4798      	blx	r3
			(void)xTaskResumeAll();
    427a:	4b13      	ldr	r3, [pc, #76]	; (42c8 <xQueueReceive+0x19c>)
    427c:	4798      	blx	r3

			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    427e:	6a3b      	ldr	r3, [r7, #32]
    4280:	0018      	movs	r0, r3
    4282:	4b0e      	ldr	r3, [pc, #56]	; (42bc <xQueueReceive+0x190>)
    4284:	4798      	blx	r3
    4286:	1e03      	subs	r3, r0, #0
    4288:	d100      	bne.n	428c <xQueueReceive+0x160>
    428a:	e77a      	b.n	4182 <xQueueReceive+0x56>
				traceQUEUE_RECEIVE_FAILED(pxQueue);
				return errQUEUE_EMPTY;
    428c:	2300      	movs	r3, #0
			} else {
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    428e:	0018      	movs	r0, r3
    4290:	46bd      	mov	sp, r7
    4292:	b00a      	add	sp, #40	; 0x28
    4294:	bd80      	pop	{r7, pc}
    4296:	46c0      	nop			; (mov r8, r8)
    4298:	0000510d 	.word	0x0000510d
    429c:	00003ad1 	.word	0x00003ad1
    42a0:	00004389 	.word	0x00004389
    42a4:	00004dd5 	.word	0x00004dd5
    42a8:	00003ab1 	.word	0x00003ab1
    42ac:	00003af5 	.word	0x00003af5
    42b0:	00004e95 	.word	0x00004e95
    42b4:	000049bd 	.word	0x000049bd
    42b8:	00004ebd 	.word	0x00004ebd
    42bc:	000044c9 	.word	0x000044c9
    42c0:	00004d3d 	.word	0x00004d3d
    42c4:	000043d9 	.word	0x000043d9
    42c8:	000049d5 	.word	0x000049d5

000042cc <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue(Queue_t *const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition)
{
    42cc:	b580      	push	{r7, lr}
    42ce:	b086      	sub	sp, #24
    42d0:	af00      	add	r7, sp, #0
    42d2:	60f8      	str	r0, [r7, #12]
    42d4:	60b9      	str	r1, [r7, #8]
    42d6:	607a      	str	r2, [r7, #4]
	BaseType_t  xReturn = pdFALSE;
    42d8:	2300      	movs	r3, #0
    42da:	613b      	str	r3, [r7, #16]
	UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    42dc:	68fb      	ldr	r3, [r7, #12]
    42de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    42e0:	617b      	str	r3, [r7, #20]

	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    42e2:	68fb      	ldr	r3, [r7, #12]
    42e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    42e6:	2b00      	cmp	r3, #0
    42e8:	d043      	beq.n	4372 <prvCopyDataToQueue+0xa6>
			} else {
				mtCOVERAGE_TEST_MARKER();
			}
		}
#endif /* configUSE_MUTEXES */
	} else if (xPosition == queueSEND_TO_BACK) {
    42ea:	687b      	ldr	r3, [r7, #4]
    42ec:	2b00      	cmp	r3, #0
    42ee:	d119      	bne.n	4324 <prvCopyDataToQueue+0x58>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    42f0:	68fb      	ldr	r3, [r7, #12]
    42f2:	6898      	ldr	r0, [r3, #8]
		             pvItemToQueue,
		             (size_t)pxQueue->uxItemSize); /*lint !e961 !e418 MISRA exception as the casts are only redundant
    42f4:	68fb      	ldr	r3, [r7, #12]
    42f6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
		(void)memcpy((void *)pxQueue->pcWriteTo,
    42f8:	68bb      	ldr	r3, [r7, #8]
    42fa:	0019      	movs	r1, r3
    42fc:	4b21      	ldr	r3, [pc, #132]	; (4384 <prvCopyDataToQueue+0xb8>)
    42fe:	4798      	blx	r3
		                                              for some ports, plus previous logic ensures a null pointer can
		                                              only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4300:	68fb      	ldr	r3, [r7, #12]
    4302:	689a      	ldr	r2, [r3, #8]
    4304:	68fb      	ldr	r3, [r7, #12]
    4306:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4308:	18d2      	adds	r2, r2, r3
    430a:	68fb      	ldr	r3, [r7, #12]
    430c:	609a      	str	r2, [r3, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    430e:	68fb      	ldr	r3, [r7, #12]
    4310:	689a      	ldr	r2, [r3, #8]
    4312:	68fb      	ldr	r3, [r7, #12]
    4314:	685b      	ldr	r3, [r3, #4]
    4316:	429a      	cmp	r2, r3
    4318:	d32b      	bcc.n	4372 <prvCopyDataToQueue+0xa6>
		                                              the cleanest solution. */
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    431a:	68fb      	ldr	r3, [r7, #12]
    431c:	681a      	ldr	r2, [r3, #0]
    431e:	68fb      	ldr	r3, [r7, #12]
    4320:	609a      	str	r2, [r3, #8]
    4322:	e026      	b.n	4372 <prvCopyDataToQueue+0xa6>
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	} else {
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    4324:	68fb      	ldr	r3, [r7, #12]
    4326:	68d8      	ldr	r0, [r3, #12]
		             pvItemToQueue,
		             (size_t)pxQueue
		                 ->uxItemSize); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4328:	68fb      	ldr	r3, [r7, #12]
    432a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    432c:	68bb      	ldr	r3, [r7, #8]
    432e:	0019      	movs	r1, r3
    4330:	4b14      	ldr	r3, [pc, #80]	; (4384 <prvCopyDataToQueue+0xb8>)
    4332:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    4334:	68fb      	ldr	r3, [r7, #12]
    4336:	68da      	ldr	r2, [r3, #12]
    4338:	68fb      	ldr	r3, [r7, #12]
    433a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    433c:	425b      	negs	r3, r3
    433e:	18d2      	adds	r2, r2, r3
    4340:	68fb      	ldr	r3, [r7, #12]
    4342:	60da      	str	r2, [r3, #12]
		if (pxQueue->u.pcReadFrom
    4344:	68fb      	ldr	r3, [r7, #12]
    4346:	68da      	ldr	r2, [r3, #12]
		    < pxQueue->pcHead) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest
    4348:	68fb      	ldr	r3, [r7, #12]
    434a:	681b      	ldr	r3, [r3, #0]
		if (pxQueue->u.pcReadFrom
    434c:	429a      	cmp	r2, r3
    434e:	d207      	bcs.n	4360 <prvCopyDataToQueue+0x94>
		                          solution. */
		{
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    4350:	68fb      	ldr	r3, [r7, #12]
    4352:	685a      	ldr	r2, [r3, #4]
    4354:	68fb      	ldr	r3, [r7, #12]
    4356:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4358:	425b      	negs	r3, r3
    435a:	18d2      	adds	r2, r2, r3
    435c:	68fb      	ldr	r3, [r7, #12]
    435e:	60da      	str	r2, [r3, #12]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}

		if (xPosition == queueOVERWRITE) {
    4360:	687b      	ldr	r3, [r7, #4]
    4362:	2b02      	cmp	r3, #2
    4364:	d105      	bne.n	4372 <prvCopyDataToQueue+0xa6>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    4366:	697b      	ldr	r3, [r7, #20]
    4368:	2b00      	cmp	r3, #0
    436a:	d002      	beq.n	4372 <prvCopyDataToQueue+0xa6>
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    436c:	697b      	ldr	r3, [r7, #20]
    436e:	3b01      	subs	r3, #1
    4370:	617b      	str	r3, [r7, #20]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    4372:	697b      	ldr	r3, [r7, #20]
    4374:	1c5a      	adds	r2, r3, #1
    4376:	68fb      	ldr	r3, [r7, #12]
    4378:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
    437a:	693b      	ldr	r3, [r7, #16]
}
    437c:	0018      	movs	r0, r3
    437e:	46bd      	mov	sp, r7
    4380:	b006      	add	sp, #24
    4382:	bd80      	pop	{r7, pc}
    4384:	00005db9 	.word	0x00005db9

00004388 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue(Queue_t *const pxQueue, void *const pvBuffer)
{
    4388:	b580      	push	{r7, lr}
    438a:	b082      	sub	sp, #8
    438c:	af00      	add	r7, sp, #0
    438e:	6078      	str	r0, [r7, #4]
    4390:	6039      	str	r1, [r7, #0]
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    4392:	687b      	ldr	r3, [r7, #4]
    4394:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4396:	2b00      	cmp	r3, #0
    4398:	d018      	beq.n	43cc <prvCopyDataFromQueue+0x44>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    439a:	687b      	ldr	r3, [r7, #4]
    439c:	68da      	ldr	r2, [r3, #12]
    439e:	687b      	ldr	r3, [r7, #4]
    43a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    43a2:	18d2      	adds	r2, r2, r3
    43a4:	687b      	ldr	r3, [r7, #4]
    43a6:	60da      	str	r2, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    43a8:	687b      	ldr	r3, [r7, #4]
    43aa:	68da      	ldr	r2, [r3, #12]
    43ac:	687b      	ldr	r3, [r7, #4]
    43ae:	685b      	ldr	r3, [r3, #4]
    43b0:	429a      	cmp	r2, r3
    43b2:	d303      	bcc.n	43bc <prvCopyDataFromQueue+0x34>
		                                                 operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    43b4:	687b      	ldr	r3, [r7, #4]
    43b6:	681a      	ldr	r2, [r3, #0]
    43b8:	687b      	ldr	r3, [r7, #4]
    43ba:	60da      	str	r2, [r3, #12]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
		(void)memcpy((void *)pvBuffer,
		             (void *)pxQueue->u.pcReadFrom,
    43bc:	687b      	ldr	r3, [r7, #4]
    43be:	68d9      	ldr	r1, [r3, #12]
		             (size_t)pxQueue->uxItemSize); /*lint !e961 !e418 MISRA exception as the casts are only redundant
    43c0:	687b      	ldr	r3, [r7, #4]
    43c2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
		(void)memcpy((void *)pvBuffer,
    43c4:	683b      	ldr	r3, [r7, #0]
    43c6:	0018      	movs	r0, r3
    43c8:	4b02      	ldr	r3, [pc, #8]	; (43d4 <prvCopyDataFromQueue+0x4c>)
    43ca:	4798      	blx	r3
		                                              for some ports.  Also previous logic ensures a null pointer can
		                                              only be passed to memcpy() when the count is 0. */
	}
}
    43cc:	46c0      	nop			; (mov r8, r8)
    43ce:	46bd      	mov	sp, r7
    43d0:	b002      	add	sp, #8
    43d2:	bd80      	pop	{r7, pc}
    43d4:	00005db9 	.word	0x00005db9

000043d8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue(Queue_t *const pxQueue)
{
    43d8:	b580      	push	{r7, lr}
    43da:	b084      	sub	sp, #16
    43dc:	af00      	add	r7, sp, #0
    43de:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    43e0:	4b34      	ldr	r3, [pc, #208]	; (44b4 <prvUnlockQueue+0xdc>)
    43e2:	4798      	blx	r3
	{
		int8_t cTxLock = pxQueue->cTxLock;
    43e4:	230f      	movs	r3, #15
    43e6:	18fb      	adds	r3, r7, r3
    43e8:	687a      	ldr	r2, [r7, #4]
    43ea:	2145      	movs	r1, #69	; 0x45
    43ec:	5c52      	ldrb	r2, [r2, r1]
    43ee:	701a      	strb	r2, [r3, #0]

		/* See if data was added to the queue while it was locked. */
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    43f0:	e022      	b.n	4438 <prvUnlockQueue+0x60>
/* Data was posted while the queue was locked.  Are any tasks
blocked waiting for data to become available? */
#if (configUSE_QUEUE_SETS == 1)
			{
				if (pxQueue->pxQueueSetContainer != NULL) {
    43f2:	687b      	ldr	r3, [r7, #4]
    43f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    43f6:	2b00      	cmp	r3, #0
    43f8:	d009      	beq.n	440e <prvUnlockQueue+0x36>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    43fa:	687b      	ldr	r3, [r7, #4]
    43fc:	2100      	movs	r1, #0
    43fe:	0018      	movs	r0, r3
    4400:	4b2d      	ldr	r3, [pc, #180]	; (44b8 <prvUnlockQueue+0xe0>)
    4402:	4798      	blx	r3
    4404:	1e03      	subs	r3, r0, #0
    4406:	d00f      	beq.n	4428 <prvUnlockQueue+0x50>
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
    4408:	4b2c      	ldr	r3, [pc, #176]	; (44bc <prvUnlockQueue+0xe4>)
    440a:	4798      	blx	r3
    440c:	e00c      	b.n	4428 <prvUnlockQueue+0x50>
					}
				} else {
					/* Tasks that are removed from the event list will get
					added to the pending ready list as the scheduler is still
					suspended. */
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    440e:	687b      	ldr	r3, [r7, #4]
    4410:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4412:	2b00      	cmp	r3, #0
    4414:	d017      	beq.n	4446 <prvUnlockQueue+0x6e>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    4416:	687b      	ldr	r3, [r7, #4]
    4418:	3324      	adds	r3, #36	; 0x24
    441a:	0018      	movs	r0, r3
    441c:	4b28      	ldr	r3, [pc, #160]	; (44c0 <prvUnlockQueue+0xe8>)
    441e:	4798      	blx	r3
    4420:	1e03      	subs	r3, r0, #0
    4422:	d001      	beq.n	4428 <prvUnlockQueue+0x50>
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
    4424:	4b25      	ldr	r3, [pc, #148]	; (44bc <prvUnlockQueue+0xe4>)
    4426:	4798      	blx	r3
					break;
				}
			}
#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    4428:	230f      	movs	r3, #15
    442a:	18fb      	adds	r3, r7, r3
    442c:	781b      	ldrb	r3, [r3, #0]
    442e:	3b01      	subs	r3, #1
    4430:	b2da      	uxtb	r2, r3
    4432:	230f      	movs	r3, #15
    4434:	18fb      	adds	r3, r7, r3
    4436:	701a      	strb	r2, [r3, #0]
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    4438:	230f      	movs	r3, #15
    443a:	18fb      	adds	r3, r7, r3
    443c:	781b      	ldrb	r3, [r3, #0]
    443e:	b25b      	sxtb	r3, r3
    4440:	2b00      	cmp	r3, #0
    4442:	dcd6      	bgt.n	43f2 <prvUnlockQueue+0x1a>
    4444:	e000      	b.n	4448 <prvUnlockQueue+0x70>
						break;
    4446:	46c0      	nop			; (mov r8, r8)
		}

		pxQueue->cTxLock = queueUNLOCKED;
    4448:	687b      	ldr	r3, [r7, #4]
    444a:	2245      	movs	r2, #69	; 0x45
    444c:	21ff      	movs	r1, #255	; 0xff
    444e:	5499      	strb	r1, [r3, r2]
	}
	taskEXIT_CRITICAL();
    4450:	4b1c      	ldr	r3, [pc, #112]	; (44c4 <prvUnlockQueue+0xec>)
    4452:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4454:	4b17      	ldr	r3, [pc, #92]	; (44b4 <prvUnlockQueue+0xdc>)
    4456:	4798      	blx	r3
	{
		int8_t cRxLock = pxQueue->cRxLock;
    4458:	230e      	movs	r3, #14
    445a:	18fb      	adds	r3, r7, r3
    445c:	687a      	ldr	r2, [r7, #4]
    445e:	2144      	movs	r1, #68	; 0x44
    4460:	5c52      	ldrb	r2, [r2, r1]
    4462:	701a      	strb	r2, [r3, #0]

		while (cRxLock > queueLOCKED_UNMODIFIED) {
    4464:	e014      	b.n	4490 <prvUnlockQueue+0xb8>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    4466:	687b      	ldr	r3, [r7, #4]
    4468:	691b      	ldr	r3, [r3, #16]
    446a:	2b00      	cmp	r3, #0
    446c:	d017      	beq.n	449e <prvUnlockQueue+0xc6>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    446e:	687b      	ldr	r3, [r7, #4]
    4470:	3310      	adds	r3, #16
    4472:	0018      	movs	r0, r3
    4474:	4b12      	ldr	r3, [pc, #72]	; (44c0 <prvUnlockQueue+0xe8>)
    4476:	4798      	blx	r3
    4478:	1e03      	subs	r3, r0, #0
    447a:	d001      	beq.n	4480 <prvUnlockQueue+0xa8>
					vTaskMissedYield();
    447c:	4b0f      	ldr	r3, [pc, #60]	; (44bc <prvUnlockQueue+0xe4>)
    447e:	4798      	blx	r3
				} else {
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    4480:	230e      	movs	r3, #14
    4482:	18fb      	adds	r3, r7, r3
    4484:	781b      	ldrb	r3, [r3, #0]
    4486:	3b01      	subs	r3, #1
    4488:	b2da      	uxtb	r2, r3
    448a:	230e      	movs	r3, #14
    448c:	18fb      	adds	r3, r7, r3
    448e:	701a      	strb	r2, [r3, #0]
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    4490:	230e      	movs	r3, #14
    4492:	18fb      	adds	r3, r7, r3
    4494:	781b      	ldrb	r3, [r3, #0]
    4496:	b25b      	sxtb	r3, r3
    4498:	2b00      	cmp	r3, #0
    449a:	dce4      	bgt.n	4466 <prvUnlockQueue+0x8e>
    449c:	e000      	b.n	44a0 <prvUnlockQueue+0xc8>
			} else {
				break;
    449e:	46c0      	nop			; (mov r8, r8)
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    44a0:	687b      	ldr	r3, [r7, #4]
    44a2:	2244      	movs	r2, #68	; 0x44
    44a4:	21ff      	movs	r1, #255	; 0xff
    44a6:	5499      	strb	r1, [r3, r2]
	}
	taskEXIT_CRITICAL();
    44a8:	4b06      	ldr	r3, [pc, #24]	; (44c4 <prvUnlockQueue+0xec>)
    44aa:	4798      	blx	r3
}
    44ac:	46c0      	nop			; (mov r8, r8)
    44ae:	46bd      	mov	sp, r7
    44b0:	b004      	add	sp, #16
    44b2:	bd80      	pop	{r7, pc}
    44b4:	00003ad1 	.word	0x00003ad1
    44b8:	000045ad 	.word	0x000045ad
    44bc:	00004f69 	.word	0x00004f69
    44c0:	00004dd5 	.word	0x00004dd5
    44c4:	00003af5 	.word	0x00003af5

000044c8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    44c8:	b580      	push	{r7, lr}
    44ca:	b084      	sub	sp, #16
    44cc:	af00      	add	r7, sp, #0
    44ce:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    44d0:	4b08      	ldr	r3, [pc, #32]	; (44f4 <prvIsQueueEmpty+0x2c>)
    44d2:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    44d4:	687b      	ldr	r3, [r7, #4]
    44d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    44d8:	2b00      	cmp	r3, #0
    44da:	d102      	bne.n	44e2 <prvIsQueueEmpty+0x1a>
			xReturn = pdTRUE;
    44dc:	2301      	movs	r3, #1
    44de:	60fb      	str	r3, [r7, #12]
    44e0:	e001      	b.n	44e6 <prvIsQueueEmpty+0x1e>
		} else {
			xReturn = pdFALSE;
    44e2:	2300      	movs	r3, #0
    44e4:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    44e6:	4b04      	ldr	r3, [pc, #16]	; (44f8 <prvIsQueueEmpty+0x30>)
    44e8:	4798      	blx	r3

	return xReturn;
    44ea:	68fb      	ldr	r3, [r7, #12]
}
    44ec:	0018      	movs	r0, r3
    44ee:	46bd      	mov	sp, r7
    44f0:	b004      	add	sp, #16
    44f2:	bd80      	pop	{r7, pc}
    44f4:	00003ad1 	.word	0x00003ad1
    44f8:	00003af5 	.word	0x00003af5

000044fc <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull(const Queue_t *pxQueue)
{
    44fc:	b580      	push	{r7, lr}
    44fe:	b084      	sub	sp, #16
    4500:	af00      	add	r7, sp, #0
    4502:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    4504:	4b09      	ldr	r3, [pc, #36]	; (452c <prvIsQueueFull+0x30>)
    4506:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    4508:	687b      	ldr	r3, [r7, #4]
    450a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    450c:	687b      	ldr	r3, [r7, #4]
    450e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4510:	429a      	cmp	r2, r3
    4512:	d102      	bne.n	451a <prvIsQueueFull+0x1e>
			xReturn = pdTRUE;
    4514:	2301      	movs	r3, #1
    4516:	60fb      	str	r3, [r7, #12]
    4518:	e001      	b.n	451e <prvIsQueueFull+0x22>
		} else {
			xReturn = pdFALSE;
    451a:	2300      	movs	r3, #0
    451c:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    451e:	4b04      	ldr	r3, [pc, #16]	; (4530 <prvIsQueueFull+0x34>)
    4520:	4798      	blx	r3

	return xReturn;
    4522:	68fb      	ldr	r3, [r7, #12]
}
    4524:	0018      	movs	r0, r3
    4526:	46bd      	mov	sp, r7
    4528:	b004      	add	sp, #16
    452a:	bd80      	pop	{r7, pc}
    452c:	00003ad1 	.word	0x00003ad1
    4530:	00003af5 	.word	0x00003af5

00004534 <vQueueWaitForMessageRestricted>:
	/*-----------------------------------------------------------*/

#if (configUSE_TIMERS == 1)

void vQueueWaitForMessageRestricted(QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
    4534:	b580      	push	{r7, lr}
    4536:	b086      	sub	sp, #24
    4538:	af00      	add	r7, sp, #0
    453a:	60f8      	str	r0, [r7, #12]
    453c:	60b9      	str	r1, [r7, #8]
    453e:	607a      	str	r2, [r7, #4]
	Queue_t *const pxQueue = (Queue_t *)xQueue;
    4540:	68fb      	ldr	r3, [r7, #12]
    4542:	617b      	str	r3, [r7, #20]
	will not actually cause the task to block, just place it on a blocked
	list.  It will not block until the scheduler is unlocked - at which
	time a yield will be performed.  If an item is added to the queue while
	the queue is locked, and the calling task blocks on the queue, then the
	calling task will be immediately unblocked when the queue is unlocked. */
	prvLockQueue(pxQueue);
    4544:	4b15      	ldr	r3, [pc, #84]	; (459c <vQueueWaitForMessageRestricted+0x68>)
    4546:	4798      	blx	r3
    4548:	697b      	ldr	r3, [r7, #20]
    454a:	2244      	movs	r2, #68	; 0x44
    454c:	5c9b      	ldrb	r3, [r3, r2]
    454e:	b25b      	sxtb	r3, r3
    4550:	3301      	adds	r3, #1
    4552:	d103      	bne.n	455c <vQueueWaitForMessageRestricted+0x28>
    4554:	697b      	ldr	r3, [r7, #20]
    4556:	2244      	movs	r2, #68	; 0x44
    4558:	2100      	movs	r1, #0
    455a:	5499      	strb	r1, [r3, r2]
    455c:	697b      	ldr	r3, [r7, #20]
    455e:	2245      	movs	r2, #69	; 0x45
    4560:	5c9b      	ldrb	r3, [r3, r2]
    4562:	b25b      	sxtb	r3, r3
    4564:	3301      	adds	r3, #1
    4566:	d103      	bne.n	4570 <vQueueWaitForMessageRestricted+0x3c>
    4568:	697b      	ldr	r3, [r7, #20]
    456a:	2245      	movs	r2, #69	; 0x45
    456c:	2100      	movs	r1, #0
    456e:	5499      	strb	r1, [r3, r2]
    4570:	4b0b      	ldr	r3, [pc, #44]	; (45a0 <vQueueWaitForMessageRestricted+0x6c>)
    4572:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    4574:	697b      	ldr	r3, [r7, #20]
    4576:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4578:	2b00      	cmp	r3, #0
    457a:	d106      	bne.n	458a <vQueueWaitForMessageRestricted+0x56>
		/* There is nothing in the queue, block for the specified period. */
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    457c:	697b      	ldr	r3, [r7, #20]
    457e:	3324      	adds	r3, #36	; 0x24
    4580:	687a      	ldr	r2, [r7, #4]
    4582:	68b9      	ldr	r1, [r7, #8]
    4584:	0018      	movs	r0, r3
    4586:	4b07      	ldr	r3, [pc, #28]	; (45a4 <vQueueWaitForMessageRestricted+0x70>)
    4588:	4798      	blx	r3
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
	prvUnlockQueue(pxQueue);
    458a:	697b      	ldr	r3, [r7, #20]
    458c:	0018      	movs	r0, r3
    458e:	4b06      	ldr	r3, [pc, #24]	; (45a8 <vQueueWaitForMessageRestricted+0x74>)
    4590:	4798      	blx	r3
}
    4592:	46c0      	nop			; (mov r8, r8)
    4594:	46bd      	mov	sp, r7
    4596:	b006      	add	sp, #24
    4598:	bd80      	pop	{r7, pc}
    459a:	46c0      	nop			; (mov r8, r8)
    459c:	00003ad1 	.word	0x00003ad1
    45a0:	00003af5 	.word	0x00003af5
    45a4:	00004d81 	.word	0x00004d81
    45a8:	000043d9 	.word	0x000043d9

000045ac <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
    45ac:	b580      	push	{r7, lr}
    45ae:	b086      	sub	sp, #24
    45b0:	af00      	add	r7, sp, #0
    45b2:	6078      	str	r0, [r7, #4]
    45b4:	6039      	str	r1, [r7, #0]
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    45b6:	687b      	ldr	r3, [r7, #4]
    45b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    45ba:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn             = pdFALSE;
    45bc:	2300      	movs	r3, #0
    45be:	617b      	str	r3, [r7, #20]

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    45c0:	693b      	ldr	r3, [r7, #16]
    45c2:	2b00      	cmp	r3, #0
    45c4:	d101      	bne.n	45ca <prvNotifyQueueSetContainer+0x1e>
    45c6:	b672      	cpsid	i
    45c8:	e7fe      	b.n	45c8 <prvNotifyQueueSetContainer+0x1c>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    45ca:	693b      	ldr	r3, [r7, #16]
    45cc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    45ce:	693b      	ldr	r3, [r7, #16]
    45d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    45d2:	429a      	cmp	r2, r3
    45d4:	d301      	bcc.n	45da <prvNotifyQueueSetContainer+0x2e>
    45d6:	b672      	cpsid	i
    45d8:	e7fe      	b.n	45d8 <prvNotifyQueueSetContainer+0x2c>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    45da:	693b      	ldr	r3, [r7, #16]
    45dc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    45de:	693b      	ldr	r3, [r7, #16]
    45e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    45e2:	429a      	cmp	r2, r3
    45e4:	d22a      	bcs.n	463c <prvNotifyQueueSetContainer+0x90>
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    45e6:	230f      	movs	r3, #15
    45e8:	18fb      	adds	r3, r7, r3
    45ea:	693a      	ldr	r2, [r7, #16]
    45ec:	2145      	movs	r1, #69	; 0x45
    45ee:	5c52      	ldrb	r2, [r2, r1]
    45f0:	701a      	strb	r2, [r3, #0]

		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    45f2:	683a      	ldr	r2, [r7, #0]
    45f4:	1d39      	adds	r1, r7, #4
    45f6:	693b      	ldr	r3, [r7, #16]
    45f8:	0018      	movs	r0, r3
    45fa:	4b13      	ldr	r3, [pc, #76]	; (4648 <prvNotifyQueueSetContainer+0x9c>)
    45fc:	4798      	blx	r3
    45fe:	0003      	movs	r3, r0
    4600:	617b      	str	r3, [r7, #20]

		if (cTxLock == queueUNLOCKED) {
    4602:	230f      	movs	r3, #15
    4604:	18fb      	adds	r3, r7, r3
    4606:	781b      	ldrb	r3, [r3, #0]
    4608:	b25b      	sxtb	r3, r3
    460a:	3301      	adds	r3, #1
    460c:	d10d      	bne.n	462a <prvNotifyQueueSetContainer+0x7e>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    460e:	693b      	ldr	r3, [r7, #16]
    4610:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4612:	2b00      	cmp	r3, #0
    4614:	d012      	beq.n	463c <prvNotifyQueueSetContainer+0x90>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    4616:	693b      	ldr	r3, [r7, #16]
    4618:	3324      	adds	r3, #36	; 0x24
    461a:	0018      	movs	r0, r3
    461c:	4b0b      	ldr	r3, [pc, #44]	; (464c <prvNotifyQueueSetContainer+0xa0>)
    461e:	4798      	blx	r3
    4620:	1e03      	subs	r3, r0, #0
    4622:	d00b      	beq.n	463c <prvNotifyQueueSetContainer+0x90>
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
    4624:	2301      	movs	r3, #1
    4626:	617b      	str	r3, [r7, #20]
    4628:	e008      	b.n	463c <prvNotifyQueueSetContainer+0x90>
				}
			} else {
				mtCOVERAGE_TEST_MARKER();
			}
		} else {
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    462a:	230f      	movs	r3, #15
    462c:	18fb      	adds	r3, r7, r3
    462e:	781b      	ldrb	r3, [r3, #0]
    4630:	3301      	adds	r3, #1
    4632:	b2db      	uxtb	r3, r3
    4634:	b259      	sxtb	r1, r3
    4636:	693b      	ldr	r3, [r7, #16]
    4638:	2245      	movs	r2, #69	; 0x45
    463a:	5499      	strb	r1, [r3, r2]
		}
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
    463c:	697b      	ldr	r3, [r7, #20]
}
    463e:	0018      	movs	r0, r3
    4640:	46bd      	mov	sp, r7
    4642:	b006      	add	sp, #24
    4644:	bd80      	pop	{r7, pc}
    4646:	46c0      	nop			; (mov r8, r8)
    4648:	000042cd 	.word	0x000042cd
    464c:	00004dd5 	.word	0x00004dd5

00004650 <xTaskCreate>:
BaseType_t xTaskCreate(
    TaskFunction_t    pxTaskCode,
    const char *const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    const configSTACK_DEPTH_TYPE usStackDepth, void *const pvParameters, UBaseType_t uxPriority,
    TaskHandle_t *const pxCreatedTask)
{
    4650:	b590      	push	{r4, r7, lr}
    4652:	b08d      	sub	sp, #52	; 0x34
    4654:	af04      	add	r7, sp, #16
    4656:	60f8      	str	r0, [r7, #12]
    4658:	60b9      	str	r1, [r7, #8]
    465a:	603b      	str	r3, [r7, #0]
    465c:	1dbb      	adds	r3, r7, #6
    465e:	801a      	strh	r2, [r3, #0]
	{
		StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = (StackType_t *)pvPortMalloc(
		    (((size_t)usStackDepth)
    4660:	1dbb      	adds	r3, r7, #6
    4662:	881b      	ldrh	r3, [r3, #0]
		pxStack = (StackType_t *)pvPortMalloc(
    4664:	009b      	lsls	r3, r3, #2
    4666:	0018      	movs	r0, r3
    4668:	4b1d      	ldr	r3, [pc, #116]	; (46e0 <xTaskCreate+0x90>)
    466a:	4798      	blx	r3
    466c:	0003      	movs	r3, r0
    466e:	617b      	str	r3, [r7, #20]
		     * sizeof(StackType_t))); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

		if (pxStack != NULL) {
    4670:	697b      	ldr	r3, [r7, #20]
    4672:	2b00      	cmp	r3, #0
    4674:	d010      	beq.n	4698 <xTaskCreate+0x48>
			/* Allocate space for the TCB. */
			pxNewTCB = (TCB_t *)pvPortMalloc(
    4676:	204c      	movs	r0, #76	; 0x4c
    4678:	4b19      	ldr	r3, [pc, #100]	; (46e0 <xTaskCreate+0x90>)
    467a:	4798      	blx	r3
    467c:	0003      	movs	r3, r0
    467e:	61fb      	str	r3, [r7, #28]
			    sizeof(TCB_t)); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */

			if (pxNewTCB != NULL) {
    4680:	69fb      	ldr	r3, [r7, #28]
    4682:	2b00      	cmp	r3, #0
    4684:	d003      	beq.n	468e <xTaskCreate+0x3e>
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    4686:	69fb      	ldr	r3, [r7, #28]
    4688:	697a      	ldr	r2, [r7, #20]
    468a:	631a      	str	r2, [r3, #48]	; 0x30
    468c:	e006      	b.n	469c <xTaskCreate+0x4c>
			} else {
				/* The stack cannot be used as the TCB was not created.  Free
				it again. */
				vPortFree(pxStack);
    468e:	697b      	ldr	r3, [r7, #20]
    4690:	0018      	movs	r0, r3
    4692:	4b14      	ldr	r3, [pc, #80]	; (46e4 <xTaskCreate+0x94>)
    4694:	4798      	blx	r3
    4696:	e001      	b.n	469c <xTaskCreate+0x4c>
			}
		} else {
			pxNewTCB = NULL;
    4698:	2300      	movs	r3, #0
    469a:	61fb      	str	r3, [r7, #28]
		}
	}
#endif /* portSTACK_GROWTH */

	if (pxNewTCB != NULL) {
    469c:	69fb      	ldr	r3, [r7, #28]
    469e:	2b00      	cmp	r3, #0
    46a0:	d016      	beq.n	46d0 <xTaskCreate+0x80>
			task was created dynamically in case it is later deleted. */
			pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
		}
#endif /* configSUPPORT_STATIC_ALLOCATION */

		prvInitialiseNewTask(
    46a2:	1dbb      	adds	r3, r7, #6
    46a4:	881a      	ldrh	r2, [r3, #0]
    46a6:	683c      	ldr	r4, [r7, #0]
    46a8:	68b9      	ldr	r1, [r7, #8]
    46aa:	68f8      	ldr	r0, [r7, #12]
    46ac:	2300      	movs	r3, #0
    46ae:	9303      	str	r3, [sp, #12]
    46b0:	69fb      	ldr	r3, [r7, #28]
    46b2:	9302      	str	r3, [sp, #8]
    46b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    46b6:	9301      	str	r3, [sp, #4]
    46b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    46ba:	9300      	str	r3, [sp, #0]
    46bc:	0023      	movs	r3, r4
    46be:	4c0a      	ldr	r4, [pc, #40]	; (46e8 <xTaskCreate+0x98>)
    46c0:	47a0      	blx	r4
		    pxTaskCode, pcName, (uint32_t)usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL);
		prvAddNewTaskToReadyList(pxNewTCB);
    46c2:	69fb      	ldr	r3, [r7, #28]
    46c4:	0018      	movs	r0, r3
    46c6:	4b09      	ldr	r3, [pc, #36]	; (46ec <xTaskCreate+0x9c>)
    46c8:	4798      	blx	r3
		xReturn = pdPASS;
    46ca:	2301      	movs	r3, #1
    46cc:	61bb      	str	r3, [r7, #24]
    46ce:	e002      	b.n	46d6 <xTaskCreate+0x86>
	} else {
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    46d0:	2301      	movs	r3, #1
    46d2:	425b      	negs	r3, r3
    46d4:	61bb      	str	r3, [r7, #24]
	}

	return xReturn;
    46d6:	69bb      	ldr	r3, [r7, #24]
}
    46d8:	0018      	movs	r0, r3
    46da:	46bd      	mov	sp, r7
    46dc:	b009      	add	sp, #36	; 0x24
    46de:	bd90      	pop	{r4, r7, pc}
    46e0:	00003bfd 	.word	0x00003bfd
    46e4:	00003c91 	.word	0x00003c91
    46e8:	000046f1 	.word	0x000046f1
    46ec:	000047f5 	.word	0x000047f5

000046f0 <prvInitialiseNewTask>:
static void prvInitialiseNewTask(
    TaskFunction_t    pxTaskCode,
    const char *const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    const uint32_t ulStackDepth, void *const pvParameters, UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask,
    TCB_t *pxNewTCB, const MemoryRegion_t *const xRegions)
{
    46f0:	b580      	push	{r7, lr}
    46f2:	b086      	sub	sp, #24
    46f4:	af00      	add	r7, sp, #0
    46f6:	60f8      	str	r0, [r7, #12]
    46f8:	60b9      	str	r1, [r7, #8]
    46fa:	607a      	str	r2, [r7, #4]
    46fc:	603b      	str	r3, [r7, #0]

/* Avoid dependency on memset() if it is not required. */
#if (tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1)
	{
		/* Fill the stack with a known value to assist debugging. */
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
    46fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4700:	6b18      	ldr	r0, [r3, #48]	; 0x30
    4702:	687b      	ldr	r3, [r7, #4]
    4704:	009b      	lsls	r3, r3, #2
    4706:	001a      	movs	r2, r3
    4708:	21a5      	movs	r1, #165	; 0xa5
    470a:	4b36      	ldr	r3, [pc, #216]	; (47e4 <prvInitialiseNewTask+0xf4>)
    470c:	4798      	blx	r3
grows from high memory to low (as per the 80x86) or vice versa.
portSTACK_GROWTH is used to make the result positive or negative as required
by the port. */
#if (portSTACK_GROWTH < 0)
	{
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
    470e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4710:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    4712:	687b      	ldr	r3, [r7, #4]
    4714:	4934      	ldr	r1, [pc, #208]	; (47e8 <prvInitialiseNewTask+0xf8>)
    4716:	468c      	mov	ip, r1
    4718:	4463      	add	r3, ip
    471a:	009b      	lsls	r3, r3, #2
    471c:	18d3      	adds	r3, r2, r3
    471e:	613b      	str	r3, [r7, #16]
		pxTopOfStack
		    = (StackType_t *)(((portPOINTER_SIZE_TYPE)pxTopOfStack)
    4720:	693b      	ldr	r3, [r7, #16]
		                      & (~(
    4722:	2207      	movs	r2, #7
    4724:	4393      	bics	r3, r2
		    = (StackType_t *)(((portPOINTER_SIZE_TYPE)pxTopOfStack)
    4726:	613b      	str	r3, [r7, #16]
		                                                                                  practical.  Size differences
		                                                                                  accounted for using
		                                                                                  portPOINTER_SIZE_TYPE type. */

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT((((portPOINTER_SIZE_TYPE)pxTopOfStack & (portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK) == 0UL));
    4728:	693b      	ldr	r3, [r7, #16]
    472a:	2207      	movs	r2, #7
    472c:	4013      	ands	r3, r2
    472e:	d001      	beq.n	4734 <prvInitialiseNewTask+0x44>
    4730:	b672      	cpsid	i
    4732:	e7fe      	b.n	4732 <prvInitialiseNewTask+0x42>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
	}
#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    4734:	2300      	movs	r3, #0
    4736:	617b      	str	r3, [r7, #20]
    4738:	e013      	b.n	4762 <prvInitialiseNewTask+0x72>
		pxNewTCB->pcTaskName[x] = pcName[x];
    473a:	68ba      	ldr	r2, [r7, #8]
    473c:	697b      	ldr	r3, [r7, #20]
    473e:	18d3      	adds	r3, r2, r3
    4740:	7818      	ldrb	r0, [r3, #0]
    4742:	6aba      	ldr	r2, [r7, #40]	; 0x28
    4744:	2134      	movs	r1, #52	; 0x34
    4746:	697b      	ldr	r3, [r7, #20]
    4748:	18d3      	adds	r3, r2, r3
    474a:	185b      	adds	r3, r3, r1
    474c:	1c02      	adds	r2, r0, #0
    474e:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if (pcName[x] == 0x00) {
    4750:	68ba      	ldr	r2, [r7, #8]
    4752:	697b      	ldr	r3, [r7, #20]
    4754:	18d3      	adds	r3, r2, r3
    4756:	781b      	ldrb	r3, [r3, #0]
    4758:	2b00      	cmp	r3, #0
    475a:	d006      	beq.n	476a <prvInitialiseNewTask+0x7a>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    475c:	697b      	ldr	r3, [r7, #20]
    475e:	3301      	adds	r3, #1
    4760:	617b      	str	r3, [r7, #20]
    4762:	697b      	ldr	r3, [r7, #20]
    4764:	2b07      	cmp	r3, #7
    4766:	d9e8      	bls.n	473a <prvInitialiseNewTask+0x4a>
    4768:	e000      	b.n	476c <prvInitialiseNewTask+0x7c>
			break;
    476a:	46c0      	nop			; (mov r8, r8)
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    476c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    476e:	223b      	movs	r2, #59	; 0x3b
    4770:	2100      	movs	r1, #0
    4772:	5499      	strb	r1, [r3, r2]

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
    4774:	6a3b      	ldr	r3, [r7, #32]
    4776:	2b04      	cmp	r3, #4
    4778:	d901      	bls.n	477e <prvInitialiseNewTask+0x8e>
		uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
    477a:	2304      	movs	r3, #4
    477c:	623b      	str	r3, [r7, #32]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    477e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4780:	6a3a      	ldr	r2, [r7, #32]
    4782:	62da      	str	r2, [r3, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld  = 0;
	}
#endif /* configUSE_MUTEXES */

	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    4784:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4786:	3304      	adds	r3, #4
    4788:	0018      	movs	r0, r3
    478a:	4b18      	ldr	r3, [pc, #96]	; (47ec <prvInitialiseNewTask+0xfc>)
    478c:	4798      	blx	r3
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
    478e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4790:	3318      	adds	r3, #24
    4792:	0018      	movs	r0, r3
    4794:	4b15      	ldr	r3, [pc, #84]	; (47ec <prvInitialiseNewTask+0xfc>)
    4796:	4798      	blx	r3

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
    4798:	6abb      	ldr	r3, [r7, #40]	; 0x28
    479a:	6aba      	ldr	r2, [r7, #40]	; 0x28
    479c:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE(
    479e:	6a3b      	ldr	r3, [r7, #32]
    47a0:	2205      	movs	r2, #5
    47a2:	1ad2      	subs	r2, r2, r3
    47a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    47a6:	619a      	str	r2, [r3, #24]
	    &(pxNewTCB->xEventListItem),
	    (TickType_t)configMAX_PRIORITIES
	        - (TickType_t)uxPriority); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
    47a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    47aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
    47ac:	625a      	str	r2, [r3, #36]	; 0x24
	}
#endif

#if (configUSE_TASK_NOTIFICATIONS == 1)
	{
		pxNewTCB->ulNotifiedValue = 0;
    47ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
    47b0:	2200      	movs	r2, #0
    47b2:	645a      	str	r2, [r3, #68]	; 0x44
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
    47b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    47b6:	2248      	movs	r2, #72	; 0x48
    47b8:	2100      	movs	r1, #0
    47ba:	5499      	strb	r1, [r3, r2]
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged);
	}
#else  /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    47bc:	683a      	ldr	r2, [r7, #0]
    47be:	68f9      	ldr	r1, [r7, #12]
    47c0:	693b      	ldr	r3, [r7, #16]
    47c2:	0018      	movs	r0, r3
    47c4:	4b0a      	ldr	r3, [pc, #40]	; (47f0 <prvInitialiseNewTask+0x100>)
    47c6:	4798      	blx	r3
    47c8:	0002      	movs	r2, r0
    47ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
    47cc:	601a      	str	r2, [r3, #0]
	}
#endif /* portUSING_MPU_WRAPPERS */

	if ((void *)pxCreatedTask != NULL) {
    47ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    47d0:	2b00      	cmp	r3, #0
    47d2:	d002      	beq.n	47da <prvInitialiseNewTask+0xea>
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    47d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    47d6:	6aba      	ldr	r2, [r7, #40]	; 0x28
    47d8:	601a      	str	r2, [r3, #0]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    47da:	46c0      	nop			; (mov r8, r8)
    47dc:	46bd      	mov	sp, r7
    47de:	b006      	add	sp, #24
    47e0:	bd80      	pop	{r7, pc}
    47e2:	46c0      	nop			; (mov r8, r8)
    47e4:	00005dcb 	.word	0x00005dcb
    47e8:	3fffffff 	.word	0x3fffffff
    47ec:	0000387d 	.word	0x0000387d
    47f0:	00003995 	.word	0x00003995

000047f4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB)
{
    47f4:	b580      	push	{r7, lr}
    47f6:	b082      	sub	sp, #8
    47f8:	af00      	add	r7, sp, #0
    47fa:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    47fc:	4b2b      	ldr	r3, [pc, #172]	; (48ac <prvAddNewTaskToReadyList+0xb8>)
    47fe:	4798      	blx	r3
	{
		uxCurrentNumberOfTasks++;
    4800:	4b2b      	ldr	r3, [pc, #172]	; (48b0 <prvAddNewTaskToReadyList+0xbc>)
    4802:	681b      	ldr	r3, [r3, #0]
    4804:	1c5a      	adds	r2, r3, #1
    4806:	4b2a      	ldr	r3, [pc, #168]	; (48b0 <prvAddNewTaskToReadyList+0xbc>)
    4808:	601a      	str	r2, [r3, #0]
		if (pxCurrentTCB == NULL) {
    480a:	4b2a      	ldr	r3, [pc, #168]	; (48b4 <prvAddNewTaskToReadyList+0xc0>)
    480c:	681b      	ldr	r3, [r3, #0]
    480e:	2b00      	cmp	r3, #0
    4810:	d109      	bne.n	4826 <prvAddNewTaskToReadyList+0x32>
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4812:	4b28      	ldr	r3, [pc, #160]	; (48b4 <prvAddNewTaskToReadyList+0xc0>)
    4814:	687a      	ldr	r2, [r7, #4]
    4816:	601a      	str	r2, [r3, #0]

			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    4818:	4b25      	ldr	r3, [pc, #148]	; (48b0 <prvAddNewTaskToReadyList+0xbc>)
    481a:	681b      	ldr	r3, [r3, #0]
    481c:	2b01      	cmp	r3, #1
    481e:	d110      	bne.n	4842 <prvAddNewTaskToReadyList+0x4e>
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4820:	4b25      	ldr	r3, [pc, #148]	; (48b8 <prvAddNewTaskToReadyList+0xc4>)
    4822:	4798      	blx	r3
    4824:	e00d      	b.n	4842 <prvAddNewTaskToReadyList+0x4e>
			}
		} else {
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if (xSchedulerRunning == pdFALSE) {
    4826:	4b25      	ldr	r3, [pc, #148]	; (48bc <prvAddNewTaskToReadyList+0xc8>)
    4828:	681b      	ldr	r3, [r3, #0]
    482a:	2b00      	cmp	r3, #0
    482c:	d109      	bne.n	4842 <prvAddNewTaskToReadyList+0x4e>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
    482e:	4b21      	ldr	r3, [pc, #132]	; (48b4 <prvAddNewTaskToReadyList+0xc0>)
    4830:	681b      	ldr	r3, [r3, #0]
    4832:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4834:	687b      	ldr	r3, [r7, #4]
    4836:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4838:	429a      	cmp	r2, r3
    483a:	d802      	bhi.n	4842 <prvAddNewTaskToReadyList+0x4e>
					pxCurrentTCB = pxNewTCB;
    483c:	4b1d      	ldr	r3, [pc, #116]	; (48b4 <prvAddNewTaskToReadyList+0xc0>)
    483e:	687a      	ldr	r2, [r7, #4]
    4840:	601a      	str	r2, [r3, #0]
			} else {
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4842:	4b1f      	ldr	r3, [pc, #124]	; (48c0 <prvAddNewTaskToReadyList+0xcc>)
    4844:	681b      	ldr	r3, [r3, #0]
    4846:	1c5a      	adds	r2, r3, #1
    4848:	4b1d      	ldr	r3, [pc, #116]	; (48c0 <prvAddNewTaskToReadyList+0xcc>)
    484a:	601a      	str	r2, [r3, #0]

#if (configUSE_TRACE_FACILITY == 1)
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    484c:	4b1c      	ldr	r3, [pc, #112]	; (48c0 <prvAddNewTaskToReadyList+0xcc>)
    484e:	681a      	ldr	r2, [r3, #0]
    4850:	687b      	ldr	r3, [r7, #4]
    4852:	63da      	str	r2, [r3, #60]	; 0x3c
		}
#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE(pxNewTCB);

		prvAddTaskToReadyList(pxNewTCB);
    4854:	687b      	ldr	r3, [r7, #4]
    4856:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4858:	4b1a      	ldr	r3, [pc, #104]	; (48c4 <prvAddNewTaskToReadyList+0xd0>)
    485a:	681b      	ldr	r3, [r3, #0]
    485c:	429a      	cmp	r2, r3
    485e:	d903      	bls.n	4868 <prvAddNewTaskToReadyList+0x74>
    4860:	687b      	ldr	r3, [r7, #4]
    4862:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4864:	4b17      	ldr	r3, [pc, #92]	; (48c4 <prvAddNewTaskToReadyList+0xd0>)
    4866:	601a      	str	r2, [r3, #0]
    4868:	687b      	ldr	r3, [r7, #4]
    486a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    486c:	0013      	movs	r3, r2
    486e:	009b      	lsls	r3, r3, #2
    4870:	189b      	adds	r3, r3, r2
    4872:	009b      	lsls	r3, r3, #2
    4874:	4a14      	ldr	r2, [pc, #80]	; (48c8 <prvAddNewTaskToReadyList+0xd4>)
    4876:	189a      	adds	r2, r3, r2
    4878:	687b      	ldr	r3, [r7, #4]
    487a:	3304      	adds	r3, #4
    487c:	0019      	movs	r1, r3
    487e:	0010      	movs	r0, r2
    4880:	4b12      	ldr	r3, [pc, #72]	; (48cc <prvAddNewTaskToReadyList+0xd8>)
    4882:	4798      	blx	r3

		portSETUP_TCB(pxNewTCB);
	}
	taskEXIT_CRITICAL();
    4884:	4b12      	ldr	r3, [pc, #72]	; (48d0 <prvAddNewTaskToReadyList+0xdc>)
    4886:	4798      	blx	r3

	if (xSchedulerRunning != pdFALSE) {
    4888:	4b0c      	ldr	r3, [pc, #48]	; (48bc <prvAddNewTaskToReadyList+0xc8>)
    488a:	681b      	ldr	r3, [r3, #0]
    488c:	2b00      	cmp	r3, #0
    488e:	d008      	beq.n	48a2 <prvAddNewTaskToReadyList+0xae>
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
    4890:	4b08      	ldr	r3, [pc, #32]	; (48b4 <prvAddNewTaskToReadyList+0xc0>)
    4892:	681b      	ldr	r3, [r3, #0]
    4894:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4896:	687b      	ldr	r3, [r7, #4]
    4898:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    489a:	429a      	cmp	r2, r3
    489c:	d201      	bcs.n	48a2 <prvAddNewTaskToReadyList+0xae>
			taskYIELD_IF_USING_PREEMPTION();
    489e:	4b0d      	ldr	r3, [pc, #52]	; (48d4 <prvAddNewTaskToReadyList+0xe0>)
    48a0:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    48a2:	46c0      	nop			; (mov r8, r8)
    48a4:	46bd      	mov	sp, r7
    48a6:	b002      	add	sp, #8
    48a8:	bd80      	pop	{r7, pc}
    48aa:	46c0      	nop			; (mov r8, r8)
    48ac:	00003ad1 	.word	0x00003ad1
    48b0:	200026d8 	.word	0x200026d8
    48b4:	20002600 	.word	0x20002600
    48b8:	00004fa5 	.word	0x00004fa5
    48bc:	200026e4 	.word	0x200026e4
    48c0:	200026f4 	.word	0x200026f4
    48c4:	200026e0 	.word	0x200026e0
    48c8:	20002604 	.word	0x20002604
    48cc:	00003893 	.word	0x00003893
    48d0:	00003af5 	.word	0x00003af5
    48d4:	00003ab1 	.word	0x00003ab1

000048d8 <vTaskDelay>:
	/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskDelay == 1)

void vTaskDelay(const TickType_t xTicksToDelay)
{
    48d8:	b580      	push	{r7, lr}
    48da:	b084      	sub	sp, #16
    48dc:	af00      	add	r7, sp, #0
    48de:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
    48e0:	2300      	movs	r3, #0
    48e2:	60fb      	str	r3, [r7, #12]

	/* A delay time of zero just forces a reschedule. */
	if (xTicksToDelay > (TickType_t)0U) {
    48e4:	687b      	ldr	r3, [r7, #4]
    48e6:	2b00      	cmp	r3, #0
    48e8:	d010      	beq.n	490c <vTaskDelay+0x34>
		configASSERT(uxSchedulerSuspended == 0);
    48ea:	4b0d      	ldr	r3, [pc, #52]	; (4920 <vTaskDelay+0x48>)
    48ec:	681b      	ldr	r3, [r3, #0]
    48ee:	2b00      	cmp	r3, #0
    48f0:	d001      	beq.n	48f6 <vTaskDelay+0x1e>
    48f2:	b672      	cpsid	i
    48f4:	e7fe      	b.n	48f4 <vTaskDelay+0x1c>
		vTaskSuspendAll();
    48f6:	4b0b      	ldr	r3, [pc, #44]	; (4924 <vTaskDelay+0x4c>)
    48f8:	4798      	blx	r3
			list or removed from the blocked list until the scheduler
			is resumed.

			This task cannot be in an event list as it is the currently
			executing task. */
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
    48fa:	687b      	ldr	r3, [r7, #4]
    48fc:	2100      	movs	r1, #0
    48fe:	0018      	movs	r0, r3
    4900:	4b09      	ldr	r3, [pc, #36]	; (4928 <vTaskDelay+0x50>)
    4902:	4798      	blx	r3
		}
		xAlreadyYielded = xTaskResumeAll();
    4904:	4b09      	ldr	r3, [pc, #36]	; (492c <vTaskDelay+0x54>)
    4906:	4798      	blx	r3
    4908:	0003      	movs	r3, r0
    490a:	60fb      	str	r3, [r7, #12]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Force a reschedule if xTaskResumeAll has not already done so, we may
	have put ourselves to sleep. */
	if (xAlreadyYielded == pdFALSE) {
    490c:	68fb      	ldr	r3, [r7, #12]
    490e:	2b00      	cmp	r3, #0
    4910:	d101      	bne.n	4916 <vTaskDelay+0x3e>
		portYIELD_WITHIN_API();
    4912:	4b07      	ldr	r3, [pc, #28]	; (4930 <vTaskDelay+0x58>)
    4914:	4798      	blx	r3
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    4916:	46c0      	nop			; (mov r8, r8)
    4918:	46bd      	mov	sp, r7
    491a:	b004      	add	sp, #16
    491c:	bd80      	pop	{r7, pc}
    491e:	46c0      	nop			; (mov r8, r8)
    4920:	20002700 	.word	0x20002700
    4924:	000049bd 	.word	0x000049bd
    4928:	000053d5 	.word	0x000053d5
    492c:	000049d5 	.word	0x000049d5
    4930:	00003ab1 	.word	0x00003ab1

00004934 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler(void)
{
    4934:	b590      	push	{r4, r7, lr}
    4936:	b085      	sub	sp, #20
    4938:	af02      	add	r7, sp, #8
		}
	}
#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(prvIdleTask,
    493a:	2380      	movs	r3, #128	; 0x80
    493c:	009a      	lsls	r2, r3, #2
    493e:	4916      	ldr	r1, [pc, #88]	; (4998 <vTaskStartScheduler+0x64>)
    4940:	4816      	ldr	r0, [pc, #88]	; (499c <vTaskStartScheduler+0x68>)
    4942:	4b17      	ldr	r3, [pc, #92]	; (49a0 <vTaskStartScheduler+0x6c>)
    4944:	9301      	str	r3, [sp, #4]
    4946:	2300      	movs	r3, #0
    4948:	9300      	str	r3, [sp, #0]
    494a:	2300      	movs	r3, #0
    494c:	4c15      	ldr	r4, [pc, #84]	; (49a4 <vTaskStartScheduler+0x70>)
    494e:	47a0      	blx	r4
    4950:	0003      	movs	r3, r0
    4952:	607b      	str	r3, [r7, #4]
	}
#endif /* configSUPPORT_STATIC_ALLOCATION */

#if (configUSE_TIMERS == 1)
	{
		if (xReturn == pdPASS) {
    4954:	687b      	ldr	r3, [r7, #4]
    4956:	2b01      	cmp	r3, #1
    4958:	d103      	bne.n	4962 <vTaskStartScheduler+0x2e>
			xReturn = xTimerCreateTimerTask();
    495a:	4b13      	ldr	r3, [pc, #76]	; (49a8 <vTaskStartScheduler+0x74>)
    495c:	4798      	blx	r3
    495e:	0003      	movs	r3, r0
    4960:	607b      	str	r3, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif /* configUSE_TIMERS */

	if (xReturn == pdPASS) {
    4962:	687b      	ldr	r3, [r7, #4]
    4964:	2b01      	cmp	r3, #1
    4966:	d10d      	bne.n	4984 <vTaskStartScheduler+0x50>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4968:	b672      	cpsid	i
			structure specific to the task that will run first. */
			_impure_ptr = &(pxCurrentTCB->xNewLib_reent);
		}
#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    496a:	4b10      	ldr	r3, [pc, #64]	; (49ac <vTaskStartScheduler+0x78>)
    496c:	2201      	movs	r2, #1
    496e:	4252      	negs	r2, r2
    4970:	601a      	str	r2, [r3, #0]
		xSchedulerRunning    = pdTRUE;
    4972:	4b0f      	ldr	r3, [pc, #60]	; (49b0 <vTaskStartScheduler+0x7c>)
    4974:	2201      	movs	r2, #1
    4976:	601a      	str	r2, [r3, #0]
		xTickCount           = (TickType_t)0U;
    4978:	4b0e      	ldr	r3, [pc, #56]	; (49b4 <vTaskStartScheduler+0x80>)
    497a:	2200      	movs	r2, #0
    497c:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if (xPortStartScheduler() != pdFALSE) {
    497e:	4b0e      	ldr	r3, [pc, #56]	; (49b8 <vTaskStartScheduler+0x84>)
    4980:	4798      	blx	r3
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	(void)xIdleTaskHandle;
}
    4982:	e004      	b.n	498e <vTaskStartScheduler+0x5a>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    4984:	687b      	ldr	r3, [r7, #4]
    4986:	3301      	adds	r3, #1
    4988:	d101      	bne.n	498e <vTaskStartScheduler+0x5a>
    498a:	b672      	cpsid	i
    498c:	e7fe      	b.n	498c <vTaskStartScheduler+0x58>
}
    498e:	46c0      	nop			; (mov r8, r8)
    4990:	46bd      	mov	sp, r7
    4992:	b003      	add	sp, #12
    4994:	bd90      	pop	{r4, r7, pc}
    4996:	46c0      	nop			; (mov r8, r8)
    4998:	00005ee0 	.word	0x00005ee0
    499c:	00004f7d 	.word	0x00004f7d
    49a0:	200026fc 	.word	0x200026fc
    49a4:	00004651 	.word	0x00004651
    49a8:	00005489 	.word	0x00005489
    49ac:	200026f8 	.word	0x200026f8
    49b0:	200026e4 	.word	0x200026e4
    49b4:	200026dc 	.word	0x200026dc
    49b8:	00003a59 	.word	0x00003a59

000049bc <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll(void)
{
    49bc:	b580      	push	{r7, lr}
    49be:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    49c0:	4b03      	ldr	r3, [pc, #12]	; (49d0 <vTaskSuspendAll+0x14>)
    49c2:	681b      	ldr	r3, [r3, #0]
    49c4:	1c5a      	adds	r2, r3, #1
    49c6:	4b02      	ldr	r3, [pc, #8]	; (49d0 <vTaskSuspendAll+0x14>)
    49c8:	601a      	str	r2, [r3, #0]
}
    49ca:	46c0      	nop			; (mov r8, r8)
    49cc:	46bd      	mov	sp, r7
    49ce:	bd80      	pop	{r7, pc}
    49d0:	20002700 	.word	0x20002700

000049d4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll(void)
{
    49d4:	b580      	push	{r7, lr}
    49d6:	b084      	sub	sp, #16
    49d8:	af00      	add	r7, sp, #0
	TCB_t *    pxTCB           = NULL;
    49da:	2300      	movs	r3, #0
    49dc:	60fb      	str	r3, [r7, #12]
	BaseType_t xAlreadyYielded = pdFALSE;
    49de:	2300      	movs	r3, #0
    49e0:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT(uxSchedulerSuspended);
    49e2:	4b3a      	ldr	r3, [pc, #232]	; (4acc <xTaskResumeAll+0xf8>)
    49e4:	681b      	ldr	r3, [r3, #0]
    49e6:	2b00      	cmp	r3, #0
    49e8:	d101      	bne.n	49ee <xTaskResumeAll+0x1a>
    49ea:	b672      	cpsid	i
    49ec:	e7fe      	b.n	49ec <xTaskResumeAll+0x18>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    49ee:	4b38      	ldr	r3, [pc, #224]	; (4ad0 <xTaskResumeAll+0xfc>)
    49f0:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
    49f2:	4b36      	ldr	r3, [pc, #216]	; (4acc <xTaskResumeAll+0xf8>)
    49f4:	681b      	ldr	r3, [r3, #0]
    49f6:	1e5a      	subs	r2, r3, #1
    49f8:	4b34      	ldr	r3, [pc, #208]	; (4acc <xTaskResumeAll+0xf8>)
    49fa:	601a      	str	r2, [r3, #0]

		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    49fc:	4b33      	ldr	r3, [pc, #204]	; (4acc <xTaskResumeAll+0xf8>)
    49fe:	681b      	ldr	r3, [r3, #0]
    4a00:	2b00      	cmp	r3, #0
    4a02:	d15b      	bne.n	4abc <xTaskResumeAll+0xe8>
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    4a04:	4b33      	ldr	r3, [pc, #204]	; (4ad4 <xTaskResumeAll+0x100>)
    4a06:	681b      	ldr	r3, [r3, #0]
    4a08:	2b00      	cmp	r3, #0
    4a0a:	d057      	beq.n	4abc <xTaskResumeAll+0xe8>
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    4a0c:	e02f      	b.n	4a6e <xTaskResumeAll+0x9a>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    4a0e:	4b32      	ldr	r3, [pc, #200]	; (4ad8 <xTaskResumeAll+0x104>)
    4a10:	68db      	ldr	r3, [r3, #12]
    4a12:	68db      	ldr	r3, [r3, #12]
    4a14:	60fb      	str	r3, [r7, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    4a16:	68fb      	ldr	r3, [r7, #12]
    4a18:	3318      	adds	r3, #24
    4a1a:	0018      	movs	r0, r3
    4a1c:	4b2f      	ldr	r3, [pc, #188]	; (4adc <xTaskResumeAll+0x108>)
    4a1e:	4798      	blx	r3
					(void)uxListRemove(&(pxTCB->xStateListItem));
    4a20:	68fb      	ldr	r3, [r7, #12]
    4a22:	3304      	adds	r3, #4
    4a24:	0018      	movs	r0, r3
    4a26:	4b2d      	ldr	r3, [pc, #180]	; (4adc <xTaskResumeAll+0x108>)
    4a28:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
    4a2a:	68fb      	ldr	r3, [r7, #12]
    4a2c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4a2e:	4b2c      	ldr	r3, [pc, #176]	; (4ae0 <xTaskResumeAll+0x10c>)
    4a30:	681b      	ldr	r3, [r3, #0]
    4a32:	429a      	cmp	r2, r3
    4a34:	d903      	bls.n	4a3e <xTaskResumeAll+0x6a>
    4a36:	68fb      	ldr	r3, [r7, #12]
    4a38:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4a3a:	4b29      	ldr	r3, [pc, #164]	; (4ae0 <xTaskResumeAll+0x10c>)
    4a3c:	601a      	str	r2, [r3, #0]
    4a3e:	68fb      	ldr	r3, [r7, #12]
    4a40:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4a42:	0013      	movs	r3, r2
    4a44:	009b      	lsls	r3, r3, #2
    4a46:	189b      	adds	r3, r3, r2
    4a48:	009b      	lsls	r3, r3, #2
    4a4a:	4a26      	ldr	r2, [pc, #152]	; (4ae4 <xTaskResumeAll+0x110>)
    4a4c:	189a      	adds	r2, r3, r2
    4a4e:	68fb      	ldr	r3, [r7, #12]
    4a50:	3304      	adds	r3, #4
    4a52:	0019      	movs	r1, r3
    4a54:	0010      	movs	r0, r2
    4a56:	4b24      	ldr	r3, [pc, #144]	; (4ae8 <xTaskResumeAll+0x114>)
    4a58:	4798      	blx	r3

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    4a5a:	68fb      	ldr	r3, [r7, #12]
    4a5c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4a5e:	4b23      	ldr	r3, [pc, #140]	; (4aec <xTaskResumeAll+0x118>)
    4a60:	681b      	ldr	r3, [r3, #0]
    4a62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4a64:	429a      	cmp	r2, r3
    4a66:	d302      	bcc.n	4a6e <xTaskResumeAll+0x9a>
						xYieldPending = pdTRUE;
    4a68:	4b21      	ldr	r3, [pc, #132]	; (4af0 <xTaskResumeAll+0x11c>)
    4a6a:	2201      	movs	r2, #1
    4a6c:	601a      	str	r2, [r3, #0]
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    4a6e:	4b1a      	ldr	r3, [pc, #104]	; (4ad8 <xTaskResumeAll+0x104>)
    4a70:	681b      	ldr	r3, [r3, #0]
    4a72:	2b00      	cmp	r3, #0
    4a74:	d1cb      	bne.n	4a0e <xTaskResumeAll+0x3a>
					} else {
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if (pxTCB != NULL) {
    4a76:	68fb      	ldr	r3, [r7, #12]
    4a78:	2b00      	cmp	r3, #0
    4a7a:	d001      	beq.n	4a80 <xTaskResumeAll+0xac>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4a7c:	4b1d      	ldr	r3, [pc, #116]	; (4af4 <xTaskResumeAll+0x120>)
    4a7e:	4798      	blx	r3
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4a80:	4b1d      	ldr	r3, [pc, #116]	; (4af8 <xTaskResumeAll+0x124>)
    4a82:	681b      	ldr	r3, [r3, #0]
    4a84:	607b      	str	r3, [r7, #4]

					if (uxPendedCounts > (UBaseType_t)0U) {
    4a86:	687b      	ldr	r3, [r7, #4]
    4a88:	2b00      	cmp	r3, #0
    4a8a:	d00f      	beq.n	4aac <xTaskResumeAll+0xd8>
						do {
							if (xTaskIncrementTick() != pdFALSE) {
    4a8c:	4b1b      	ldr	r3, [pc, #108]	; (4afc <xTaskResumeAll+0x128>)
    4a8e:	4798      	blx	r3
    4a90:	1e03      	subs	r3, r0, #0
    4a92:	d002      	beq.n	4a9a <xTaskResumeAll+0xc6>
								xYieldPending = pdTRUE;
    4a94:	4b16      	ldr	r3, [pc, #88]	; (4af0 <xTaskResumeAll+0x11c>)
    4a96:	2201      	movs	r2, #1
    4a98:	601a      	str	r2, [r3, #0]
							} else {
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4a9a:	687b      	ldr	r3, [r7, #4]
    4a9c:	3b01      	subs	r3, #1
    4a9e:	607b      	str	r3, [r7, #4]
						} while (uxPendedCounts > (UBaseType_t)0U);
    4aa0:	687b      	ldr	r3, [r7, #4]
    4aa2:	2b00      	cmp	r3, #0
    4aa4:	d1f2      	bne.n	4a8c <xTaskResumeAll+0xb8>

						uxPendedTicks = 0;
    4aa6:	4b14      	ldr	r3, [pc, #80]	; (4af8 <xTaskResumeAll+0x124>)
    4aa8:	2200      	movs	r2, #0
    4aaa:	601a      	str	r2, [r3, #0]
					} else {
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if (xYieldPending != pdFALSE) {
    4aac:	4b10      	ldr	r3, [pc, #64]	; (4af0 <xTaskResumeAll+0x11c>)
    4aae:	681b      	ldr	r3, [r3, #0]
    4ab0:	2b00      	cmp	r3, #0
    4ab2:	d003      	beq.n	4abc <xTaskResumeAll+0xe8>
#if (configUSE_PREEMPTION != 0)
					{
						xAlreadyYielded = pdTRUE;
    4ab4:	2301      	movs	r3, #1
    4ab6:	60bb      	str	r3, [r7, #8]
					}
#endif
					taskYIELD_IF_USING_PREEMPTION();
    4ab8:	4b11      	ldr	r3, [pc, #68]	; (4b00 <xTaskResumeAll+0x12c>)
    4aba:	4798      	blx	r3
			}
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4abc:	4b11      	ldr	r3, [pc, #68]	; (4b04 <xTaskResumeAll+0x130>)
    4abe:	4798      	blx	r3

	return xAlreadyYielded;
    4ac0:	68bb      	ldr	r3, [r7, #8]
}
    4ac2:	0018      	movs	r0, r3
    4ac4:	46bd      	mov	sp, r7
    4ac6:	b004      	add	sp, #16
    4ac8:	bd80      	pop	{r7, pc}
    4aca:	46c0      	nop			; (mov r8, r8)
    4acc:	20002700 	.word	0x20002700
    4ad0:	00003ad1 	.word	0x00003ad1
    4ad4:	200026d8 	.word	0x200026d8
    4ad8:	20002698 	.word	0x20002698
    4adc:	00003943 	.word	0x00003943
    4ae0:	200026e0 	.word	0x200026e0
    4ae4:	20002604 	.word	0x20002604
    4ae8:	00003893 	.word	0x00003893
    4aec:	20002600 	.word	0x20002600
    4af0:	200026ec 	.word	0x200026ec
    4af4:	000050c5 	.word	0x000050c5
    4af8:	200026e8 	.word	0x200026e8
    4afc:	00004b25 	.word	0x00004b25
    4b00:	00003ab1 	.word	0x00003ab1
    4b04:	00003af5 	.word	0x00003af5

00004b08 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount(void)
{
    4b08:	b580      	push	{r7, lr}
    4b0a:	b082      	sub	sp, #8
    4b0c:	af00      	add	r7, sp, #0
	TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
    4b0e:	4b04      	ldr	r3, [pc, #16]	; (4b20 <xTaskGetTickCount+0x18>)
    4b10:	681b      	ldr	r3, [r3, #0]
    4b12:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
    4b14:	687b      	ldr	r3, [r7, #4]
}
    4b16:	0018      	movs	r0, r3
    4b18:	46bd      	mov	sp, r7
    4b1a:	b002      	add	sp, #8
    4b1c:	bd80      	pop	{r7, pc}
    4b1e:	46c0      	nop			; (mov r8, r8)
    4b20:	200026dc 	.word	0x200026dc

00004b24 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick(void)
{
    4b24:	b580      	push	{r7, lr}
    4b26:	b086      	sub	sp, #24
    4b28:	af00      	add	r7, sp, #0
	TCB_t *    pxTCB;
	TickType_t xItemValue;
	BaseType_t xSwitchRequired = pdFALSE;
    4b2a:	2300      	movs	r3, #0
    4b2c:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK(xTickCount);
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    4b2e:	4b4c      	ldr	r3, [pc, #304]	; (4c60 <xTaskIncrementTick+0x13c>)
    4b30:	681b      	ldr	r3, [r3, #0]
    4b32:	2b00      	cmp	r3, #0
    4b34:	d000      	beq.n	4b38 <xTaskIncrementTick+0x14>
    4b36:	e083      	b.n	4c40 <xTaskIncrementTick+0x11c>
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
    4b38:	4b4a      	ldr	r3, [pc, #296]	; (4c64 <xTaskIncrementTick+0x140>)
    4b3a:	681b      	ldr	r3, [r3, #0]
    4b3c:	3301      	adds	r3, #1
    4b3e:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4b40:	4b48      	ldr	r3, [pc, #288]	; (4c64 <xTaskIncrementTick+0x140>)
    4b42:	693a      	ldr	r2, [r7, #16]
    4b44:	601a      	str	r2, [r3, #0]

		if (xConstTickCount
    4b46:	693b      	ldr	r3, [r7, #16]
    4b48:	2b00      	cmp	r3, #0
    4b4a:	d117      	bne.n	4b7c <xTaskIncrementTick+0x58>
		    == (TickType_t)0U) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
		{
			taskSWITCH_DELAYED_LISTS();
    4b4c:	4b46      	ldr	r3, [pc, #280]	; (4c68 <xTaskIncrementTick+0x144>)
    4b4e:	681b      	ldr	r3, [r3, #0]
    4b50:	681b      	ldr	r3, [r3, #0]
    4b52:	2b00      	cmp	r3, #0
    4b54:	d001      	beq.n	4b5a <xTaskIncrementTick+0x36>
    4b56:	b672      	cpsid	i
    4b58:	e7fe      	b.n	4b58 <xTaskIncrementTick+0x34>
    4b5a:	4b43      	ldr	r3, [pc, #268]	; (4c68 <xTaskIncrementTick+0x144>)
    4b5c:	681b      	ldr	r3, [r3, #0]
    4b5e:	60fb      	str	r3, [r7, #12]
    4b60:	4b42      	ldr	r3, [pc, #264]	; (4c6c <xTaskIncrementTick+0x148>)
    4b62:	681a      	ldr	r2, [r3, #0]
    4b64:	4b40      	ldr	r3, [pc, #256]	; (4c68 <xTaskIncrementTick+0x144>)
    4b66:	601a      	str	r2, [r3, #0]
    4b68:	4b40      	ldr	r3, [pc, #256]	; (4c6c <xTaskIncrementTick+0x148>)
    4b6a:	68fa      	ldr	r2, [r7, #12]
    4b6c:	601a      	str	r2, [r3, #0]
    4b6e:	4b40      	ldr	r3, [pc, #256]	; (4c70 <xTaskIncrementTick+0x14c>)
    4b70:	681b      	ldr	r3, [r3, #0]
    4b72:	1c5a      	adds	r2, r3, #1
    4b74:	4b3e      	ldr	r3, [pc, #248]	; (4c70 <xTaskIncrementTick+0x14c>)
    4b76:	601a      	str	r2, [r3, #0]
    4b78:	4b3e      	ldr	r3, [pc, #248]	; (4c74 <xTaskIncrementTick+0x150>)
    4b7a:	4798      	blx	r3

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if (xConstTickCount >= xNextTaskUnblockTime) {
    4b7c:	4b3e      	ldr	r3, [pc, #248]	; (4c78 <xTaskIncrementTick+0x154>)
    4b7e:	681b      	ldr	r3, [r3, #0]
    4b80:	693a      	ldr	r2, [r7, #16]
    4b82:	429a      	cmp	r2, r3
    4b84:	d34e      	bcc.n	4c24 <xTaskIncrementTick+0x100>
			for (;;) {
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    4b86:	4b38      	ldr	r3, [pc, #224]	; (4c68 <xTaskIncrementTick+0x144>)
    4b88:	681b      	ldr	r3, [r3, #0]
    4b8a:	681b      	ldr	r3, [r3, #0]
    4b8c:	2b00      	cmp	r3, #0
    4b8e:	d101      	bne.n	4b94 <xTaskIncrementTick+0x70>
    4b90:	2301      	movs	r3, #1
    4b92:	e000      	b.n	4b96 <xTaskIncrementTick+0x72>
    4b94:	2300      	movs	r3, #0
    4b96:	2b00      	cmp	r3, #0
    4b98:	d004      	beq.n	4ba4 <xTaskIncrementTick+0x80>
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4b9a:	4b37      	ldr	r3, [pc, #220]	; (4c78 <xTaskIncrementTick+0x154>)
    4b9c:	2201      	movs	r2, #1
    4b9e:	4252      	negs	r2, r2
    4ba0:	601a      	str	r2, [r3, #0]
					break;
    4ba2:	e03f      	b.n	4c24 <xTaskIncrementTick+0x100>
				} else {
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    4ba4:	4b30      	ldr	r3, [pc, #192]	; (4c68 <xTaskIncrementTick+0x144>)
    4ba6:	681b      	ldr	r3, [r3, #0]
    4ba8:	68db      	ldr	r3, [r3, #12]
    4baa:	68db      	ldr	r3, [r3, #12]
    4bac:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
    4bae:	68bb      	ldr	r3, [r7, #8]
    4bb0:	685b      	ldr	r3, [r3, #4]
    4bb2:	607b      	str	r3, [r7, #4]

					if (xConstTickCount < xItemValue) {
    4bb4:	693a      	ldr	r2, [r7, #16]
    4bb6:	687b      	ldr	r3, [r7, #4]
    4bb8:	429a      	cmp	r2, r3
    4bba:	d203      	bcs.n	4bc4 <xTaskIncrementTick+0xa0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4bbc:	4b2e      	ldr	r3, [pc, #184]	; (4c78 <xTaskIncrementTick+0x154>)
    4bbe:	687a      	ldr	r2, [r7, #4]
    4bc0:	601a      	str	r2, [r3, #0]
						break;
    4bc2:	e02f      	b.n	4c24 <xTaskIncrementTick+0x100>
					} else {
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					(void)uxListRemove(&(pxTCB->xStateListItem));
    4bc4:	68bb      	ldr	r3, [r7, #8]
    4bc6:	3304      	adds	r3, #4
    4bc8:	0018      	movs	r0, r3
    4bca:	4b2c      	ldr	r3, [pc, #176]	; (4c7c <xTaskIncrementTick+0x158>)
    4bcc:	4798      	blx	r3

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    4bce:	68bb      	ldr	r3, [r7, #8]
    4bd0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4bd2:	2b00      	cmp	r3, #0
    4bd4:	d004      	beq.n	4be0 <xTaskIncrementTick+0xbc>
						(void)uxListRemove(&(pxTCB->xEventListItem));
    4bd6:	68bb      	ldr	r3, [r7, #8]
    4bd8:	3318      	adds	r3, #24
    4bda:	0018      	movs	r0, r3
    4bdc:	4b27      	ldr	r3, [pc, #156]	; (4c7c <xTaskIncrementTick+0x158>)
    4bde:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList(pxTCB);
    4be0:	68bb      	ldr	r3, [r7, #8]
    4be2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4be4:	4b26      	ldr	r3, [pc, #152]	; (4c80 <xTaskIncrementTick+0x15c>)
    4be6:	681b      	ldr	r3, [r3, #0]
    4be8:	429a      	cmp	r2, r3
    4bea:	d903      	bls.n	4bf4 <xTaskIncrementTick+0xd0>
    4bec:	68bb      	ldr	r3, [r7, #8]
    4bee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4bf0:	4b23      	ldr	r3, [pc, #140]	; (4c80 <xTaskIncrementTick+0x15c>)
    4bf2:	601a      	str	r2, [r3, #0]
    4bf4:	68bb      	ldr	r3, [r7, #8]
    4bf6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4bf8:	0013      	movs	r3, r2
    4bfa:	009b      	lsls	r3, r3, #2
    4bfc:	189b      	adds	r3, r3, r2
    4bfe:	009b      	lsls	r3, r3, #2
    4c00:	4a20      	ldr	r2, [pc, #128]	; (4c84 <xTaskIncrementTick+0x160>)
    4c02:	189a      	adds	r2, r3, r2
    4c04:	68bb      	ldr	r3, [r7, #8]
    4c06:	3304      	adds	r3, #4
    4c08:	0019      	movs	r1, r3
    4c0a:	0010      	movs	r0, r2
    4c0c:	4b1e      	ldr	r3, [pc, #120]	; (4c88 <xTaskIncrementTick+0x164>)
    4c0e:	4798      	blx	r3
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    4c10:	68bb      	ldr	r3, [r7, #8]
    4c12:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4c14:	4b1d      	ldr	r3, [pc, #116]	; (4c8c <xTaskIncrementTick+0x168>)
    4c16:	681b      	ldr	r3, [r3, #0]
    4c18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4c1a:	429a      	cmp	r2, r3
    4c1c:	d3b3      	bcc.n	4b86 <xTaskIncrementTick+0x62>
							xSwitchRequired = pdTRUE;
    4c1e:	2301      	movs	r3, #1
    4c20:	617b      	str	r3, [r7, #20]
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    4c22:	e7b0      	b.n	4b86 <xTaskIncrementTick+0x62>
/* Tasks of equal priority to the currently running task will share
processing time (time slice) if preemption is on, and the application
writer has not explicitly turned time slicing off. */
#if ((configUSE_PREEMPTION == 1) && (configUSE_TIME_SLICING == 1))
		{
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    4c24:	4b19      	ldr	r3, [pc, #100]	; (4c8c <xTaskIncrementTick+0x168>)
    4c26:	681b      	ldr	r3, [r3, #0]
    4c28:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4c2a:	4916      	ldr	r1, [pc, #88]	; (4c84 <xTaskIncrementTick+0x160>)
    4c2c:	0013      	movs	r3, r2
    4c2e:	009b      	lsls	r3, r3, #2
    4c30:	189b      	adds	r3, r3, r2
    4c32:	009b      	lsls	r3, r3, #2
    4c34:	585b      	ldr	r3, [r3, r1]
    4c36:	2b01      	cmp	r3, #1
    4c38:	d907      	bls.n	4c4a <xTaskIncrementTick+0x126>
				xSwitchRequired = pdTRUE;
    4c3a:	2301      	movs	r3, #1
    4c3c:	617b      	str	r3, [r7, #20]
    4c3e:	e004      	b.n	4c4a <xTaskIncrementTick+0x126>
				mtCOVERAGE_TEST_MARKER();
			}
		}
#endif /* configUSE_TICK_HOOK */
	} else {
		++uxPendedTicks;
    4c40:	4b13      	ldr	r3, [pc, #76]	; (4c90 <xTaskIncrementTick+0x16c>)
    4c42:	681b      	ldr	r3, [r3, #0]
    4c44:	1c5a      	adds	r2, r3, #1
    4c46:	4b12      	ldr	r3, [pc, #72]	; (4c90 <xTaskIncrementTick+0x16c>)
    4c48:	601a      	str	r2, [r3, #0]
#endif
	}

#if (configUSE_PREEMPTION == 1)
	{
		if (xYieldPending != pdFALSE) {
    4c4a:	4b12      	ldr	r3, [pc, #72]	; (4c94 <xTaskIncrementTick+0x170>)
    4c4c:	681b      	ldr	r3, [r3, #0]
    4c4e:	2b00      	cmp	r3, #0
    4c50:	d001      	beq.n	4c56 <xTaskIncrementTick+0x132>
			xSwitchRequired = pdTRUE;
    4c52:	2301      	movs	r3, #1
    4c54:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4c56:	697b      	ldr	r3, [r7, #20]
}
    4c58:	0018      	movs	r0, r3
    4c5a:	46bd      	mov	sp, r7
    4c5c:	b006      	add	sp, #24
    4c5e:	bd80      	pop	{r7, pc}
    4c60:	20002700 	.word	0x20002700
    4c64:	200026dc 	.word	0x200026dc
    4c68:	20002690 	.word	0x20002690
    4c6c:	20002694 	.word	0x20002694
    4c70:	200026f0 	.word	0x200026f0
    4c74:	000050c5 	.word	0x000050c5
    4c78:	200026f8 	.word	0x200026f8
    4c7c:	00003943 	.word	0x00003943
    4c80:	200026e0 	.word	0x200026e0
    4c84:	20002604 	.word	0x20002604
    4c88:	00003893 	.word	0x00003893
    4c8c:	20002600 	.word	0x20002600
    4c90:	200026e8 	.word	0x200026e8
    4c94:	200026ec 	.word	0x200026ec

00004c98 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext(void)
{
    4c98:	b580      	push	{r7, lr}
    4c9a:	b082      	sub	sp, #8
    4c9c:	af00      	add	r7, sp, #0
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    4c9e:	4b22      	ldr	r3, [pc, #136]	; (4d28 <vTaskSwitchContext+0x90>)
    4ca0:	681b      	ldr	r3, [r3, #0]
    4ca2:	2b00      	cmp	r3, #0
    4ca4:	d003      	beq.n	4cae <vTaskSwitchContext+0x16>
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4ca6:	4b21      	ldr	r3, [pc, #132]	; (4d2c <vTaskSwitchContext+0x94>)
    4ca8:	2201      	movs	r2, #1
    4caa:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &(pxCurrentTCB->xNewLib_reent);
		}
#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4cac:	e037      	b.n	4d1e <vTaskSwitchContext+0x86>
		xYieldPending = pdFALSE;
    4cae:	4b1f      	ldr	r3, [pc, #124]	; (4d2c <vTaskSwitchContext+0x94>)
    4cb0:	2200      	movs	r2, #0
    4cb2:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
    4cb4:	4b1e      	ldr	r3, [pc, #120]	; (4d30 <vTaskSwitchContext+0x98>)
    4cb6:	681b      	ldr	r3, [r3, #0]
    4cb8:	607b      	str	r3, [r7, #4]
    4cba:	e007      	b.n	4ccc <vTaskSwitchContext+0x34>
    4cbc:	687b      	ldr	r3, [r7, #4]
    4cbe:	2b00      	cmp	r3, #0
    4cc0:	d101      	bne.n	4cc6 <vTaskSwitchContext+0x2e>
    4cc2:	b672      	cpsid	i
    4cc4:	e7fe      	b.n	4cc4 <vTaskSwitchContext+0x2c>
    4cc6:	687b      	ldr	r3, [r7, #4]
    4cc8:	3b01      	subs	r3, #1
    4cca:	607b      	str	r3, [r7, #4]
    4ccc:	4919      	ldr	r1, [pc, #100]	; (4d34 <vTaskSwitchContext+0x9c>)
    4cce:	687a      	ldr	r2, [r7, #4]
    4cd0:	0013      	movs	r3, r2
    4cd2:	009b      	lsls	r3, r3, #2
    4cd4:	189b      	adds	r3, r3, r2
    4cd6:	009b      	lsls	r3, r3, #2
    4cd8:	585b      	ldr	r3, [r3, r1]
    4cda:	2b00      	cmp	r3, #0
    4cdc:	d0ee      	beq.n	4cbc <vTaskSwitchContext+0x24>
    4cde:	687a      	ldr	r2, [r7, #4]
    4ce0:	0013      	movs	r3, r2
    4ce2:	009b      	lsls	r3, r3, #2
    4ce4:	189b      	adds	r3, r3, r2
    4ce6:	009b      	lsls	r3, r3, #2
    4ce8:	4a12      	ldr	r2, [pc, #72]	; (4d34 <vTaskSwitchContext+0x9c>)
    4cea:	189b      	adds	r3, r3, r2
    4cec:	603b      	str	r3, [r7, #0]
    4cee:	683b      	ldr	r3, [r7, #0]
    4cf0:	685b      	ldr	r3, [r3, #4]
    4cf2:	685a      	ldr	r2, [r3, #4]
    4cf4:	683b      	ldr	r3, [r7, #0]
    4cf6:	605a      	str	r2, [r3, #4]
    4cf8:	683b      	ldr	r3, [r7, #0]
    4cfa:	685a      	ldr	r2, [r3, #4]
    4cfc:	683b      	ldr	r3, [r7, #0]
    4cfe:	3308      	adds	r3, #8
    4d00:	429a      	cmp	r2, r3
    4d02:	d104      	bne.n	4d0e <vTaskSwitchContext+0x76>
    4d04:	683b      	ldr	r3, [r7, #0]
    4d06:	685b      	ldr	r3, [r3, #4]
    4d08:	685a      	ldr	r2, [r3, #4]
    4d0a:	683b      	ldr	r3, [r7, #0]
    4d0c:	605a      	str	r2, [r3, #4]
    4d0e:	683b      	ldr	r3, [r7, #0]
    4d10:	685b      	ldr	r3, [r3, #4]
    4d12:	68da      	ldr	r2, [r3, #12]
    4d14:	4b08      	ldr	r3, [pc, #32]	; (4d38 <vTaskSwitchContext+0xa0>)
    4d16:	601a      	str	r2, [r3, #0]
    4d18:	4b05      	ldr	r3, [pc, #20]	; (4d30 <vTaskSwitchContext+0x98>)
    4d1a:	687a      	ldr	r2, [r7, #4]
    4d1c:	601a      	str	r2, [r3, #0]
}
    4d1e:	46c0      	nop			; (mov r8, r8)
    4d20:	46bd      	mov	sp, r7
    4d22:	b002      	add	sp, #8
    4d24:	bd80      	pop	{r7, pc}
    4d26:	46c0      	nop			; (mov r8, r8)
    4d28:	20002700 	.word	0x20002700
    4d2c:	200026ec 	.word	0x200026ec
    4d30:	200026e0 	.word	0x200026e0
    4d34:	20002604 	.word	0x20002604
    4d38:	20002600 	.word	0x20002600

00004d3c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList(List_t *const pxEventList, const TickType_t xTicksToWait)
{
    4d3c:	b580      	push	{r7, lr}
    4d3e:	b082      	sub	sp, #8
    4d40:	af00      	add	r7, sp, #0
    4d42:	6078      	str	r0, [r7, #4]
    4d44:	6039      	str	r1, [r7, #0]
	configASSERT(pxEventList);
    4d46:	687b      	ldr	r3, [r7, #4]
    4d48:	2b00      	cmp	r3, #0
    4d4a:	d101      	bne.n	4d50 <vTaskPlaceOnEventList+0x14>
    4d4c:	b672      	cpsid	i
    4d4e:	e7fe      	b.n	4d4e <vTaskPlaceOnEventList+0x12>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    4d50:	4b08      	ldr	r3, [pc, #32]	; (4d74 <vTaskPlaceOnEventList+0x38>)
    4d52:	681b      	ldr	r3, [r3, #0]
    4d54:	3318      	adds	r3, #24
    4d56:	001a      	movs	r2, r3
    4d58:	687b      	ldr	r3, [r7, #4]
    4d5a:	0011      	movs	r1, r2
    4d5c:	0018      	movs	r0, r3
    4d5e:	4b06      	ldr	r3, [pc, #24]	; (4d78 <vTaskPlaceOnEventList+0x3c>)
    4d60:	4798      	blx	r3

	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
    4d62:	683b      	ldr	r3, [r7, #0]
    4d64:	2101      	movs	r1, #1
    4d66:	0018      	movs	r0, r3
    4d68:	4b04      	ldr	r3, [pc, #16]	; (4d7c <vTaskPlaceOnEventList+0x40>)
    4d6a:	4798      	blx	r3
}
    4d6c:	46c0      	nop			; (mov r8, r8)
    4d6e:	46bd      	mov	sp, r7
    4d70:	b002      	add	sp, #8
    4d72:	bd80      	pop	{r7, pc}
    4d74:	20002600 	.word	0x20002600
    4d78:	000038d7 	.word	0x000038d7
    4d7c:	000053d5 	.word	0x000053d5

00004d80 <vTaskPlaceOnEventListRestricted>:

#if (configUSE_TIMERS == 1)

void vTaskPlaceOnEventListRestricted(List_t *const pxEventList, TickType_t xTicksToWait,
                                     const BaseType_t xWaitIndefinitely)
{
    4d80:	b580      	push	{r7, lr}
    4d82:	b084      	sub	sp, #16
    4d84:	af00      	add	r7, sp, #0
    4d86:	60f8      	str	r0, [r7, #12]
    4d88:	60b9      	str	r1, [r7, #8]
    4d8a:	607a      	str	r2, [r7, #4]
	configASSERT(pxEventList);
    4d8c:	68fb      	ldr	r3, [r7, #12]
    4d8e:	2b00      	cmp	r3, #0
    4d90:	d101      	bne.n	4d96 <vTaskPlaceOnEventListRestricted+0x16>
    4d92:	b672      	cpsid	i
    4d94:	e7fe      	b.n	4d94 <vTaskPlaceOnEventListRestricted+0x14>

	/* Place the event list item of the TCB in the appropriate event list.
	In this case it is assume that this is the only task that is going to
	be waiting on this event list, so the faster vListInsertEnd() function
	can be used in place of vListInsert. */
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    4d96:	4b0c      	ldr	r3, [pc, #48]	; (4dc8 <vTaskPlaceOnEventListRestricted+0x48>)
    4d98:	681b      	ldr	r3, [r3, #0]
    4d9a:	3318      	adds	r3, #24
    4d9c:	001a      	movs	r2, r3
    4d9e:	68fb      	ldr	r3, [r7, #12]
    4da0:	0011      	movs	r1, r2
    4da2:	0018      	movs	r0, r3
    4da4:	4b09      	ldr	r3, [pc, #36]	; (4dcc <vTaskPlaceOnEventListRestricted+0x4c>)
    4da6:	4798      	blx	r3

	/* If the task should block indefinitely then set the block time to a
	value that will be recognised as an indefinite delay inside the
	prvAddCurrentTaskToDelayedList() function. */
	if (xWaitIndefinitely != pdFALSE) {
    4da8:	687b      	ldr	r3, [r7, #4]
    4daa:	2b00      	cmp	r3, #0
    4dac:	d002      	beq.n	4db4 <vTaskPlaceOnEventListRestricted+0x34>
		xTicksToWait = portMAX_DELAY;
    4dae:	2301      	movs	r3, #1
    4db0:	425b      	negs	r3, r3
    4db2:	60bb      	str	r3, [r7, #8]
	}

	traceTASK_DELAY_UNTIL((xTickCount + xTicksToWait));
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
    4db4:	687a      	ldr	r2, [r7, #4]
    4db6:	68bb      	ldr	r3, [r7, #8]
    4db8:	0011      	movs	r1, r2
    4dba:	0018      	movs	r0, r3
    4dbc:	4b04      	ldr	r3, [pc, #16]	; (4dd0 <vTaskPlaceOnEventListRestricted+0x50>)
    4dbe:	4798      	blx	r3
}
    4dc0:	46c0      	nop			; (mov r8, r8)
    4dc2:	46bd      	mov	sp, r7
    4dc4:	b004      	add	sp, #16
    4dc6:	bd80      	pop	{r7, pc}
    4dc8:	20002600 	.word	0x20002600
    4dcc:	00003893 	.word	0x00003893
    4dd0:	000053d5 	.word	0x000053d5

00004dd4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList)
{
    4dd4:	b580      	push	{r7, lr}
    4dd6:	b084      	sub	sp, #16
    4dd8:	af00      	add	r7, sp, #0
    4dda:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    4ddc:	687b      	ldr	r3, [r7, #4]
    4dde:	68db      	ldr	r3, [r3, #12]
    4de0:	68db      	ldr	r3, [r3, #12]
    4de2:	60bb      	str	r3, [r7, #8]
	configASSERT(pxUnblockedTCB);
    4de4:	68bb      	ldr	r3, [r7, #8]
    4de6:	2b00      	cmp	r3, #0
    4de8:	d101      	bne.n	4dee <xTaskRemoveFromEventList+0x1a>
    4dea:	b672      	cpsid	i
    4dec:	e7fe      	b.n	4dec <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    4dee:	68bb      	ldr	r3, [r7, #8]
    4df0:	3318      	adds	r3, #24
    4df2:	0018      	movs	r0, r3
    4df4:	4b1f      	ldr	r3, [pc, #124]	; (4e74 <xTaskRemoveFromEventList+0xa0>)
    4df6:	4798      	blx	r3

	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    4df8:	4b1f      	ldr	r3, [pc, #124]	; (4e78 <xTaskRemoveFromEventList+0xa4>)
    4dfa:	681b      	ldr	r3, [r3, #0]
    4dfc:	2b00      	cmp	r3, #0
    4dfe:	d11d      	bne.n	4e3c <xTaskRemoveFromEventList+0x68>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
    4e00:	68bb      	ldr	r3, [r7, #8]
    4e02:	3304      	adds	r3, #4
    4e04:	0018      	movs	r0, r3
    4e06:	4b1b      	ldr	r3, [pc, #108]	; (4e74 <xTaskRemoveFromEventList+0xa0>)
    4e08:	4798      	blx	r3
		prvAddTaskToReadyList(pxUnblockedTCB);
    4e0a:	68bb      	ldr	r3, [r7, #8]
    4e0c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4e0e:	4b1b      	ldr	r3, [pc, #108]	; (4e7c <xTaskRemoveFromEventList+0xa8>)
    4e10:	681b      	ldr	r3, [r3, #0]
    4e12:	429a      	cmp	r2, r3
    4e14:	d903      	bls.n	4e1e <xTaskRemoveFromEventList+0x4a>
    4e16:	68bb      	ldr	r3, [r7, #8]
    4e18:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4e1a:	4b18      	ldr	r3, [pc, #96]	; (4e7c <xTaskRemoveFromEventList+0xa8>)
    4e1c:	601a      	str	r2, [r3, #0]
    4e1e:	68bb      	ldr	r3, [r7, #8]
    4e20:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4e22:	0013      	movs	r3, r2
    4e24:	009b      	lsls	r3, r3, #2
    4e26:	189b      	adds	r3, r3, r2
    4e28:	009b      	lsls	r3, r3, #2
    4e2a:	4a15      	ldr	r2, [pc, #84]	; (4e80 <xTaskRemoveFromEventList+0xac>)
    4e2c:	189a      	adds	r2, r3, r2
    4e2e:	68bb      	ldr	r3, [r7, #8]
    4e30:	3304      	adds	r3, #4
    4e32:	0019      	movs	r1, r3
    4e34:	0010      	movs	r0, r2
    4e36:	4b13      	ldr	r3, [pc, #76]	; (4e84 <xTaskRemoveFromEventList+0xb0>)
    4e38:	4798      	blx	r3
    4e3a:	e007      	b.n	4e4c <xTaskRemoveFromEventList+0x78>
	} else {
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    4e3c:	68bb      	ldr	r3, [r7, #8]
    4e3e:	3318      	adds	r3, #24
    4e40:	001a      	movs	r2, r3
    4e42:	4b11      	ldr	r3, [pc, #68]	; (4e88 <xTaskRemoveFromEventList+0xb4>)
    4e44:	0011      	movs	r1, r2
    4e46:	0018      	movs	r0, r3
    4e48:	4b0e      	ldr	r3, [pc, #56]	; (4e84 <xTaskRemoveFromEventList+0xb0>)
    4e4a:	4798      	blx	r3
	}

	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    4e4c:	68bb      	ldr	r3, [r7, #8]
    4e4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4e50:	4b0e      	ldr	r3, [pc, #56]	; (4e8c <xTaskRemoveFromEventList+0xb8>)
    4e52:	681b      	ldr	r3, [r3, #0]
    4e54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4e56:	429a      	cmp	r2, r3
    4e58:	d905      	bls.n	4e66 <xTaskRemoveFromEventList+0x92>
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4e5a:	2301      	movs	r3, #1
    4e5c:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4e5e:	4b0c      	ldr	r3, [pc, #48]	; (4e90 <xTaskRemoveFromEventList+0xbc>)
    4e60:	2201      	movs	r2, #1
    4e62:	601a      	str	r2, [r3, #0]
    4e64:	e001      	b.n	4e6a <xTaskRemoveFromEventList+0x96>
	} else {
		xReturn = pdFALSE;
    4e66:	2300      	movs	r3, #0
    4e68:	60fb      	str	r3, [r7, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
#endif

	return xReturn;
    4e6a:	68fb      	ldr	r3, [r7, #12]
}
    4e6c:	0018      	movs	r0, r3
    4e6e:	46bd      	mov	sp, r7
    4e70:	b004      	add	sp, #16
    4e72:	bd80      	pop	{r7, pc}
    4e74:	00003943 	.word	0x00003943
    4e78:	20002700 	.word	0x20002700
    4e7c:	200026e0 	.word	0x200026e0
    4e80:	20002604 	.word	0x20002604
    4e84:	00003893 	.word	0x00003893
    4e88:	20002698 	.word	0x20002698
    4e8c:	20002600 	.word	0x20002600
    4e90:	200026ec 	.word	0x200026ec

00004e94 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut)
{
    4e94:	b580      	push	{r7, lr}
    4e96:	b082      	sub	sp, #8
    4e98:	af00      	add	r7, sp, #0
    4e9a:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    4e9c:	4b05      	ldr	r3, [pc, #20]	; (4eb4 <vTaskInternalSetTimeOutState+0x20>)
    4e9e:	681a      	ldr	r2, [r3, #0]
    4ea0:	687b      	ldr	r3, [r7, #4]
    4ea2:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    4ea4:	4b04      	ldr	r3, [pc, #16]	; (4eb8 <vTaskInternalSetTimeOutState+0x24>)
    4ea6:	681a      	ldr	r2, [r3, #0]
    4ea8:	687b      	ldr	r3, [r7, #4]
    4eaa:	605a      	str	r2, [r3, #4]
}
    4eac:	46c0      	nop			; (mov r8, r8)
    4eae:	46bd      	mov	sp, r7
    4eb0:	b002      	add	sp, #8
    4eb2:	bd80      	pop	{r7, pc}
    4eb4:	200026f0 	.word	0x200026f0
    4eb8:	200026dc 	.word	0x200026dc

00004ebc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut(TimeOut_t *const pxTimeOut, TickType_t *const pxTicksToWait)
{
    4ebc:	b580      	push	{r7, lr}
    4ebe:	b086      	sub	sp, #24
    4ec0:	af00      	add	r7, sp, #0
    4ec2:	6078      	str	r0, [r7, #4]
    4ec4:	6039      	str	r1, [r7, #0]
	BaseType_t xReturn;

	configASSERT(pxTimeOut);
    4ec6:	687b      	ldr	r3, [r7, #4]
    4ec8:	2b00      	cmp	r3, #0
    4eca:	d101      	bne.n	4ed0 <xTaskCheckForTimeOut+0x14>
    4ecc:	b672      	cpsid	i
    4ece:	e7fe      	b.n	4ece <xTaskCheckForTimeOut+0x12>
	configASSERT(pxTicksToWait);
    4ed0:	683b      	ldr	r3, [r7, #0]
    4ed2:	2b00      	cmp	r3, #0
    4ed4:	d101      	bne.n	4eda <xTaskCheckForTimeOut+0x1e>
    4ed6:	b672      	cpsid	i
    4ed8:	e7fe      	b.n	4ed8 <xTaskCheckForTimeOut+0x1c>

	taskENTER_CRITICAL();
    4eda:	4b1e      	ldr	r3, [pc, #120]	; (4f54 <xTaskCheckForTimeOut+0x98>)
    4edc:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4ede:	4b1e      	ldr	r3, [pc, #120]	; (4f58 <xTaskCheckForTimeOut+0x9c>)
    4ee0:	681b      	ldr	r3, [r3, #0]
    4ee2:	613b      	str	r3, [r7, #16]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4ee4:	687b      	ldr	r3, [r7, #4]
    4ee6:	685b      	ldr	r3, [r3, #4]
    4ee8:	693a      	ldr	r2, [r7, #16]
    4eea:	1ad3      	subs	r3, r2, r3
    4eec:	60fb      	str	r3, [r7, #12]
			xReturn                      = pdTRUE;
		} else
#endif

#if (INCLUDE_vTaskSuspend == 1)
		    if (*pxTicksToWait == portMAX_DELAY) {
    4eee:	683b      	ldr	r3, [r7, #0]
    4ef0:	681b      	ldr	r3, [r3, #0]
    4ef2:	3301      	adds	r3, #1
    4ef4:	d102      	bne.n	4efc <xTaskCheckForTimeOut+0x40>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time
			specified is the maximum block time then the task should block
			indefinitely, and therefore never time out. */
			xReturn = pdFALSE;
    4ef6:	2300      	movs	r3, #0
    4ef8:	617b      	str	r3, [r7, #20]
    4efa:	e024      	b.n	4f46 <xTaskCheckForTimeOut+0x8a>
		} else
#endif

		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    4efc:	687b      	ldr	r3, [r7, #4]
    4efe:	681a      	ldr	r2, [r3, #0]
    4f00:	4b16      	ldr	r3, [pc, #88]	; (4f5c <xTaskCheckForTimeOut+0xa0>)
    4f02:	681b      	ldr	r3, [r3, #0]
    4f04:	429a      	cmp	r2, r3
    4f06:	d007      	beq.n	4f18 <xTaskCheckForTimeOut+0x5c>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    4f08:	687b      	ldr	r3, [r7, #4]
    4f0a:	685a      	ldr	r2, [r3, #4]
    4f0c:	693b      	ldr	r3, [r7, #16]
    4f0e:	429a      	cmp	r2, r3
    4f10:	d802      	bhi.n	4f18 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    4f12:	2301      	movs	r3, #1
    4f14:	617b      	str	r3, [r7, #20]
    4f16:	e016      	b.n	4f46 <xTaskCheckForTimeOut+0x8a>
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
    4f18:	683b      	ldr	r3, [r7, #0]
    4f1a:	681a      	ldr	r2, [r3, #0]
    4f1c:	68fb      	ldr	r3, [r7, #12]
    4f1e:	429a      	cmp	r2, r3
    4f20:	d90c      	bls.n	4f3c <xTaskCheckForTimeOut+0x80>
		                                             whereas others require it to prevent integer conversion errors. */
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4f22:	683b      	ldr	r3, [r7, #0]
    4f24:	681a      	ldr	r2, [r3, #0]
    4f26:	68fb      	ldr	r3, [r7, #12]
    4f28:	1ad2      	subs	r2, r2, r3
    4f2a:	683b      	ldr	r3, [r7, #0]
    4f2c:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
    4f2e:	687b      	ldr	r3, [r7, #4]
    4f30:	0018      	movs	r0, r3
    4f32:	4b0b      	ldr	r3, [pc, #44]	; (4f60 <xTaskCheckForTimeOut+0xa4>)
    4f34:	4798      	blx	r3
			xReturn = pdFALSE;
    4f36:	2300      	movs	r3, #0
    4f38:	617b      	str	r3, [r7, #20]
    4f3a:	e004      	b.n	4f46 <xTaskCheckForTimeOut+0x8a>
		} else {
			*pxTicksToWait = 0;
    4f3c:	683b      	ldr	r3, [r7, #0]
    4f3e:	2200      	movs	r2, #0
    4f40:	601a      	str	r2, [r3, #0]
			xReturn        = pdTRUE;
    4f42:	2301      	movs	r3, #1
    4f44:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
    4f46:	4b07      	ldr	r3, [pc, #28]	; (4f64 <xTaskCheckForTimeOut+0xa8>)
    4f48:	4798      	blx	r3

	return xReturn;
    4f4a:	697b      	ldr	r3, [r7, #20]
}
    4f4c:	0018      	movs	r0, r3
    4f4e:	46bd      	mov	sp, r7
    4f50:	b006      	add	sp, #24
    4f52:	bd80      	pop	{r7, pc}
    4f54:	00003ad1 	.word	0x00003ad1
    4f58:	200026dc 	.word	0x200026dc
    4f5c:	200026f0 	.word	0x200026f0
    4f60:	00004e95 	.word	0x00004e95
    4f64:	00003af5 	.word	0x00003af5

00004f68 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield(void)
{
    4f68:	b580      	push	{r7, lr}
    4f6a:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
    4f6c:	4b02      	ldr	r3, [pc, #8]	; (4f78 <vTaskMissedYield+0x10>)
    4f6e:	2201      	movs	r2, #1
    4f70:	601a      	str	r2, [r3, #0]
}
    4f72:	46c0      	nop			; (mov r8, r8)
    4f74:	46bd      	mov	sp, r7
    4f76:	bd80      	pop	{r7, pc}
    4f78:	200026ec 	.word	0x200026ec

00004f7c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION(prvIdleTask, pvParameters)
{
    4f7c:	b580      	push	{r7, lr}
    4f7e:	b082      	sub	sp, #8
    4f80:	af00      	add	r7, sp, #0
    4f82:	6078      	str	r0, [r7, #4]
	portTASK_CALLS_SECURE_FUNCTIONS();

	for (;;) {
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4f84:	4b04      	ldr	r3, [pc, #16]	; (4f98 <prvIdleTask+0x1c>)
    4f86:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    4f88:	4b04      	ldr	r3, [pc, #16]	; (4f9c <prvIdleTask+0x20>)
    4f8a:	681b      	ldr	r3, [r3, #0]
    4f8c:	2b01      	cmp	r3, #1
    4f8e:	d9f9      	bls.n	4f84 <prvIdleTask+0x8>
				taskYIELD();
    4f90:	4b03      	ldr	r3, [pc, #12]	; (4fa0 <prvIdleTask+0x24>)
    4f92:	4798      	blx	r3
		prvCheckTasksWaitingTermination();
    4f94:	e7f6      	b.n	4f84 <prvIdleTask+0x8>
    4f96:	46c0      	nop			; (mov r8, r8)
    4f98:	00005031 	.word	0x00005031
    4f9c:	20002604 	.word	0x20002604
    4fa0:	00003ab1 	.word	0x00003ab1

00004fa4 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists(void)
{
    4fa4:	b580      	push	{r7, lr}
    4fa6:	b082      	sub	sp, #8
    4fa8:	af00      	add	r7, sp, #0
	UBaseType_t uxPriority;

	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    4faa:	2300      	movs	r3, #0
    4fac:	607b      	str	r3, [r7, #4]
    4fae:	e00c      	b.n	4fca <prvInitialiseTaskLists+0x26>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    4fb0:	687a      	ldr	r2, [r7, #4]
    4fb2:	0013      	movs	r3, r2
    4fb4:	009b      	lsls	r3, r3, #2
    4fb6:	189b      	adds	r3, r3, r2
    4fb8:	009b      	lsls	r3, r3, #2
    4fba:	4a14      	ldr	r2, [pc, #80]	; (500c <prvInitialiseTaskLists+0x68>)
    4fbc:	189b      	adds	r3, r3, r2
    4fbe:	0018      	movs	r0, r3
    4fc0:	4b13      	ldr	r3, [pc, #76]	; (5010 <prvInitialiseTaskLists+0x6c>)
    4fc2:	4798      	blx	r3
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    4fc4:	687b      	ldr	r3, [r7, #4]
    4fc6:	3301      	adds	r3, #1
    4fc8:	607b      	str	r3, [r7, #4]
    4fca:	687b      	ldr	r3, [r7, #4]
    4fcc:	2b04      	cmp	r3, #4
    4fce:	d9ef      	bls.n	4fb0 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise(&xDelayedTaskList1);
    4fd0:	4b10      	ldr	r3, [pc, #64]	; (5014 <prvInitialiseTaskLists+0x70>)
    4fd2:	0018      	movs	r0, r3
    4fd4:	4b0e      	ldr	r3, [pc, #56]	; (5010 <prvInitialiseTaskLists+0x6c>)
    4fd6:	4798      	blx	r3
	vListInitialise(&xDelayedTaskList2);
    4fd8:	4b0f      	ldr	r3, [pc, #60]	; (5018 <prvInitialiseTaskLists+0x74>)
    4fda:	0018      	movs	r0, r3
    4fdc:	4b0c      	ldr	r3, [pc, #48]	; (5010 <prvInitialiseTaskLists+0x6c>)
    4fde:	4798      	blx	r3
	vListInitialise(&xPendingReadyList);
    4fe0:	4b0e      	ldr	r3, [pc, #56]	; (501c <prvInitialiseTaskLists+0x78>)
    4fe2:	0018      	movs	r0, r3
    4fe4:	4b0a      	ldr	r3, [pc, #40]	; (5010 <prvInitialiseTaskLists+0x6c>)
    4fe6:	4798      	blx	r3

#if (INCLUDE_vTaskDelete == 1)
	{
		vListInitialise(&xTasksWaitingTermination);
    4fe8:	4b0d      	ldr	r3, [pc, #52]	; (5020 <prvInitialiseTaskLists+0x7c>)
    4fea:	0018      	movs	r0, r3
    4fec:	4b08      	ldr	r3, [pc, #32]	; (5010 <prvInitialiseTaskLists+0x6c>)
    4fee:	4798      	blx	r3
	}
#endif /* INCLUDE_vTaskDelete */

#if (INCLUDE_vTaskSuspend == 1)
	{
		vListInitialise(&xSuspendedTaskList);
    4ff0:	4b0c      	ldr	r3, [pc, #48]	; (5024 <prvInitialiseTaskLists+0x80>)
    4ff2:	0018      	movs	r0, r3
    4ff4:	4b06      	ldr	r3, [pc, #24]	; (5010 <prvInitialiseTaskLists+0x6c>)
    4ff6:	4798      	blx	r3
	}
#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList         = &xDelayedTaskList1;
    4ff8:	4b0b      	ldr	r3, [pc, #44]	; (5028 <prvInitialiseTaskLists+0x84>)
    4ffa:	4a06      	ldr	r2, [pc, #24]	; (5014 <prvInitialiseTaskLists+0x70>)
    4ffc:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4ffe:	4b0b      	ldr	r3, [pc, #44]	; (502c <prvInitialiseTaskLists+0x88>)
    5000:	4a05      	ldr	r2, [pc, #20]	; (5018 <prvInitialiseTaskLists+0x74>)
    5002:	601a      	str	r2, [r3, #0]
}
    5004:	46c0      	nop			; (mov r8, r8)
    5006:	46bd      	mov	sp, r7
    5008:	b002      	add	sp, #8
    500a:	bd80      	pop	{r7, pc}
    500c:	20002604 	.word	0x20002604
    5010:	00003841 	.word	0x00003841
    5014:	20002668 	.word	0x20002668
    5018:	2000267c 	.word	0x2000267c
    501c:	20002698 	.word	0x20002698
    5020:	200026ac 	.word	0x200026ac
    5024:	200026c4 	.word	0x200026c4
    5028:	20002690 	.word	0x20002690
    502c:	20002694 	.word	0x20002694

00005030 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination(void)
{
    5030:	b580      	push	{r7, lr}
    5032:	b082      	sub	sp, #8
    5034:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
    5036:	e01a      	b.n	506e <prvCheckTasksWaitingTermination+0x3e>
			taskENTER_CRITICAL();
    5038:	4b11      	ldr	r3, [pc, #68]	; (5080 <prvCheckTasksWaitingTermination+0x50>)
    503a:	4798      	blx	r3
			{
				pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xTasksWaitingTermination));
    503c:	4b11      	ldr	r3, [pc, #68]	; (5084 <prvCheckTasksWaitingTermination+0x54>)
    503e:	68db      	ldr	r3, [r3, #12]
    5040:	68db      	ldr	r3, [r3, #12]
    5042:	607b      	str	r3, [r7, #4]
				(void)uxListRemove(&(pxTCB->xStateListItem));
    5044:	687b      	ldr	r3, [r7, #4]
    5046:	3304      	adds	r3, #4
    5048:	0018      	movs	r0, r3
    504a:	4b0f      	ldr	r3, [pc, #60]	; (5088 <prvCheckTasksWaitingTermination+0x58>)
    504c:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
    504e:	4b0f      	ldr	r3, [pc, #60]	; (508c <prvCheckTasksWaitingTermination+0x5c>)
    5050:	681b      	ldr	r3, [r3, #0]
    5052:	1e5a      	subs	r2, r3, #1
    5054:	4b0d      	ldr	r3, [pc, #52]	; (508c <prvCheckTasksWaitingTermination+0x5c>)
    5056:	601a      	str	r2, [r3, #0]
				--uxDeletedTasksWaitingCleanUp;
    5058:	4b0d      	ldr	r3, [pc, #52]	; (5090 <prvCheckTasksWaitingTermination+0x60>)
    505a:	681b      	ldr	r3, [r3, #0]
    505c:	1e5a      	subs	r2, r3, #1
    505e:	4b0c      	ldr	r3, [pc, #48]	; (5090 <prvCheckTasksWaitingTermination+0x60>)
    5060:	601a      	str	r2, [r3, #0]
			}
			taskEXIT_CRITICAL();
    5062:	4b0c      	ldr	r3, [pc, #48]	; (5094 <prvCheckTasksWaitingTermination+0x64>)
    5064:	4798      	blx	r3

			prvDeleteTCB(pxTCB);
    5066:	687b      	ldr	r3, [r7, #4]
    5068:	0018      	movs	r0, r3
    506a:	4b0b      	ldr	r3, [pc, #44]	; (5098 <prvCheckTasksWaitingTermination+0x68>)
    506c:	4798      	blx	r3
		while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
    506e:	4b08      	ldr	r3, [pc, #32]	; (5090 <prvCheckTasksWaitingTermination+0x60>)
    5070:	681b      	ldr	r3, [r3, #0]
    5072:	2b00      	cmp	r3, #0
    5074:	d1e0      	bne.n	5038 <prvCheckTasksWaitingTermination+0x8>
		}
	}
#endif /* INCLUDE_vTaskDelete */
}
    5076:	46c0      	nop			; (mov r8, r8)
    5078:	46bd      	mov	sp, r7
    507a:	b002      	add	sp, #8
    507c:	bd80      	pop	{r7, pc}
    507e:	46c0      	nop			; (mov r8, r8)
    5080:	00003ad1 	.word	0x00003ad1
    5084:	200026ac 	.word	0x200026ac
    5088:	00003943 	.word	0x00003943
    508c:	200026d8 	.word	0x200026d8
    5090:	200026c0 	.word	0x200026c0
    5094:	00003af5 	.word	0x00003af5
    5098:	0000509d 	.word	0x0000509d

0000509c <prvDeleteTCB>:
	/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskDelete == 1)

static void prvDeleteTCB(TCB_t *pxTCB)
{
    509c:	b580      	push	{r7, lr}
    509e:	b082      	sub	sp, #8
    50a0:	af00      	add	r7, sp, #0
    50a2:	6078      	str	r0, [r7, #4]

#if ((configSUPPORT_DYNAMIC_ALLOCATION == 1) && (configSUPPORT_STATIC_ALLOCATION == 0) && (portUSING_MPU_WRAPPERS == 0))
	{
		/* The task can only have been allocated dynamically - free both
		the stack and TCB. */
		vPortFree(pxTCB->pxStack);
    50a4:	687b      	ldr	r3, [r7, #4]
    50a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    50a8:	0018      	movs	r0, r3
    50aa:	4b05      	ldr	r3, [pc, #20]	; (50c0 <prvDeleteTCB+0x24>)
    50ac:	4798      	blx	r3
		vPortFree(pxTCB);
    50ae:	687b      	ldr	r3, [r7, #4]
    50b0:	0018      	movs	r0, r3
    50b2:	4b03      	ldr	r3, [pc, #12]	; (50c0 <prvDeleteTCB+0x24>)
    50b4:	4798      	blx	r3
			configASSERT(pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB);
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif       /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    50b6:	46c0      	nop			; (mov r8, r8)
    50b8:	46bd      	mov	sp, r7
    50ba:	b002      	add	sp, #8
    50bc:	bd80      	pop	{r7, pc}
    50be:	46c0      	nop			; (mov r8, r8)
    50c0:	00003c91 	.word	0x00003c91

000050c4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime(void)
{
    50c4:	b580      	push	{r7, lr}
    50c6:	b082      	sub	sp, #8
    50c8:	af00      	add	r7, sp, #0
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    50ca:	4b0e      	ldr	r3, [pc, #56]	; (5104 <prvResetNextTaskUnblockTime+0x40>)
    50cc:	681b      	ldr	r3, [r3, #0]
    50ce:	681b      	ldr	r3, [r3, #0]
    50d0:	2b00      	cmp	r3, #0
    50d2:	d101      	bne.n	50d8 <prvResetNextTaskUnblockTime+0x14>
    50d4:	2301      	movs	r3, #1
    50d6:	e000      	b.n	50da <prvResetNextTaskUnblockTime+0x16>
    50d8:	2300      	movs	r3, #0
    50da:	2b00      	cmp	r3, #0
    50dc:	d004      	beq.n	50e8 <prvResetNextTaskUnblockTime+0x24>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    50de:	4b0a      	ldr	r3, [pc, #40]	; (5108 <prvResetNextTaskUnblockTime+0x44>)
    50e0:	2201      	movs	r2, #1
    50e2:	4252      	negs	r2, r2
    50e4:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
	}
}
    50e6:	e008      	b.n	50fa <prvResetNextTaskUnblockTime+0x36>
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    50e8:	4b06      	ldr	r3, [pc, #24]	; (5104 <prvResetNextTaskUnblockTime+0x40>)
    50ea:	681b      	ldr	r3, [r3, #0]
    50ec:	68db      	ldr	r3, [r3, #12]
    50ee:	68db      	ldr	r3, [r3, #12]
    50f0:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    50f2:	687b      	ldr	r3, [r7, #4]
    50f4:	685a      	ldr	r2, [r3, #4]
    50f6:	4b04      	ldr	r3, [pc, #16]	; (5108 <prvResetNextTaskUnblockTime+0x44>)
    50f8:	601a      	str	r2, [r3, #0]
}
    50fa:	46c0      	nop			; (mov r8, r8)
    50fc:	46bd      	mov	sp, r7
    50fe:	b002      	add	sp, #8
    5100:	bd80      	pop	{r7, pc}
    5102:	46c0      	nop			; (mov r8, r8)
    5104:	20002690 	.word	0x20002690
    5108:	200026f8 	.word	0x200026f8

0000510c <xTaskGetSchedulerState>:
	/*-----------------------------------------------------------*/

#if ((INCLUDE_xTaskGetSchedulerState == 1) || (configUSE_TIMERS == 1))

BaseType_t xTaskGetSchedulerState(void)
{
    510c:	b580      	push	{r7, lr}
    510e:	b082      	sub	sp, #8
    5110:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

	if (xSchedulerRunning == pdFALSE) {
    5112:	4b0a      	ldr	r3, [pc, #40]	; (513c <xTaskGetSchedulerState+0x30>)
    5114:	681b      	ldr	r3, [r3, #0]
    5116:	2b00      	cmp	r3, #0
    5118:	d102      	bne.n	5120 <xTaskGetSchedulerState+0x14>
		xReturn = taskSCHEDULER_NOT_STARTED;
    511a:	2301      	movs	r3, #1
    511c:	607b      	str	r3, [r7, #4]
    511e:	e008      	b.n	5132 <xTaskGetSchedulerState+0x26>
	} else {
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    5120:	4b07      	ldr	r3, [pc, #28]	; (5140 <xTaskGetSchedulerState+0x34>)
    5122:	681b      	ldr	r3, [r3, #0]
    5124:	2b00      	cmp	r3, #0
    5126:	d102      	bne.n	512e <xTaskGetSchedulerState+0x22>
			xReturn = taskSCHEDULER_RUNNING;
    5128:	2302      	movs	r3, #2
    512a:	607b      	str	r3, [r7, #4]
    512c:	e001      	b.n	5132 <xTaskGetSchedulerState+0x26>
		} else {
			xReturn = taskSCHEDULER_SUSPENDED;
    512e:	2300      	movs	r3, #0
    5130:	607b      	str	r3, [r7, #4]
		}
	}

	return xReturn;
    5132:	687b      	ldr	r3, [r7, #4]
}
    5134:	0018      	movs	r0, r3
    5136:	46bd      	mov	sp, r7
    5138:	b002      	add	sp, #8
    513a:	bd80      	pop	{r7, pc}
    513c:	200026e4 	.word	0x200026e4
    5140:	20002700 	.word	0x20002700

00005144 <xTaskGenericNotify>:

#if (configUSE_TASK_NOTIFICATIONS == 1)

BaseType_t xTaskGenericNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction,
                              uint32_t *pulPreviousNotificationValue)
{
    5144:	b580      	push	{r7, lr}
    5146:	b088      	sub	sp, #32
    5148:	af00      	add	r7, sp, #0
    514a:	60f8      	str	r0, [r7, #12]
    514c:	60b9      	str	r1, [r7, #8]
    514e:	603b      	str	r3, [r7, #0]
    5150:	1dfb      	adds	r3, r7, #7
    5152:	701a      	strb	r2, [r3, #0]
	TCB_t *    pxTCB;
	BaseType_t xReturn = pdPASS;
    5154:	2301      	movs	r3, #1
    5156:	61fb      	str	r3, [r7, #28]
	uint8_t    ucOriginalNotifyState;

	configASSERT(xTaskToNotify);
    5158:	68fb      	ldr	r3, [r7, #12]
    515a:	2b00      	cmp	r3, #0
    515c:	d101      	bne.n	5162 <xTaskGenericNotify+0x1e>
    515e:	b672      	cpsid	i
    5160:	e7fe      	b.n	5160 <xTaskGenericNotify+0x1c>
	pxTCB = (TCB_t *)xTaskToNotify;
    5162:	68fb      	ldr	r3, [r7, #12]
    5164:	61bb      	str	r3, [r7, #24]

	taskENTER_CRITICAL();
    5166:	4b39      	ldr	r3, [pc, #228]	; (524c <xTaskGenericNotify+0x108>)
    5168:	4798      	blx	r3
	{
		if (pulPreviousNotificationValue != NULL) {
    516a:	683b      	ldr	r3, [r7, #0]
    516c:	2b00      	cmp	r3, #0
    516e:	d003      	beq.n	5178 <xTaskGenericNotify+0x34>
			*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5170:	69bb      	ldr	r3, [r7, #24]
    5172:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    5174:	683b      	ldr	r3, [r7, #0]
    5176:	601a      	str	r2, [r3, #0]
		}

		ucOriginalNotifyState = pxTCB->ucNotifyState;
    5178:	2317      	movs	r3, #23
    517a:	18fb      	adds	r3, r7, r3
    517c:	69ba      	ldr	r2, [r7, #24]
    517e:	2148      	movs	r1, #72	; 0x48
    5180:	5c52      	ldrb	r2, [r2, r1]
    5182:	701a      	strb	r2, [r3, #0]

		pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5184:	69bb      	ldr	r3, [r7, #24]
    5186:	2248      	movs	r2, #72	; 0x48
    5188:	2102      	movs	r1, #2
    518a:	5499      	strb	r1, [r3, r2]

		switch (eAction) {
    518c:	1dfb      	adds	r3, r7, #7
    518e:	781b      	ldrb	r3, [r3, #0]
    5190:	2b04      	cmp	r3, #4
    5192:	d822      	bhi.n	51da <xTaskGenericNotify+0x96>
    5194:	009a      	lsls	r2, r3, #2
    5196:	4b2e      	ldr	r3, [pc, #184]	; (5250 <xTaskGenericNotify+0x10c>)
    5198:	18d3      	adds	r3, r2, r3
    519a:	681b      	ldr	r3, [r3, #0]
    519c:	469f      	mov	pc, r3
		case eSetBits:
			pxTCB->ulNotifiedValue |= ulValue;
    519e:	69bb      	ldr	r3, [r7, #24]
    51a0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    51a2:	68bb      	ldr	r3, [r7, #8]
    51a4:	431a      	orrs	r2, r3
    51a6:	69bb      	ldr	r3, [r7, #24]
    51a8:	645a      	str	r2, [r3, #68]	; 0x44
			break;
    51aa:	e016      	b.n	51da <xTaskGenericNotify+0x96>

		case eIncrement:
			(pxTCB->ulNotifiedValue)++;
    51ac:	69bb      	ldr	r3, [r7, #24]
    51ae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    51b0:	1c5a      	adds	r2, r3, #1
    51b2:	69bb      	ldr	r3, [r7, #24]
    51b4:	645a      	str	r2, [r3, #68]	; 0x44
			break;
    51b6:	e010      	b.n	51da <xTaskGenericNotify+0x96>

		case eSetValueWithOverwrite:
			pxTCB->ulNotifiedValue = ulValue;
    51b8:	69bb      	ldr	r3, [r7, #24]
    51ba:	68ba      	ldr	r2, [r7, #8]
    51bc:	645a      	str	r2, [r3, #68]	; 0x44
			break;
    51be:	e00c      	b.n	51da <xTaskGenericNotify+0x96>

		case eSetValueWithoutOverwrite:
			if (ucOriginalNotifyState != taskNOTIFICATION_RECEIVED) {
    51c0:	2317      	movs	r3, #23
    51c2:	18fb      	adds	r3, r7, r3
    51c4:	781b      	ldrb	r3, [r3, #0]
    51c6:	2b02      	cmp	r3, #2
    51c8:	d003      	beq.n	51d2 <xTaskGenericNotify+0x8e>
				pxTCB->ulNotifiedValue = ulValue;
    51ca:	69bb      	ldr	r3, [r7, #24]
    51cc:	68ba      	ldr	r2, [r7, #8]
    51ce:	645a      	str	r2, [r3, #68]	; 0x44
			} else {
				/* The value could not be written to the task. */
				xReturn = pdFAIL;
			}
			break;
    51d0:	e003      	b.n	51da <xTaskGenericNotify+0x96>
				xReturn = pdFAIL;
    51d2:	2300      	movs	r3, #0
    51d4:	61fb      	str	r3, [r7, #28]
			break;
    51d6:	e000      	b.n	51da <xTaskGenericNotify+0x96>

		case eNoAction:
			/* The task is being notified without its notify value being
			updated. */
			break;
    51d8:	46c0      	nop			; (mov r8, r8)

		traceTASK_NOTIFY();

		/* If the task is in the blocked state specifically to wait for a
		notification then unblock it now. */
		if (ucOriginalNotifyState == taskWAITING_NOTIFICATION) {
    51da:	2317      	movs	r3, #23
    51dc:	18fb      	adds	r3, r7, r3
    51de:	781b      	ldrb	r3, [r3, #0]
    51e0:	2b01      	cmp	r3, #1
    51e2:	d12b      	bne.n	523c <xTaskGenericNotify+0xf8>
			(void)uxListRemove(&(pxTCB->xStateListItem));
    51e4:	69bb      	ldr	r3, [r7, #24]
    51e6:	3304      	adds	r3, #4
    51e8:	0018      	movs	r0, r3
    51ea:	4b1a      	ldr	r3, [pc, #104]	; (5254 <xTaskGenericNotify+0x110>)
    51ec:	4798      	blx	r3
			prvAddTaskToReadyList(pxTCB);
    51ee:	69bb      	ldr	r3, [r7, #24]
    51f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    51f2:	4b19      	ldr	r3, [pc, #100]	; (5258 <xTaskGenericNotify+0x114>)
    51f4:	681b      	ldr	r3, [r3, #0]
    51f6:	429a      	cmp	r2, r3
    51f8:	d903      	bls.n	5202 <xTaskGenericNotify+0xbe>
    51fa:	69bb      	ldr	r3, [r7, #24]
    51fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    51fe:	4b16      	ldr	r3, [pc, #88]	; (5258 <xTaskGenericNotify+0x114>)
    5200:	601a      	str	r2, [r3, #0]
    5202:	69bb      	ldr	r3, [r7, #24]
    5204:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    5206:	0013      	movs	r3, r2
    5208:	009b      	lsls	r3, r3, #2
    520a:	189b      	adds	r3, r3, r2
    520c:	009b      	lsls	r3, r3, #2
    520e:	4a13      	ldr	r2, [pc, #76]	; (525c <xTaskGenericNotify+0x118>)
    5210:	189a      	adds	r2, r3, r2
    5212:	69bb      	ldr	r3, [r7, #24]
    5214:	3304      	adds	r3, #4
    5216:	0019      	movs	r1, r3
    5218:	0010      	movs	r0, r2
    521a:	4b11      	ldr	r3, [pc, #68]	; (5260 <xTaskGenericNotify+0x11c>)
    521c:	4798      	blx	r3

			/* The task should not have been on an event list. */
			configASSERT(listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL);
    521e:	69bb      	ldr	r3, [r7, #24]
    5220:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5222:	2b00      	cmp	r3, #0
    5224:	d001      	beq.n	522a <xTaskGenericNotify+0xe6>
    5226:	b672      	cpsid	i
    5228:	e7fe      	b.n	5228 <xTaskGenericNotify+0xe4>
				earliest possible time. */
				prvResetNextTaskUnblockTime();
			}
#endif

			if (pxTCB->uxPriority > pxCurrentTCB->uxPriority) {
    522a:	69bb      	ldr	r3, [r7, #24]
    522c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    522e:	4b0d      	ldr	r3, [pc, #52]	; (5264 <xTaskGenericNotify+0x120>)
    5230:	681b      	ldr	r3, [r3, #0]
    5232:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    5234:	429a      	cmp	r2, r3
    5236:	d901      	bls.n	523c <xTaskGenericNotify+0xf8>
				/* The notified task has a priority above the currently
				executing task so a yield is required. */
				taskYIELD_IF_USING_PREEMPTION();
    5238:	4b0b      	ldr	r3, [pc, #44]	; (5268 <xTaskGenericNotify+0x124>)
    523a:	4798      	blx	r3
			}
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    523c:	4b0b      	ldr	r3, [pc, #44]	; (526c <xTaskGenericNotify+0x128>)
    523e:	4798      	blx	r3

	return xReturn;
    5240:	69fb      	ldr	r3, [r7, #28]
}
    5242:	0018      	movs	r0, r3
    5244:	46bd      	mov	sp, r7
    5246:	b008      	add	sp, #32
    5248:	bd80      	pop	{r7, pc}
    524a:	46c0      	nop			; (mov r8, r8)
    524c:	00003ad1 	.word	0x00003ad1
    5250:	00005ef8 	.word	0x00005ef8
    5254:	00003943 	.word	0x00003943
    5258:	200026e0 	.word	0x200026e0
    525c:	20002604 	.word	0x20002604
    5260:	00003893 	.word	0x00003893
    5264:	20002600 	.word	0x20002600
    5268:	00003ab1 	.word	0x00003ab1
    526c:	00003af5 	.word	0x00003af5

00005270 <xTaskGenericNotifyFromISR>:

#if (configUSE_TASK_NOTIFICATIONS == 1)

BaseType_t xTaskGenericNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction,
                                     uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken)
{
    5270:	b580      	push	{r7, lr}
    5272:	b088      	sub	sp, #32
    5274:	af00      	add	r7, sp, #0
    5276:	60f8      	str	r0, [r7, #12]
    5278:	60b9      	str	r1, [r7, #8]
    527a:	603b      	str	r3, [r7, #0]
    527c:	1dfb      	adds	r3, r7, #7
    527e:	701a      	strb	r2, [r3, #0]
	TCB_t *     pxTCB;
	uint8_t     ucOriginalNotifyState;
	BaseType_t  xReturn = pdPASS;
    5280:	2301      	movs	r3, #1
    5282:	61fb      	str	r3, [r7, #28]
	UBaseType_t uxSavedInterruptStatus;

	configASSERT(xTaskToNotify);
    5284:	68fb      	ldr	r3, [r7, #12]
    5286:	2b00      	cmp	r3, #0
    5288:	d101      	bne.n	528e <xTaskGenericNotifyFromISR+0x1e>
    528a:	b672      	cpsid	i
    528c:	e7fe      	b.n	528c <xTaskGenericNotifyFromISR+0x1c>
	simple as possible.  More information (albeit Cortex-M specific) is
	provided on the following link:
	http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	pxTCB = (TCB_t *)xTaskToNotify;
    528e:	68fb      	ldr	r3, [r7, #12]
    5290:	61bb      	str	r3, [r7, #24]

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5292:	4b45      	ldr	r3, [pc, #276]	; (53a8 <xTaskGenericNotifyFromISR+0x138>)
    5294:	4798      	blx	r3
    5296:	0003      	movs	r3, r0
    5298:	617b      	str	r3, [r7, #20]
	{
		if (pulPreviousNotificationValue != NULL) {
    529a:	683b      	ldr	r3, [r7, #0]
    529c:	2b00      	cmp	r3, #0
    529e:	d003      	beq.n	52a8 <xTaskGenericNotifyFromISR+0x38>
			*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    52a0:	69bb      	ldr	r3, [r7, #24]
    52a2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    52a4:	683b      	ldr	r3, [r7, #0]
    52a6:	601a      	str	r2, [r3, #0]
		}

		ucOriginalNotifyState = pxTCB->ucNotifyState;
    52a8:	2313      	movs	r3, #19
    52aa:	18fb      	adds	r3, r7, r3
    52ac:	69ba      	ldr	r2, [r7, #24]
    52ae:	2148      	movs	r1, #72	; 0x48
    52b0:	5c52      	ldrb	r2, [r2, r1]
    52b2:	701a      	strb	r2, [r3, #0]
		pxTCB->ucNotifyState  = taskNOTIFICATION_RECEIVED;
    52b4:	69bb      	ldr	r3, [r7, #24]
    52b6:	2248      	movs	r2, #72	; 0x48
    52b8:	2102      	movs	r1, #2
    52ba:	5499      	strb	r1, [r3, r2]

		switch (eAction) {
    52bc:	1dfb      	adds	r3, r7, #7
    52be:	781b      	ldrb	r3, [r3, #0]
    52c0:	2b04      	cmp	r3, #4
    52c2:	d822      	bhi.n	530a <xTaskGenericNotifyFromISR+0x9a>
    52c4:	009a      	lsls	r2, r3, #2
    52c6:	4b39      	ldr	r3, [pc, #228]	; (53ac <xTaskGenericNotifyFromISR+0x13c>)
    52c8:	18d3      	adds	r3, r2, r3
    52ca:	681b      	ldr	r3, [r3, #0]
    52cc:	469f      	mov	pc, r3
		case eSetBits:
			pxTCB->ulNotifiedValue |= ulValue;
    52ce:	69bb      	ldr	r3, [r7, #24]
    52d0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    52d2:	68bb      	ldr	r3, [r7, #8]
    52d4:	431a      	orrs	r2, r3
    52d6:	69bb      	ldr	r3, [r7, #24]
    52d8:	645a      	str	r2, [r3, #68]	; 0x44
			break;
    52da:	e016      	b.n	530a <xTaskGenericNotifyFromISR+0x9a>

		case eIncrement:
			(pxTCB->ulNotifiedValue)++;
    52dc:	69bb      	ldr	r3, [r7, #24]
    52de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    52e0:	1c5a      	adds	r2, r3, #1
    52e2:	69bb      	ldr	r3, [r7, #24]
    52e4:	645a      	str	r2, [r3, #68]	; 0x44
			break;
    52e6:	e010      	b.n	530a <xTaskGenericNotifyFromISR+0x9a>

		case eSetValueWithOverwrite:
			pxTCB->ulNotifiedValue = ulValue;
    52e8:	69bb      	ldr	r3, [r7, #24]
    52ea:	68ba      	ldr	r2, [r7, #8]
    52ec:	645a      	str	r2, [r3, #68]	; 0x44
			break;
    52ee:	e00c      	b.n	530a <xTaskGenericNotifyFromISR+0x9a>

		case eSetValueWithoutOverwrite:
			if (ucOriginalNotifyState != taskNOTIFICATION_RECEIVED) {
    52f0:	2313      	movs	r3, #19
    52f2:	18fb      	adds	r3, r7, r3
    52f4:	781b      	ldrb	r3, [r3, #0]
    52f6:	2b02      	cmp	r3, #2
    52f8:	d003      	beq.n	5302 <xTaskGenericNotifyFromISR+0x92>
				pxTCB->ulNotifiedValue = ulValue;
    52fa:	69bb      	ldr	r3, [r7, #24]
    52fc:	68ba      	ldr	r2, [r7, #8]
    52fe:	645a      	str	r2, [r3, #68]	; 0x44
			} else {
				/* The value could not be written to the task. */
				xReturn = pdFAIL;
			}
			break;
    5300:	e003      	b.n	530a <xTaskGenericNotifyFromISR+0x9a>
				xReturn = pdFAIL;
    5302:	2300      	movs	r3, #0
    5304:	61fb      	str	r3, [r7, #28]
			break;
    5306:	e000      	b.n	530a <xTaskGenericNotifyFromISR+0x9a>

		case eNoAction:
			/* The task is being notified without its notify value being
			updated. */
			break;
    5308:	46c0      	nop			; (mov r8, r8)

		traceTASK_NOTIFY_FROM_ISR();

		/* If the task is in the blocked state specifically to wait for a
		notification then unblock it now. */
		if (ucOriginalNotifyState == taskWAITING_NOTIFICATION) {
    530a:	2313      	movs	r3, #19
    530c:	18fb      	adds	r3, r7, r3
    530e:	781b      	ldrb	r3, [r3, #0]
    5310:	2b01      	cmp	r3, #1
    5312:	d140      	bne.n	5396 <xTaskGenericNotifyFromISR+0x126>
			/* The task should not have been on an event list. */
			configASSERT(listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL);
    5314:	69bb      	ldr	r3, [r7, #24]
    5316:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5318:	2b00      	cmp	r3, #0
    531a:	d001      	beq.n	5320 <xTaskGenericNotifyFromISR+0xb0>
    531c:	b672      	cpsid	i
    531e:	e7fe      	b.n	531e <xTaskGenericNotifyFromISR+0xae>

			if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    5320:	4b23      	ldr	r3, [pc, #140]	; (53b0 <xTaskGenericNotifyFromISR+0x140>)
    5322:	681b      	ldr	r3, [r3, #0]
    5324:	2b00      	cmp	r3, #0
    5326:	d11d      	bne.n	5364 <xTaskGenericNotifyFromISR+0xf4>
				(void)uxListRemove(&(pxTCB->xStateListItem));
    5328:	69bb      	ldr	r3, [r7, #24]
    532a:	3304      	adds	r3, #4
    532c:	0018      	movs	r0, r3
    532e:	4b21      	ldr	r3, [pc, #132]	; (53b4 <xTaskGenericNotifyFromISR+0x144>)
    5330:	4798      	blx	r3
				prvAddTaskToReadyList(pxTCB);
    5332:	69bb      	ldr	r3, [r7, #24]
    5334:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    5336:	4b20      	ldr	r3, [pc, #128]	; (53b8 <xTaskGenericNotifyFromISR+0x148>)
    5338:	681b      	ldr	r3, [r3, #0]
    533a:	429a      	cmp	r2, r3
    533c:	d903      	bls.n	5346 <xTaskGenericNotifyFromISR+0xd6>
    533e:	69bb      	ldr	r3, [r7, #24]
    5340:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    5342:	4b1d      	ldr	r3, [pc, #116]	; (53b8 <xTaskGenericNotifyFromISR+0x148>)
    5344:	601a      	str	r2, [r3, #0]
    5346:	69bb      	ldr	r3, [r7, #24]
    5348:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    534a:	0013      	movs	r3, r2
    534c:	009b      	lsls	r3, r3, #2
    534e:	189b      	adds	r3, r3, r2
    5350:	009b      	lsls	r3, r3, #2
    5352:	4a1a      	ldr	r2, [pc, #104]	; (53bc <xTaskGenericNotifyFromISR+0x14c>)
    5354:	189a      	adds	r2, r3, r2
    5356:	69bb      	ldr	r3, [r7, #24]
    5358:	3304      	adds	r3, #4
    535a:	0019      	movs	r1, r3
    535c:	0010      	movs	r0, r2
    535e:	4b18      	ldr	r3, [pc, #96]	; (53c0 <xTaskGenericNotifyFromISR+0x150>)
    5360:	4798      	blx	r3
    5362:	e007      	b.n	5374 <xTaskGenericNotifyFromISR+0x104>
			} else {
				/* The delayed and ready lists cannot be accessed, so hold
				this task pending until the scheduler is resumed. */
				vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
    5364:	69bb      	ldr	r3, [r7, #24]
    5366:	3318      	adds	r3, #24
    5368:	001a      	movs	r2, r3
    536a:	4b16      	ldr	r3, [pc, #88]	; (53c4 <xTaskGenericNotifyFromISR+0x154>)
    536c:	0011      	movs	r1, r2
    536e:	0018      	movs	r0, r3
    5370:	4b13      	ldr	r3, [pc, #76]	; (53c0 <xTaskGenericNotifyFromISR+0x150>)
    5372:	4798      	blx	r3
			}

			if (pxTCB->uxPriority > pxCurrentTCB->uxPriority) {
    5374:	69bb      	ldr	r3, [r7, #24]
    5376:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    5378:	4b13      	ldr	r3, [pc, #76]	; (53c8 <xTaskGenericNotifyFromISR+0x158>)
    537a:	681b      	ldr	r3, [r3, #0]
    537c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    537e:	429a      	cmp	r2, r3
    5380:	d909      	bls.n	5396 <xTaskGenericNotifyFromISR+0x126>
				/* The notified task has a priority above the currently
				executing task so a yield is required. */
				if (pxHigherPriorityTaskWoken != NULL) {
    5382:	6abb      	ldr	r3, [r7, #40]	; 0x28
    5384:	2b00      	cmp	r3, #0
    5386:	d003      	beq.n	5390 <xTaskGenericNotifyFromISR+0x120>
					*pxHigherPriorityTaskWoken = pdTRUE;
    5388:	6abb      	ldr	r3, [r7, #40]	; 0x28
    538a:	2201      	movs	r2, #1
    538c:	601a      	str	r2, [r3, #0]
    538e:	e002      	b.n	5396 <xTaskGenericNotifyFromISR+0x126>
				} else {
					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5390:	4b0e      	ldr	r3, [pc, #56]	; (53cc <xTaskGenericNotifyFromISR+0x15c>)
    5392:	2201      	movs	r2, #1
    5394:	601a      	str	r2, [r3, #0]
			} else {
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
    5396:	697b      	ldr	r3, [r7, #20]
    5398:	0018      	movs	r0, r3
    539a:	4b0d      	ldr	r3, [pc, #52]	; (53d0 <xTaskGenericNotifyFromISR+0x160>)
    539c:	4798      	blx	r3

	return xReturn;
    539e:	69fb      	ldr	r3, [r7, #28]
}
    53a0:	0018      	movs	r0, r3
    53a2:	46bd      	mov	sp, r7
    53a4:	b008      	add	sp, #32
    53a6:	bd80      	pop	{r7, pc}
    53a8:	00003b25 	.word	0x00003b25
    53ac:	00005f0c 	.word	0x00005f0c
    53b0:	20002700 	.word	0x20002700
    53b4:	00003943 	.word	0x00003943
    53b8:	200026e0 	.word	0x200026e0
    53bc:	20002604 	.word	0x20002604
    53c0:	00003893 	.word	0x00003893
    53c4:	20002698 	.word	0x20002698
    53c8:	20002600 	.word	0x20002600
    53cc:	200026ec 	.word	0x200026ec
    53d0:	00003b31 	.word	0x00003b31

000053d4 <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
    53d4:	b580      	push	{r7, lr}
    53d6:	b084      	sub	sp, #16
    53d8:	af00      	add	r7, sp, #0
    53da:	6078      	str	r0, [r7, #4]
    53dc:	6039      	str	r1, [r7, #0]
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
    53de:	4b21      	ldr	r3, [pc, #132]	; (5464 <prvAddCurrentTaskToDelayedList+0x90>)
    53e0:	681b      	ldr	r3, [r3, #0]
    53e2:	60fb      	str	r3, [r7, #12]
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
    53e4:	4b20      	ldr	r3, [pc, #128]	; (5468 <prvAddCurrentTaskToDelayedList+0x94>)
    53e6:	681b      	ldr	r3, [r3, #0]
    53e8:	3304      	adds	r3, #4
    53ea:	0018      	movs	r0, r3
    53ec:	4b1f      	ldr	r3, [pc, #124]	; (546c <prvAddCurrentTaskToDelayedList+0x98>)
    53ee:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    53f0:	687b      	ldr	r3, [r7, #4]
    53f2:	3301      	adds	r3, #1
    53f4:	d10b      	bne.n	540e <prvAddCurrentTaskToDelayedList+0x3a>
    53f6:	683b      	ldr	r3, [r7, #0]
    53f8:	2b00      	cmp	r3, #0
    53fa:	d008      	beq.n	540e <prvAddCurrentTaskToDelayedList+0x3a>
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
    53fc:	4b1a      	ldr	r3, [pc, #104]	; (5468 <prvAddCurrentTaskToDelayedList+0x94>)
    53fe:	681b      	ldr	r3, [r3, #0]
    5400:	1d1a      	adds	r2, r3, #4
    5402:	4b1b      	ldr	r3, [pc, #108]	; (5470 <prvAddCurrentTaskToDelayedList+0x9c>)
    5404:	0011      	movs	r1, r2
    5406:	0018      	movs	r0, r3
    5408:	4b1a      	ldr	r3, [pc, #104]	; (5474 <prvAddCurrentTaskToDelayedList+0xa0>)
    540a:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
    540c:	e026      	b.n	545c <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
    540e:	68fa      	ldr	r2, [r7, #12]
    5410:	687b      	ldr	r3, [r7, #4]
    5412:	18d3      	adds	r3, r2, r3
    5414:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
    5416:	4b14      	ldr	r3, [pc, #80]	; (5468 <prvAddCurrentTaskToDelayedList+0x94>)
    5418:	681b      	ldr	r3, [r3, #0]
    541a:	68ba      	ldr	r2, [r7, #8]
    541c:	605a      	str	r2, [r3, #4]
			if (xTimeToWake < xConstTickCount) {
    541e:	68ba      	ldr	r2, [r7, #8]
    5420:	68fb      	ldr	r3, [r7, #12]
    5422:	429a      	cmp	r2, r3
    5424:	d209      	bcs.n	543a <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    5426:	4b14      	ldr	r3, [pc, #80]	; (5478 <prvAddCurrentTaskToDelayedList+0xa4>)
    5428:	681a      	ldr	r2, [r3, #0]
    542a:	4b0f      	ldr	r3, [pc, #60]	; (5468 <prvAddCurrentTaskToDelayedList+0x94>)
    542c:	681b      	ldr	r3, [r3, #0]
    542e:	3304      	adds	r3, #4
    5430:	0019      	movs	r1, r3
    5432:	0010      	movs	r0, r2
    5434:	4b11      	ldr	r3, [pc, #68]	; (547c <prvAddCurrentTaskToDelayedList+0xa8>)
    5436:	4798      	blx	r3
}
    5438:	e010      	b.n	545c <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    543a:	4b11      	ldr	r3, [pc, #68]	; (5480 <prvAddCurrentTaskToDelayedList+0xac>)
    543c:	681a      	ldr	r2, [r3, #0]
    543e:	4b0a      	ldr	r3, [pc, #40]	; (5468 <prvAddCurrentTaskToDelayedList+0x94>)
    5440:	681b      	ldr	r3, [r3, #0]
    5442:	3304      	adds	r3, #4
    5444:	0019      	movs	r1, r3
    5446:	0010      	movs	r0, r2
    5448:	4b0c      	ldr	r3, [pc, #48]	; (547c <prvAddCurrentTaskToDelayedList+0xa8>)
    544a:	4798      	blx	r3
				if (xTimeToWake < xNextTaskUnblockTime) {
    544c:	4b0d      	ldr	r3, [pc, #52]	; (5484 <prvAddCurrentTaskToDelayedList+0xb0>)
    544e:	681b      	ldr	r3, [r3, #0]
    5450:	68ba      	ldr	r2, [r7, #8]
    5452:	429a      	cmp	r2, r3
    5454:	d202      	bcs.n	545c <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
    5456:	4b0b      	ldr	r3, [pc, #44]	; (5484 <prvAddCurrentTaskToDelayedList+0xb0>)
    5458:	68ba      	ldr	r2, [r7, #8]
    545a:	601a      	str	r2, [r3, #0]
}
    545c:	46c0      	nop			; (mov r8, r8)
    545e:	46bd      	mov	sp, r7
    5460:	b004      	add	sp, #16
    5462:	bd80      	pop	{r7, pc}
    5464:	200026dc 	.word	0x200026dc
    5468:	20002600 	.word	0x20002600
    546c:	00003943 	.word	0x00003943
    5470:	200026c4 	.word	0x200026c4
    5474:	00003893 	.word	0x00003893
    5478:	20002694 	.word	0x20002694
    547c:	000038d7 	.word	0x000038d7
    5480:	20002690 	.word	0x20002690
    5484:	200026f8 	.word	0x200026f8

00005488 <xTimerCreateTimerTask>:
                                  void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction,
                                  Timer_t *pxNewTimer) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask(void)
{
    5488:	b590      	push	{r4, r7, lr}
    548a:	b085      	sub	sp, #20
    548c:	af02      	add	r7, sp, #8
	BaseType_t xReturn = pdFAIL;
    548e:	2300      	movs	r3, #0
    5490:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    5492:	4b0e      	ldr	r3, [pc, #56]	; (54cc <xTimerCreateTimerTask+0x44>)
    5494:	4798      	blx	r3

	if (xTimerQueue != NULL) {
    5496:	4b0e      	ldr	r3, [pc, #56]	; (54d0 <xTimerCreateTimerTask+0x48>)
    5498:	681b      	ldr	r3, [r3, #0]
    549a:	2b00      	cmp	r3, #0
    549c:	d00c      	beq.n	54b8 <xTimerCreateTimerTask+0x30>
				xReturn = pdPASS;
			}
		}
#else
		{
			xReturn = xTaskCreate(prvTimerTask,
    549e:	2380      	movs	r3, #128	; 0x80
    54a0:	005a      	lsls	r2, r3, #1
    54a2:	490c      	ldr	r1, [pc, #48]	; (54d4 <xTimerCreateTimerTask+0x4c>)
    54a4:	480c      	ldr	r0, [pc, #48]	; (54d8 <xTimerCreateTimerTask+0x50>)
    54a6:	4b0d      	ldr	r3, [pc, #52]	; (54dc <xTimerCreateTimerTask+0x54>)
    54a8:	9301      	str	r3, [sp, #4]
    54aa:	2302      	movs	r3, #2
    54ac:	9300      	str	r3, [sp, #0]
    54ae:	2300      	movs	r3, #0
    54b0:	4c0b      	ldr	r4, [pc, #44]	; (54e0 <xTimerCreateTimerTask+0x58>)
    54b2:	47a0      	blx	r4
    54b4:	0003      	movs	r3, r0
    54b6:	607b      	str	r3, [r7, #4]
#endif /* configSUPPORT_STATIC_ALLOCATION */
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT(xReturn);
    54b8:	687b      	ldr	r3, [r7, #4]
    54ba:	2b00      	cmp	r3, #0
    54bc:	d101      	bne.n	54c2 <xTimerCreateTimerTask+0x3a>
    54be:	b672      	cpsid	i
    54c0:	e7fe      	b.n	54c0 <xTimerCreateTimerTask+0x38>
	return xReturn;
    54c2:	687b      	ldr	r3, [r7, #4]
}
    54c4:	0018      	movs	r0, r3
    54c6:	46bd      	mov	sp, r7
    54c8:	b003      	add	sp, #12
    54ca:	bd90      	pop	{r4, r7, pc}
    54cc:	000059c9 	.word	0x000059c9
    54d0:	20002734 	.word	0x20002734
    54d4:	00005f20 	.word	0x00005f20
    54d8:	00005609 	.word	0x00005609
    54dc:	20002738 	.word	0x20002738
    54e0:	00004651 	.word	0x00004651

000054e4 <xTimerGenericCommand>:
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand(TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue,
                                BaseType_t *const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait)
{
    54e4:	b590      	push	{r4, r7, lr}
    54e6:	b089      	sub	sp, #36	; 0x24
    54e8:	af00      	add	r7, sp, #0
    54ea:	60f8      	str	r0, [r7, #12]
    54ec:	60b9      	str	r1, [r7, #8]
    54ee:	607a      	str	r2, [r7, #4]
    54f0:	603b      	str	r3, [r7, #0]
	BaseType_t          xReturn = pdFAIL;
    54f2:	2300      	movs	r3, #0
    54f4:	61fb      	str	r3, [r7, #28]
	DaemonTaskMessage_t xMessage;

	configASSERT(xTimer);
    54f6:	68fb      	ldr	r3, [r7, #12]
    54f8:	2b00      	cmp	r3, #0
    54fa:	d101      	bne.n	5500 <xTimerGenericCommand+0x1c>
    54fc:	b672      	cpsid	i
    54fe:	e7fe      	b.n	54fe <xTimerGenericCommand+0x1a>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if (xTimerQueue != NULL) {
    5500:	4b1e      	ldr	r3, [pc, #120]	; (557c <xTimerGenericCommand+0x98>)
    5502:	681b      	ldr	r3, [r3, #0]
    5504:	2b00      	cmp	r3, #0
    5506:	d033      	beq.n	5570 <xTimerGenericCommand+0x8c>
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID                       = xCommandID;
    5508:	2310      	movs	r3, #16
    550a:	18fb      	adds	r3, r7, r3
    550c:	68ba      	ldr	r2, [r7, #8]
    550e:	601a      	str	r2, [r3, #0]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    5510:	2310      	movs	r3, #16
    5512:	18fb      	adds	r3, r7, r3
    5514:	687a      	ldr	r2, [r7, #4]
    5516:	605a      	str	r2, [r3, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    5518:	2310      	movs	r3, #16
    551a:	18fb      	adds	r3, r7, r3
    551c:	68fa      	ldr	r2, [r7, #12]
    551e:	609a      	str	r2, [r3, #8]

		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    5520:	68bb      	ldr	r3, [r7, #8]
    5522:	2b05      	cmp	r3, #5
    5524:	dc1a      	bgt.n	555c <xTimerGenericCommand+0x78>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    5526:	4b16      	ldr	r3, [pc, #88]	; (5580 <xTimerGenericCommand+0x9c>)
    5528:	4798      	blx	r3
    552a:	0003      	movs	r3, r0
    552c:	2b02      	cmp	r3, #2
    552e:	d10a      	bne.n	5546 <xTimerGenericCommand+0x62>
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    5530:	4b12      	ldr	r3, [pc, #72]	; (557c <xTimerGenericCommand+0x98>)
    5532:	6818      	ldr	r0, [r3, #0]
    5534:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    5536:	2310      	movs	r3, #16
    5538:	18f9      	adds	r1, r7, r3
    553a:	2300      	movs	r3, #0
    553c:	4c11      	ldr	r4, [pc, #68]	; (5584 <xTimerGenericCommand+0xa0>)
    553e:	47a0      	blx	r4
    5540:	0003      	movs	r3, r0
    5542:	61fb      	str	r3, [r7, #28]
    5544:	e014      	b.n	5570 <xTimerGenericCommand+0x8c>
			} else {
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    5546:	4b0d      	ldr	r3, [pc, #52]	; (557c <xTimerGenericCommand+0x98>)
    5548:	6818      	ldr	r0, [r3, #0]
    554a:	2310      	movs	r3, #16
    554c:	18f9      	adds	r1, r7, r3
    554e:	2300      	movs	r3, #0
    5550:	2200      	movs	r2, #0
    5552:	4c0c      	ldr	r4, [pc, #48]	; (5584 <xTimerGenericCommand+0xa0>)
    5554:	47a0      	blx	r4
    5556:	0003      	movs	r3, r0
    5558:	61fb      	str	r3, [r7, #28]
    555a:	e009      	b.n	5570 <xTimerGenericCommand+0x8c>
			}
		} else {
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    555c:	4b07      	ldr	r3, [pc, #28]	; (557c <xTimerGenericCommand+0x98>)
    555e:	6818      	ldr	r0, [r3, #0]
    5560:	683a      	ldr	r2, [r7, #0]
    5562:	2310      	movs	r3, #16
    5564:	18f9      	adds	r1, r7, r3
    5566:	2300      	movs	r3, #0
    5568:	4c07      	ldr	r4, [pc, #28]	; (5588 <xTimerGenericCommand+0xa4>)
    556a:	47a0      	blx	r4
    556c:	0003      	movs	r3, r0
    556e:	61fb      	str	r3, [r7, #28]
		traceTIMER_COMMAND_SEND(xTimer, xCommandID, xOptionalValue, xReturn);
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
    5570:	69fb      	ldr	r3, [r7, #28]
}
    5572:	0018      	movs	r0, r3
    5574:	46bd      	mov	sp, r7
    5576:	b009      	add	sp, #36	; 0x24
    5578:	bd90      	pop	{r4, r7, pc}
    557a:	46c0      	nop			; (mov r8, r8)
    557c:	20002734 	.word	0x20002734
    5580:	0000510d 	.word	0x0000510d
    5584:	00003e2d 	.word	0x00003e2d
    5588:	0000400d 	.word	0x0000400d

0000558c <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer(const TickType_t xNextExpireTime, const TickType_t xTimeNow)
{
    558c:	b590      	push	{r4, r7, lr}
    558e:	b087      	sub	sp, #28
    5590:	af02      	add	r7, sp, #8
    5592:	6078      	str	r0, [r7, #4]
    5594:	6039      	str	r1, [r7, #0]
	BaseType_t     xResult;
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    5596:	4b18      	ldr	r3, [pc, #96]	; (55f8 <prvProcessExpiredTimer+0x6c>)
    5598:	681b      	ldr	r3, [r3, #0]
    559a:	68db      	ldr	r3, [r3, #12]
    559c:	68db      	ldr	r3, [r3, #12]
    559e:	60fb      	str	r3, [r7, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    55a0:	68fb      	ldr	r3, [r7, #12]
    55a2:	3304      	adds	r3, #4
    55a4:	0018      	movs	r0, r3
    55a6:	4b15      	ldr	r3, [pc, #84]	; (55fc <prvProcessExpiredTimer+0x70>)
    55a8:	4798      	blx	r3
	traceTIMER_EXPIRED(pxTimer);

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    55aa:	68fb      	ldr	r3, [r7, #12]
    55ac:	69db      	ldr	r3, [r3, #28]
    55ae:	2b01      	cmp	r3, #1
    55b0:	d119      	bne.n	55e6 <prvProcessExpiredTimer+0x5a>
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if (prvInsertTimerInActiveList(
		        pxTimer, (xNextExpireTime + pxTimer->xTimerPeriodInTicks), xTimeNow, xNextExpireTime)
    55b2:	68fb      	ldr	r3, [r7, #12]
    55b4:	699a      	ldr	r2, [r3, #24]
		if (prvInsertTimerInActiveList(
    55b6:	687b      	ldr	r3, [r7, #4]
    55b8:	18d1      	adds	r1, r2, r3
    55ba:	687b      	ldr	r3, [r7, #4]
    55bc:	683a      	ldr	r2, [r7, #0]
    55be:	68f8      	ldr	r0, [r7, #12]
    55c0:	4c0f      	ldr	r4, [pc, #60]	; (5600 <prvProcessExpiredTimer+0x74>)
    55c2:	47a0      	blx	r4
    55c4:	1e03      	subs	r3, r0, #0
    55c6:	d00e      	beq.n	55e6 <prvProcessExpiredTimer+0x5a>
		    != pdFALSE) {
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    55c8:	687a      	ldr	r2, [r7, #4]
    55ca:	68f8      	ldr	r0, [r7, #12]
    55cc:	2300      	movs	r3, #0
    55ce:	9300      	str	r3, [sp, #0]
    55d0:	2300      	movs	r3, #0
    55d2:	2100      	movs	r1, #0
    55d4:	4c0b      	ldr	r4, [pc, #44]	; (5604 <prvProcessExpiredTimer+0x78>)
    55d6:	47a0      	blx	r4
    55d8:	0003      	movs	r3, r0
    55da:	60bb      	str	r3, [r7, #8]
			configASSERT(xResult);
    55dc:	68bb      	ldr	r3, [r7, #8]
    55de:	2b00      	cmp	r3, #0
    55e0:	d101      	bne.n	55e6 <prvProcessExpiredTimer+0x5a>
    55e2:	b672      	cpsid	i
    55e4:	e7fe      	b.n	55e4 <prvProcessExpiredTimer+0x58>
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    55e6:	68fb      	ldr	r3, [r7, #12]
    55e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    55ea:	68fa      	ldr	r2, [r7, #12]
    55ec:	0010      	movs	r0, r2
    55ee:	4798      	blx	r3
}
    55f0:	46c0      	nop			; (mov r8, r8)
    55f2:	46bd      	mov	sp, r7
    55f4:	b005      	add	sp, #20
    55f6:	bd90      	pop	{r4, r7, pc}
    55f8:	2000272c 	.word	0x2000272c
    55fc:	00003943 	.word	0x00003943
    5600:	00005769 	.word	0x00005769
    5604:	000054e5 	.word	0x000054e5

00005608 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask(void *pvParameters)
{
    5608:	b580      	push	{r7, lr}
    560a:	b084      	sub	sp, #16
    560c:	af00      	add	r7, sp, #0
    560e:	6078      	str	r0, [r7, #4]
#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */

	for (;;) {
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime(&xListWasEmpty);
    5610:	2308      	movs	r3, #8
    5612:	18fb      	adds	r3, r7, r3
    5614:	0018      	movs	r0, r3
    5616:	4b06      	ldr	r3, [pc, #24]	; (5630 <prvTimerTask+0x28>)
    5618:	4798      	blx	r3
    561a:	0003      	movs	r3, r0
    561c:	60fb      	str	r3, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask(xNextExpireTime, xListWasEmpty);
    561e:	68ba      	ldr	r2, [r7, #8]
    5620:	68fb      	ldr	r3, [r7, #12]
    5622:	0011      	movs	r1, r2
    5624:	0018      	movs	r0, r3
    5626:	4b03      	ldr	r3, [pc, #12]	; (5634 <prvTimerTask+0x2c>)
    5628:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
    562a:	4b03      	ldr	r3, [pc, #12]	; (5638 <prvTimerTask+0x30>)
    562c:	4798      	blx	r3
		xNextExpireTime = prvGetNextExpireTime(&xListWasEmpty);
    562e:	e7ef      	b.n	5610 <prvTimerTask+0x8>
    5630:	000056e1 	.word	0x000056e1
    5634:	0000563d 	.word	0x0000563d
    5638:	000057f1 	.word	0x000057f1

0000563c <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask(const TickType_t xNextExpireTime, BaseType_t xListWasEmpty)
{
    563c:	b580      	push	{r7, lr}
    563e:	b084      	sub	sp, #16
    5640:	af00      	add	r7, sp, #0
    5642:	6078      	str	r0, [r7, #4]
    5644:	6039      	str	r1, [r7, #0]
	TickType_t xTimeNow;
	BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    5646:	4b1e      	ldr	r3, [pc, #120]	; (56c0 <prvProcessTimerOrBlockTask+0x84>)
    5648:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    564a:	2308      	movs	r3, #8
    564c:	18fb      	adds	r3, r7, r3
    564e:	0018      	movs	r0, r3
    5650:	4b1c      	ldr	r3, [pc, #112]	; (56c4 <prvProcessTimerOrBlockTask+0x88>)
    5652:	4798      	blx	r3
    5654:	0003      	movs	r3, r0
    5656:	60fb      	str	r3, [r7, #12]
		if (xTimerListsWereSwitched == pdFALSE) {
    5658:	68bb      	ldr	r3, [r7, #8]
    565a:	2b00      	cmp	r3, #0
    565c:	d129      	bne.n	56b2 <prvProcessTimerOrBlockTask+0x76>
			/* The tick count has not overflowed, has the timer expired? */
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    565e:	683b      	ldr	r3, [r7, #0]
    5660:	2b00      	cmp	r3, #0
    5662:	d10c      	bne.n	567e <prvProcessTimerOrBlockTask+0x42>
    5664:	687a      	ldr	r2, [r7, #4]
    5666:	68fb      	ldr	r3, [r7, #12]
    5668:	429a      	cmp	r2, r3
    566a:	d808      	bhi.n	567e <prvProcessTimerOrBlockTask+0x42>
				(void)xTaskResumeAll();
    566c:	4b16      	ldr	r3, [pc, #88]	; (56c8 <prvProcessTimerOrBlockTask+0x8c>)
    566e:	4798      	blx	r3
				prvProcessExpiredTimer(xNextExpireTime, xTimeNow);
    5670:	68fa      	ldr	r2, [r7, #12]
    5672:	687b      	ldr	r3, [r7, #4]
    5674:	0011      	movs	r1, r2
    5676:	0018      	movs	r0, r3
    5678:	4b14      	ldr	r3, [pc, #80]	; (56cc <prvProcessTimerOrBlockTask+0x90>)
    567a:	4798      	blx	r3
			}
		} else {
			(void)xTaskResumeAll();
		}
	}
}
    567c:	e01b      	b.n	56b6 <prvProcessTimerOrBlockTask+0x7a>
				if (xListWasEmpty != pdFALSE) {
    567e:	683b      	ldr	r3, [r7, #0]
    5680:	2b00      	cmp	r3, #0
    5682:	d006      	beq.n	5692 <prvProcessTimerOrBlockTask+0x56>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    5684:	4b12      	ldr	r3, [pc, #72]	; (56d0 <prvProcessTimerOrBlockTask+0x94>)
    5686:	681b      	ldr	r3, [r3, #0]
    5688:	681b      	ldr	r3, [r3, #0]
    568a:	425a      	negs	r2, r3
    568c:	4153      	adcs	r3, r2
    568e:	b2db      	uxtb	r3, r3
    5690:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    5692:	4b10      	ldr	r3, [pc, #64]	; (56d4 <prvProcessTimerOrBlockTask+0x98>)
    5694:	6818      	ldr	r0, [r3, #0]
    5696:	687a      	ldr	r2, [r7, #4]
    5698:	68fb      	ldr	r3, [r7, #12]
    569a:	1ad3      	subs	r3, r2, r3
    569c:	683a      	ldr	r2, [r7, #0]
    569e:	0019      	movs	r1, r3
    56a0:	4b0d      	ldr	r3, [pc, #52]	; (56d8 <prvProcessTimerOrBlockTask+0x9c>)
    56a2:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    56a4:	4b08      	ldr	r3, [pc, #32]	; (56c8 <prvProcessTimerOrBlockTask+0x8c>)
    56a6:	4798      	blx	r3
    56a8:	1e03      	subs	r3, r0, #0
    56aa:	d104      	bne.n	56b6 <prvProcessTimerOrBlockTask+0x7a>
					portYIELD_WITHIN_API();
    56ac:	4b0b      	ldr	r3, [pc, #44]	; (56dc <prvProcessTimerOrBlockTask+0xa0>)
    56ae:	4798      	blx	r3
}
    56b0:	e001      	b.n	56b6 <prvProcessTimerOrBlockTask+0x7a>
			(void)xTaskResumeAll();
    56b2:	4b05      	ldr	r3, [pc, #20]	; (56c8 <prvProcessTimerOrBlockTask+0x8c>)
    56b4:	4798      	blx	r3
}
    56b6:	46c0      	nop			; (mov r8, r8)
    56b8:	46bd      	mov	sp, r7
    56ba:	b004      	add	sp, #16
    56bc:	bd80      	pop	{r7, pc}
    56be:	46c0      	nop			; (mov r8, r8)
    56c0:	000049bd 	.word	0x000049bd
    56c4:	00005721 	.word	0x00005721
    56c8:	000049d5 	.word	0x000049d5
    56cc:	0000558d 	.word	0x0000558d
    56d0:	20002730 	.word	0x20002730
    56d4:	20002734 	.word	0x20002734
    56d8:	00004535 	.word	0x00004535
    56dc:	00003ab1 	.word	0x00003ab1

000056e0 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime(BaseType_t *const pxListWasEmpty)
{
    56e0:	b580      	push	{r7, lr}
    56e2:	b084      	sub	sp, #16
    56e4:	af00      	add	r7, sp, #0
    56e6:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    56e8:	4b0c      	ldr	r3, [pc, #48]	; (571c <prvGetNextExpireTime+0x3c>)
    56ea:	681b      	ldr	r3, [r3, #0]
    56ec:	681b      	ldr	r3, [r3, #0]
    56ee:	425a      	negs	r2, r3
    56f0:	4153      	adcs	r3, r2
    56f2:	b2db      	uxtb	r3, r3
    56f4:	001a      	movs	r2, r3
    56f6:	687b      	ldr	r3, [r7, #4]
    56f8:	601a      	str	r2, [r3, #0]
	if (*pxListWasEmpty == pdFALSE) {
    56fa:	687b      	ldr	r3, [r7, #4]
    56fc:	681b      	ldr	r3, [r3, #0]
    56fe:	2b00      	cmp	r3, #0
    5700:	d105      	bne.n	570e <prvGetNextExpireTime+0x2e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    5702:	4b06      	ldr	r3, [pc, #24]	; (571c <prvGetNextExpireTime+0x3c>)
    5704:	681b      	ldr	r3, [r3, #0]
    5706:	68db      	ldr	r3, [r3, #12]
    5708:	681b      	ldr	r3, [r3, #0]
    570a:	60fb      	str	r3, [r7, #12]
    570c:	e001      	b.n	5712 <prvGetNextExpireTime+0x32>
	} else {
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = (TickType_t)0U;
    570e:	2300      	movs	r3, #0
    5710:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
    5712:	68fb      	ldr	r3, [r7, #12]
}
    5714:	0018      	movs	r0, r3
    5716:	46bd      	mov	sp, r7
    5718:	b004      	add	sp, #16
    571a:	bd80      	pop	{r7, pc}
    571c:	2000272c 	.word	0x2000272c

00005720 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow(BaseType_t *const pxTimerListsWereSwitched)
{
    5720:	b580      	push	{r7, lr}
    5722:	b084      	sub	sp, #16
    5724:	af00      	add	r7, sp, #0
    5726:	6078      	str	r0, [r7, #4]
	TickType_t                        xTimeNow;
	PRIVILEGED_DATA static TickType_t xLastTime
	    = (TickType_t)0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    5728:	4b0c      	ldr	r3, [pc, #48]	; (575c <prvSampleTimeNow+0x3c>)
    572a:	4798      	blx	r3
    572c:	0003      	movs	r3, r0
    572e:	60fb      	str	r3, [r7, #12]

	if (xTimeNow < xLastTime) {
    5730:	4b0b      	ldr	r3, [pc, #44]	; (5760 <prvSampleTimeNow+0x40>)
    5732:	681b      	ldr	r3, [r3, #0]
    5734:	68fa      	ldr	r2, [r7, #12]
    5736:	429a      	cmp	r2, r3
    5738:	d205      	bcs.n	5746 <prvSampleTimeNow+0x26>
		prvSwitchTimerLists();
    573a:	4b0a      	ldr	r3, [pc, #40]	; (5764 <prvSampleTimeNow+0x44>)
    573c:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
    573e:	687b      	ldr	r3, [r7, #4]
    5740:	2201      	movs	r2, #1
    5742:	601a      	str	r2, [r3, #0]
    5744:	e002      	b.n	574c <prvSampleTimeNow+0x2c>
	} else {
		*pxTimerListsWereSwitched = pdFALSE;
    5746:	687b      	ldr	r3, [r7, #4]
    5748:	2200      	movs	r2, #0
    574a:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
    574c:	4b04      	ldr	r3, [pc, #16]	; (5760 <prvSampleTimeNow+0x40>)
    574e:	68fa      	ldr	r2, [r7, #12]
    5750:	601a      	str	r2, [r3, #0]

	return xTimeNow;
    5752:	68fb      	ldr	r3, [r7, #12]
}
    5754:	0018      	movs	r0, r3
    5756:	46bd      	mov	sp, r7
    5758:	b004      	add	sp, #16
    575a:	bd80      	pop	{r7, pc}
    575c:	00004b09 	.word	0x00004b09
    5760:	2000273c 	.word	0x2000273c
    5764:	00005909 	.word	0x00005909

00005768 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList(Timer_t *const pxTimer, const TickType_t xNextExpiryTime,
                                             const TickType_t xTimeNow, const TickType_t xCommandTime)
{
    5768:	b580      	push	{r7, lr}
    576a:	b086      	sub	sp, #24
    576c:	af00      	add	r7, sp, #0
    576e:	60f8      	str	r0, [r7, #12]
    5770:	60b9      	str	r1, [r7, #8]
    5772:	607a      	str	r2, [r7, #4]
    5774:	603b      	str	r3, [r7, #0]
	BaseType_t xProcessTimerNow = pdFALSE;
    5776:	2300      	movs	r3, #0
    5778:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    577a:	68fb      	ldr	r3, [r7, #12]
    577c:	68ba      	ldr	r2, [r7, #8]
    577e:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    5780:	68fb      	ldr	r3, [r7, #12]
    5782:	68fa      	ldr	r2, [r7, #12]
    5784:	611a      	str	r2, [r3, #16]

	if (xNextExpiryTime <= xTimeNow) {
    5786:	68ba      	ldr	r2, [r7, #8]
    5788:	687b      	ldr	r3, [r7, #4]
    578a:	429a      	cmp	r2, r3
    578c:	d812      	bhi.n	57b4 <prvInsertTimerInActiveList+0x4c>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if (((TickType_t)(xTimeNow - xCommandTime))
    578e:	687a      	ldr	r2, [r7, #4]
    5790:	683b      	ldr	r3, [r7, #0]
    5792:	1ad2      	subs	r2, r2, r3
		    >= pxTimer->xTimerPeriodInTicks) /*lint !e961 MISRA exception as the casts are only redundant for some
    5794:	68fb      	ldr	r3, [r7, #12]
    5796:	699b      	ldr	r3, [r3, #24]
		if (((TickType_t)(xTimeNow - xCommandTime))
    5798:	429a      	cmp	r2, r3
    579a:	d302      	bcc.n	57a2 <prvInsertTimerInActiveList+0x3a>
		                                        ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    579c:	2301      	movs	r3, #1
    579e:	617b      	str	r3, [r7, #20]
    57a0:	e01b      	b.n	57da <prvInsertTimerInActiveList+0x72>
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    57a2:	4b10      	ldr	r3, [pc, #64]	; (57e4 <prvInsertTimerInActiveList+0x7c>)
    57a4:	681a      	ldr	r2, [r3, #0]
    57a6:	68fb      	ldr	r3, [r7, #12]
    57a8:	3304      	adds	r3, #4
    57aa:	0019      	movs	r1, r3
    57ac:	0010      	movs	r0, r2
    57ae:	4b0e      	ldr	r3, [pc, #56]	; (57e8 <prvInsertTimerInActiveList+0x80>)
    57b0:	4798      	blx	r3
    57b2:	e012      	b.n	57da <prvInsertTimerInActiveList+0x72>
		}
	} else {
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    57b4:	687a      	ldr	r2, [r7, #4]
    57b6:	683b      	ldr	r3, [r7, #0]
    57b8:	429a      	cmp	r2, r3
    57ba:	d206      	bcs.n	57ca <prvInsertTimerInActiveList+0x62>
    57bc:	68ba      	ldr	r2, [r7, #8]
    57be:	683b      	ldr	r3, [r7, #0]
    57c0:	429a      	cmp	r2, r3
    57c2:	d302      	bcc.n	57ca <prvInsertTimerInActiveList+0x62>
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    57c4:	2301      	movs	r3, #1
    57c6:	617b      	str	r3, [r7, #20]
    57c8:	e007      	b.n	57da <prvInsertTimerInActiveList+0x72>
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    57ca:	4b08      	ldr	r3, [pc, #32]	; (57ec <prvInsertTimerInActiveList+0x84>)
    57cc:	681a      	ldr	r2, [r3, #0]
    57ce:	68fb      	ldr	r3, [r7, #12]
    57d0:	3304      	adds	r3, #4
    57d2:	0019      	movs	r1, r3
    57d4:	0010      	movs	r0, r2
    57d6:	4b04      	ldr	r3, [pc, #16]	; (57e8 <prvInsertTimerInActiveList+0x80>)
    57d8:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
    57da:	697b      	ldr	r3, [r7, #20]
}
    57dc:	0018      	movs	r0, r3
    57de:	46bd      	mov	sp, r7
    57e0:	b006      	add	sp, #24
    57e2:	bd80      	pop	{r7, pc}
    57e4:	20002730 	.word	0x20002730
    57e8:	000038d7 	.word	0x000038d7
    57ec:	2000272c 	.word	0x2000272c

000057f0 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void prvProcessReceivedCommands(void)
{
    57f0:	b590      	push	{r4, r7, lr}
    57f2:	b08b      	sub	sp, #44	; 0x2c
    57f4:	af02      	add	r7, sp, #8
	DaemonTaskMessage_t xMessage;
	Timer_t *           pxTimer;
	BaseType_t          xTimerListsWereSwitched, xResult;
	TickType_t          xTimeNow;

	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    57f6:	e068      	b.n	58ca <prvProcessReceivedCommands+0xda>
		}
#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if (xMessage.xMessageID >= (BaseType_t)0) {
    57f8:	2308      	movs	r3, #8
    57fa:	18fb      	adds	r3, r7, r3
    57fc:	681b      	ldr	r3, [r3, #0]
    57fe:	2b00      	cmp	r3, #0
    5800:	db63      	blt.n	58ca <prvProcessReceivedCommands+0xda>
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    5802:	2308      	movs	r3, #8
    5804:	18fb      	adds	r3, r7, r3
    5806:	689b      	ldr	r3, [r3, #8]
    5808:	61fb      	str	r3, [r7, #28]

			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    580a:	69fb      	ldr	r3, [r7, #28]
    580c:	695b      	ldr	r3, [r3, #20]
    580e:	2b00      	cmp	r3, #0
    5810:	d004      	beq.n	581c <prvProcessReceivedCommands+0x2c>
			    == pdFALSE) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
			{
				/* The timer is in a list, remove it. */
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    5812:	69fb      	ldr	r3, [r7, #28]
    5814:	3304      	adds	r3, #4
    5816:	0018      	movs	r0, r3
    5818:	4b33      	ldr	r3, [pc, #204]	; (58e8 <prvProcessReceivedCommands+0xf8>)
    581a:	4798      	blx	r3
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    581c:	1d3b      	adds	r3, r7, #4
    581e:	0018      	movs	r0, r3
    5820:	4b32      	ldr	r3, [pc, #200]	; (58ec <prvProcessReceivedCommands+0xfc>)
    5822:	4798      	blx	r3
    5824:	0003      	movs	r3, r0
    5826:	61bb      	str	r3, [r7, #24]

			switch (xMessage.xMessageID) {
    5828:	2308      	movs	r3, #8
    582a:	18fb      	adds	r3, r7, r3
    582c:	681b      	ldr	r3, [r3, #0]
    582e:	2b09      	cmp	r3, #9
    5830:	d84a      	bhi.n	58c8 <prvProcessReceivedCommands+0xd8>
    5832:	009a      	lsls	r2, r3, #2
    5834:	4b2e      	ldr	r3, [pc, #184]	; (58f0 <prvProcessReceivedCommands+0x100>)
    5836:	18d3      	adds	r3, r2, r3
    5838:	681b      	ldr	r3, [r3, #0]
    583a:	469f      	mov	pc, r3
			case tmrCOMMAND_RESET:
			case tmrCOMMAND_RESET_FROM_ISR:
			case tmrCOMMAND_START_DONT_TRACE:
				/* Start or restart a timer. */
				if (prvInsertTimerInActiveList(pxTimer,
				                               xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks,
    583c:	2308      	movs	r3, #8
    583e:	18fb      	adds	r3, r7, r3
    5840:	685a      	ldr	r2, [r3, #4]
    5842:	69fb      	ldr	r3, [r7, #28]
    5844:	699b      	ldr	r3, [r3, #24]
				if (prvInsertTimerInActiveList(pxTimer,
    5846:	18d1      	adds	r1, r2, r3
    5848:	2308      	movs	r3, #8
    584a:	18fb      	adds	r3, r7, r3
    584c:	685b      	ldr	r3, [r3, #4]
    584e:	69ba      	ldr	r2, [r7, #24]
    5850:	69f8      	ldr	r0, [r7, #28]
    5852:	4c28      	ldr	r4, [pc, #160]	; (58f4 <prvProcessReceivedCommands+0x104>)
    5854:	47a0      	blx	r4
    5856:	1e03      	subs	r3, r0, #0
    5858:	d037      	beq.n	58ca <prvProcessReceivedCommands+0xda>
				                               xTimeNow,
				                               xMessage.u.xTimerParameters.xMessageValue)
				    != pdFALSE) {
					/* The timer expired before it was added to the active
					timer list.  Process it now. */
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    585a:	69fb      	ldr	r3, [r7, #28]
    585c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    585e:	69fa      	ldr	r2, [r7, #28]
    5860:	0010      	movs	r0, r2
    5862:	4798      	blx	r3
					traceTIMER_EXPIRED(pxTimer);

					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    5864:	69fb      	ldr	r3, [r7, #28]
    5866:	69db      	ldr	r3, [r3, #28]
    5868:	2b01      	cmp	r3, #1
    586a:	d12e      	bne.n	58ca <prvProcessReceivedCommands+0xda>
						xResult = xTimerGenericCommand(pxTimer,
						                               tmrCOMMAND_START_DONT_TRACE,
						                               xMessage.u.xTimerParameters.xMessageValue
    586c:	2308      	movs	r3, #8
    586e:	18fb      	adds	r3, r7, r3
    5870:	685a      	ldr	r2, [r3, #4]
						                                   + pxTimer->xTimerPeriodInTicks,
    5872:	69fb      	ldr	r3, [r7, #28]
    5874:	699b      	ldr	r3, [r3, #24]
						xResult = xTimerGenericCommand(pxTimer,
    5876:	18d2      	adds	r2, r2, r3
    5878:	69f8      	ldr	r0, [r7, #28]
    587a:	2300      	movs	r3, #0
    587c:	9300      	str	r3, [sp, #0]
    587e:	2300      	movs	r3, #0
    5880:	2100      	movs	r1, #0
    5882:	4c1d      	ldr	r4, [pc, #116]	; (58f8 <prvProcessReceivedCommands+0x108>)
    5884:	47a0      	blx	r4
    5886:	0003      	movs	r3, r0
    5888:	617b      	str	r3, [r7, #20]
						                               NULL,
						                               tmrNO_DELAY);
						configASSERT(xResult);
    588a:	697b      	ldr	r3, [r7, #20]
    588c:	2b00      	cmp	r3, #0
    588e:	d11c      	bne.n	58ca <prvProcessReceivedCommands+0xda>
    5890:	b672      	cpsid	i
    5892:	e7fe      	b.n	5892 <prvProcessReceivedCommands+0xa2>
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD:
			case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    5894:	2308      	movs	r3, #8
    5896:	18fb      	adds	r3, r7, r3
    5898:	685a      	ldr	r2, [r3, #4]
    589a:	69fb      	ldr	r3, [r7, #28]
    589c:	619a      	str	r2, [r3, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    589e:	69fb      	ldr	r3, [r7, #28]
    58a0:	699b      	ldr	r3, [r3, #24]
    58a2:	2b00      	cmp	r3, #0
    58a4:	d101      	bne.n	58aa <prvProcessReceivedCommands+0xba>
    58a6:	b672      	cpsid	i
    58a8:	e7fe      	b.n	58a8 <prvProcessReceivedCommands+0xb8>
				therefore set to the current time, and as the period cannot
				be zero the next expiry time can only be in the future,
				meaning (unlike for the xTimerStart() case above) there is
				no fail case that needs to be handled here. */
				(void)prvInsertTimerInActiveList(
				    pxTimer, (xTimeNow + pxTimer->xTimerPeriodInTicks), xTimeNow, xTimeNow);
    58aa:	69fb      	ldr	r3, [r7, #28]
    58ac:	699a      	ldr	r2, [r3, #24]
				(void)prvInsertTimerInActiveList(
    58ae:	69bb      	ldr	r3, [r7, #24]
    58b0:	18d1      	adds	r1, r2, r3
    58b2:	69bb      	ldr	r3, [r7, #24]
    58b4:	69ba      	ldr	r2, [r7, #24]
    58b6:	69f8      	ldr	r0, [r7, #28]
    58b8:	4c0e      	ldr	r4, [pc, #56]	; (58f4 <prvProcessReceivedCommands+0x104>)
    58ba:	47a0      	blx	r4
				break;
    58bc:	e005      	b.n	58ca <prvProcessReceivedCommands+0xda>
allocated. */
#if ((configSUPPORT_DYNAMIC_ALLOCATION == 1) && (configSUPPORT_STATIC_ALLOCATION == 0))
			{
				/* The timer can only have been allocated dynamically -
				free it again. */
				vPortFree(pxTimer);
    58be:	69fb      	ldr	r3, [r7, #28]
    58c0:	0018      	movs	r0, r3
    58c2:	4b0e      	ldr	r3, [pc, #56]	; (58fc <prvProcessReceivedCommands+0x10c>)
    58c4:	4798      	blx	r3
				} else {
					mtCOVERAGE_TEST_MARKER();
				}
			}
#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
			break;
    58c6:	e000      	b.n	58ca <prvProcessReceivedCommands+0xda>

			default:
				/* Don't expect to get here. */
				break;
    58c8:	46c0      	nop			; (mov r8, r8)
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    58ca:	4b0d      	ldr	r3, [pc, #52]	; (5900 <prvProcessReceivedCommands+0x110>)
    58cc:	681b      	ldr	r3, [r3, #0]
    58ce:	2208      	movs	r2, #8
    58d0:	18b9      	adds	r1, r7, r2
    58d2:	2200      	movs	r2, #0
    58d4:	0018      	movs	r0, r3
    58d6:	4b0b      	ldr	r3, [pc, #44]	; (5904 <prvProcessReceivedCommands+0x114>)
    58d8:	4798      	blx	r3
    58da:	1e03      	subs	r3, r0, #0
    58dc:	d18c      	bne.n	57f8 <prvProcessReceivedCommands+0x8>
			}
		}
	}
}
    58de:	46c0      	nop			; (mov r8, r8)
    58e0:	46bd      	mov	sp, r7
    58e2:	b009      	add	sp, #36	; 0x24
    58e4:	bd90      	pop	{r4, r7, pc}
    58e6:	46c0      	nop			; (mov r8, r8)
    58e8:	00003943 	.word	0x00003943
    58ec:	00005721 	.word	0x00005721
    58f0:	00005f28 	.word	0x00005f28
    58f4:	00005769 	.word	0x00005769
    58f8:	000054e5 	.word	0x000054e5
    58fc:	00003c91 	.word	0x00003c91
    5900:	20002734 	.word	0x20002734
    5904:	0000412d 	.word	0x0000412d

00005908 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists(void)
{
    5908:	b590      	push	{r4, r7, lr}
    590a:	b089      	sub	sp, #36	; 0x24
    590c:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    590e:	e03e      	b.n	598e <prvSwitchTimerLists+0x86>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    5910:	4b28      	ldr	r3, [pc, #160]	; (59b4 <prvSwitchTimerLists+0xac>)
    5912:	681b      	ldr	r3, [r3, #0]
    5914:	68db      	ldr	r3, [r3, #12]
    5916:	681b      	ldr	r3, [r3, #0]
    5918:	617b      	str	r3, [r7, #20]

		/* Remove the timer from the list. */
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    591a:	4b26      	ldr	r3, [pc, #152]	; (59b4 <prvSwitchTimerLists+0xac>)
    591c:	681b      	ldr	r3, [r3, #0]
    591e:	68db      	ldr	r3, [r3, #12]
    5920:	68db      	ldr	r3, [r3, #12]
    5922:	613b      	str	r3, [r7, #16]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    5924:	693b      	ldr	r3, [r7, #16]
    5926:	3304      	adds	r3, #4
    5928:	0018      	movs	r0, r3
    592a:	4b23      	ldr	r3, [pc, #140]	; (59b8 <prvSwitchTimerLists+0xb0>)
    592c:	4798      	blx	r3
		traceTIMER_EXPIRED(pxTimer);

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    592e:	693b      	ldr	r3, [r7, #16]
    5930:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5932:	693a      	ldr	r2, [r7, #16]
    5934:	0010      	movs	r0, r2
    5936:	4798      	blx	r3

		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    5938:	693b      	ldr	r3, [r7, #16]
    593a:	69db      	ldr	r3, [r3, #28]
    593c:	2b01      	cmp	r3, #1
    593e:	d126      	bne.n	598e <prvSwitchTimerLists+0x86>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    5940:	693b      	ldr	r3, [r7, #16]
    5942:	699a      	ldr	r2, [r3, #24]
    5944:	697b      	ldr	r3, [r7, #20]
    5946:	18d3      	adds	r3, r2, r3
    5948:	60fb      	str	r3, [r7, #12]
			if (xReloadTime > xNextExpireTime) {
    594a:	68fa      	ldr	r2, [r7, #12]
    594c:	697b      	ldr	r3, [r7, #20]
    594e:	429a      	cmp	r2, r3
    5950:	d90e      	bls.n	5970 <prvSwitchTimerLists+0x68>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    5952:	693b      	ldr	r3, [r7, #16]
    5954:	68fa      	ldr	r2, [r7, #12]
    5956:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    5958:	693b      	ldr	r3, [r7, #16]
    595a:	693a      	ldr	r2, [r7, #16]
    595c:	611a      	str	r2, [r3, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    595e:	4b15      	ldr	r3, [pc, #84]	; (59b4 <prvSwitchTimerLists+0xac>)
    5960:	681a      	ldr	r2, [r3, #0]
    5962:	693b      	ldr	r3, [r7, #16]
    5964:	3304      	adds	r3, #4
    5966:	0019      	movs	r1, r3
    5968:	0010      	movs	r0, r2
    596a:	4b14      	ldr	r3, [pc, #80]	; (59bc <prvSwitchTimerLists+0xb4>)
    596c:	4798      	blx	r3
    596e:	e00e      	b.n	598e <prvSwitchTimerLists+0x86>
			} else {
				xResult
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    5970:	697a      	ldr	r2, [r7, #20]
    5972:	6938      	ldr	r0, [r7, #16]
    5974:	2300      	movs	r3, #0
    5976:	9300      	str	r3, [sp, #0]
    5978:	2300      	movs	r3, #0
    597a:	2100      	movs	r1, #0
    597c:	4c10      	ldr	r4, [pc, #64]	; (59c0 <prvSwitchTimerLists+0xb8>)
    597e:	47a0      	blx	r4
    5980:	0003      	movs	r3, r0
    5982:	60bb      	str	r3, [r7, #8]
				configASSERT(xResult);
    5984:	68bb      	ldr	r3, [r7, #8]
    5986:	2b00      	cmp	r3, #0
    5988:	d101      	bne.n	598e <prvSwitchTimerLists+0x86>
    598a:	b672      	cpsid	i
    598c:	e7fe      	b.n	598c <prvSwitchTimerLists+0x84>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    598e:	4b09      	ldr	r3, [pc, #36]	; (59b4 <prvSwitchTimerLists+0xac>)
    5990:	681b      	ldr	r3, [r3, #0]
    5992:	681b      	ldr	r3, [r3, #0]
    5994:	2b00      	cmp	r3, #0
    5996:	d1bb      	bne.n	5910 <prvSwitchTimerLists+0x8>
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp              = pxCurrentTimerList;
    5998:	4b06      	ldr	r3, [pc, #24]	; (59b4 <prvSwitchTimerLists+0xac>)
    599a:	681b      	ldr	r3, [r3, #0]
    599c:	607b      	str	r3, [r7, #4]
	pxCurrentTimerList  = pxOverflowTimerList;
    599e:	4b09      	ldr	r3, [pc, #36]	; (59c4 <prvSwitchTimerLists+0xbc>)
    59a0:	681a      	ldr	r2, [r3, #0]
    59a2:	4b04      	ldr	r3, [pc, #16]	; (59b4 <prvSwitchTimerLists+0xac>)
    59a4:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
    59a6:	4b07      	ldr	r3, [pc, #28]	; (59c4 <prvSwitchTimerLists+0xbc>)
    59a8:	687a      	ldr	r2, [r7, #4]
    59aa:	601a      	str	r2, [r3, #0]
}
    59ac:	46c0      	nop			; (mov r8, r8)
    59ae:	46bd      	mov	sp, r7
    59b0:	b007      	add	sp, #28
    59b2:	bd90      	pop	{r4, r7, pc}
    59b4:	2000272c 	.word	0x2000272c
    59b8:	00003943 	.word	0x00003943
    59bc:	000038d7 	.word	0x000038d7
    59c0:	000054e5 	.word	0x000054e5
    59c4:	20002730 	.word	0x20002730

000059c8 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    59c8:	b580      	push	{r7, lr}
    59ca:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    59cc:	4b10      	ldr	r3, [pc, #64]	; (5a10 <prvCheckForValidListAndQueue+0x48>)
    59ce:	4798      	blx	r3
	{
		if (xTimerQueue == NULL) {
    59d0:	4b10      	ldr	r3, [pc, #64]	; (5a14 <prvCheckForValidListAndQueue+0x4c>)
    59d2:	681b      	ldr	r3, [r3, #0]
    59d4:	2b00      	cmp	r3, #0
    59d6:	d115      	bne.n	5a04 <prvCheckForValidListAndQueue+0x3c>
			vListInitialise(&xActiveTimerList1);
    59d8:	4b0f      	ldr	r3, [pc, #60]	; (5a18 <prvCheckForValidListAndQueue+0x50>)
    59da:	0018      	movs	r0, r3
    59dc:	4b0f      	ldr	r3, [pc, #60]	; (5a1c <prvCheckForValidListAndQueue+0x54>)
    59de:	4798      	blx	r3
			vListInitialise(&xActiveTimerList2);
    59e0:	4b0f      	ldr	r3, [pc, #60]	; (5a20 <prvCheckForValidListAndQueue+0x58>)
    59e2:	0018      	movs	r0, r3
    59e4:	4b0d      	ldr	r3, [pc, #52]	; (5a1c <prvCheckForValidListAndQueue+0x54>)
    59e6:	4798      	blx	r3
			pxCurrentTimerList  = &xActiveTimerList1;
    59e8:	4b0e      	ldr	r3, [pc, #56]	; (5a24 <prvCheckForValidListAndQueue+0x5c>)
    59ea:	4a0b      	ldr	r2, [pc, #44]	; (5a18 <prvCheckForValidListAndQueue+0x50>)
    59ec:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
    59ee:	4b0e      	ldr	r3, [pc, #56]	; (5a28 <prvCheckForValidListAndQueue+0x60>)
    59f0:	4a0b      	ldr	r2, [pc, #44]	; (5a20 <prvCheckForValidListAndQueue+0x58>)
    59f2:	601a      	str	r2, [r3, #0]
				                                 &(ucStaticTimerQueueStorage[0]),
				                                 &xStaticTimerQueue);
			}
#else
			{
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    59f4:	2200      	movs	r2, #0
    59f6:	210c      	movs	r1, #12
    59f8:	2002      	movs	r0, #2
    59fa:	4b0c      	ldr	r3, [pc, #48]	; (5a2c <prvCheckForValidListAndQueue+0x64>)
    59fc:	4798      	blx	r3
    59fe:	0002      	movs	r2, r0
    5a00:	4b04      	ldr	r3, [pc, #16]	; (5a14 <prvCheckForValidListAndQueue+0x4c>)
    5a02:	601a      	str	r2, [r3, #0]
#endif /* configQUEUE_REGISTRY_SIZE */
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    5a04:	4b0a      	ldr	r3, [pc, #40]	; (5a30 <prvCheckForValidListAndQueue+0x68>)
    5a06:	4798      	blx	r3
}
    5a08:	46c0      	nop			; (mov r8, r8)
    5a0a:	46bd      	mov	sp, r7
    5a0c:	bd80      	pop	{r7, pc}
    5a0e:	46c0      	nop			; (mov r8, r8)
    5a10:	00003ad1 	.word	0x00003ad1
    5a14:	20002734 	.word	0x20002734
    5a18:	20002704 	.word	0x20002704
    5a1c:	00003841 	.word	0x00003841
    5a20:	20002718 	.word	0x20002718
    5a24:	2000272c 	.word	0x2000272c
    5a28:	20002730 	.word	0x20002730
    5a2c:	00003d69 	.word	0x00003d69
    5a30:	00003af5 	.word	0x00003af5

00005a34 <__aeabi_cdrcmple>:
    5a34:	4684      	mov	ip, r0
    5a36:	1c10      	adds	r0, r2, #0
    5a38:	4662      	mov	r2, ip
    5a3a:	468c      	mov	ip, r1
    5a3c:	1c19      	adds	r1, r3, #0
    5a3e:	4663      	mov	r3, ip
    5a40:	e000      	b.n	5a44 <__aeabi_cdcmpeq>
    5a42:	46c0      	nop			; (mov r8, r8)

00005a44 <__aeabi_cdcmpeq>:
    5a44:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    5a46:	f000 f8d1 	bl	5bec <__ledf2>
    5a4a:	2800      	cmp	r0, #0
    5a4c:	d401      	bmi.n	5a52 <__aeabi_cdcmpeq+0xe>
    5a4e:	2100      	movs	r1, #0
    5a50:	42c8      	cmn	r0, r1
    5a52:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

00005a54 <__aeabi_dcmpeq>:
    5a54:	b510      	push	{r4, lr}
    5a56:	f000 f82b 	bl	5ab0 <__eqdf2>
    5a5a:	4240      	negs	r0, r0
    5a5c:	3001      	adds	r0, #1
    5a5e:	bd10      	pop	{r4, pc}

00005a60 <__aeabi_dcmplt>:
    5a60:	b510      	push	{r4, lr}
    5a62:	f000 f8c3 	bl	5bec <__ledf2>
    5a66:	2800      	cmp	r0, #0
    5a68:	db01      	blt.n	5a6e <__aeabi_dcmplt+0xe>
    5a6a:	2000      	movs	r0, #0
    5a6c:	bd10      	pop	{r4, pc}
    5a6e:	2001      	movs	r0, #1
    5a70:	bd10      	pop	{r4, pc}
    5a72:	46c0      	nop			; (mov r8, r8)

00005a74 <__aeabi_dcmple>:
    5a74:	b510      	push	{r4, lr}
    5a76:	f000 f8b9 	bl	5bec <__ledf2>
    5a7a:	2800      	cmp	r0, #0
    5a7c:	dd01      	ble.n	5a82 <__aeabi_dcmple+0xe>
    5a7e:	2000      	movs	r0, #0
    5a80:	bd10      	pop	{r4, pc}
    5a82:	2001      	movs	r0, #1
    5a84:	bd10      	pop	{r4, pc}
    5a86:	46c0      	nop			; (mov r8, r8)

00005a88 <__aeabi_dcmpgt>:
    5a88:	b510      	push	{r4, lr}
    5a8a:	f000 f84b 	bl	5b24 <__gedf2>
    5a8e:	2800      	cmp	r0, #0
    5a90:	dc01      	bgt.n	5a96 <__aeabi_dcmpgt+0xe>
    5a92:	2000      	movs	r0, #0
    5a94:	bd10      	pop	{r4, pc}
    5a96:	2001      	movs	r0, #1
    5a98:	bd10      	pop	{r4, pc}
    5a9a:	46c0      	nop			; (mov r8, r8)

00005a9c <__aeabi_dcmpge>:
    5a9c:	b510      	push	{r4, lr}
    5a9e:	f000 f841 	bl	5b24 <__gedf2>
    5aa2:	2800      	cmp	r0, #0
    5aa4:	da01      	bge.n	5aaa <__aeabi_dcmpge+0xe>
    5aa6:	2000      	movs	r0, #0
    5aa8:	bd10      	pop	{r4, pc}
    5aaa:	2001      	movs	r0, #1
    5aac:	bd10      	pop	{r4, pc}
    5aae:	46c0      	nop			; (mov r8, r8)

00005ab0 <__eqdf2>:
    5ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
    5ab2:	464f      	mov	r7, r9
    5ab4:	4646      	mov	r6, r8
    5ab6:	46d6      	mov	lr, sl
    5ab8:	005c      	lsls	r4, r3, #1
    5aba:	b5c0      	push	{r6, r7, lr}
    5abc:	031f      	lsls	r7, r3, #12
    5abe:	0fdb      	lsrs	r3, r3, #31
    5ac0:	469a      	mov	sl, r3
    5ac2:	4b17      	ldr	r3, [pc, #92]	; (5b20 <__eqdf2+0x70>)
    5ac4:	030e      	lsls	r6, r1, #12
    5ac6:	004d      	lsls	r5, r1, #1
    5ac8:	4684      	mov	ip, r0
    5aca:	4680      	mov	r8, r0
    5acc:	0b36      	lsrs	r6, r6, #12
    5ace:	0d6d      	lsrs	r5, r5, #21
    5ad0:	0fc9      	lsrs	r1, r1, #31
    5ad2:	4691      	mov	r9, r2
    5ad4:	0b3f      	lsrs	r7, r7, #12
    5ad6:	0d64      	lsrs	r4, r4, #21
    5ad8:	2001      	movs	r0, #1
    5ada:	429d      	cmp	r5, r3
    5adc:	d008      	beq.n	5af0 <__eqdf2+0x40>
    5ade:	429c      	cmp	r4, r3
    5ae0:	d001      	beq.n	5ae6 <__eqdf2+0x36>
    5ae2:	42a5      	cmp	r5, r4
    5ae4:	d00b      	beq.n	5afe <__eqdf2+0x4e>
    5ae6:	bc1c      	pop	{r2, r3, r4}
    5ae8:	4690      	mov	r8, r2
    5aea:	4699      	mov	r9, r3
    5aec:	46a2      	mov	sl, r4
    5aee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5af0:	4663      	mov	r3, ip
    5af2:	4333      	orrs	r3, r6
    5af4:	d1f7      	bne.n	5ae6 <__eqdf2+0x36>
    5af6:	42ac      	cmp	r4, r5
    5af8:	d1f5      	bne.n	5ae6 <__eqdf2+0x36>
    5afa:	433a      	orrs	r2, r7
    5afc:	d1f3      	bne.n	5ae6 <__eqdf2+0x36>
    5afe:	2001      	movs	r0, #1
    5b00:	42be      	cmp	r6, r7
    5b02:	d1f0      	bne.n	5ae6 <__eqdf2+0x36>
    5b04:	45c8      	cmp	r8, r9
    5b06:	d1ee      	bne.n	5ae6 <__eqdf2+0x36>
    5b08:	4551      	cmp	r1, sl
    5b0a:	d007      	beq.n	5b1c <__eqdf2+0x6c>
    5b0c:	2d00      	cmp	r5, #0
    5b0e:	d1ea      	bne.n	5ae6 <__eqdf2+0x36>
    5b10:	4663      	mov	r3, ip
    5b12:	431e      	orrs	r6, r3
    5b14:	0030      	movs	r0, r6
    5b16:	1e46      	subs	r6, r0, #1
    5b18:	41b0      	sbcs	r0, r6
    5b1a:	e7e4      	b.n	5ae6 <__eqdf2+0x36>
    5b1c:	2000      	movs	r0, #0
    5b1e:	e7e2      	b.n	5ae6 <__eqdf2+0x36>
    5b20:	000007ff 	.word	0x000007ff

00005b24 <__gedf2>:
    5b24:	b5f0      	push	{r4, r5, r6, r7, lr}
    5b26:	4645      	mov	r5, r8
    5b28:	46de      	mov	lr, fp
    5b2a:	4657      	mov	r7, sl
    5b2c:	464e      	mov	r6, r9
    5b2e:	b5e0      	push	{r5, r6, r7, lr}
    5b30:	031f      	lsls	r7, r3, #12
    5b32:	0b3d      	lsrs	r5, r7, #12
    5b34:	4f2c      	ldr	r7, [pc, #176]	; (5be8 <__gedf2+0xc4>)
    5b36:	030e      	lsls	r6, r1, #12
    5b38:	004c      	lsls	r4, r1, #1
    5b3a:	46ab      	mov	fp, r5
    5b3c:	005d      	lsls	r5, r3, #1
    5b3e:	4684      	mov	ip, r0
    5b40:	0b36      	lsrs	r6, r6, #12
    5b42:	0d64      	lsrs	r4, r4, #21
    5b44:	0fc9      	lsrs	r1, r1, #31
    5b46:	4690      	mov	r8, r2
    5b48:	0d6d      	lsrs	r5, r5, #21
    5b4a:	0fdb      	lsrs	r3, r3, #31
    5b4c:	42bc      	cmp	r4, r7
    5b4e:	d02a      	beq.n	5ba6 <__gedf2+0x82>
    5b50:	4f25      	ldr	r7, [pc, #148]	; (5be8 <__gedf2+0xc4>)
    5b52:	42bd      	cmp	r5, r7
    5b54:	d02d      	beq.n	5bb2 <__gedf2+0x8e>
    5b56:	2c00      	cmp	r4, #0
    5b58:	d10f      	bne.n	5b7a <__gedf2+0x56>
    5b5a:	4330      	orrs	r0, r6
    5b5c:	0007      	movs	r7, r0
    5b5e:	4681      	mov	r9, r0
    5b60:	4278      	negs	r0, r7
    5b62:	4178      	adcs	r0, r7
    5b64:	b2c0      	uxtb	r0, r0
    5b66:	2d00      	cmp	r5, #0
    5b68:	d117      	bne.n	5b9a <__gedf2+0x76>
    5b6a:	465f      	mov	r7, fp
    5b6c:	433a      	orrs	r2, r7
    5b6e:	d114      	bne.n	5b9a <__gedf2+0x76>
    5b70:	464b      	mov	r3, r9
    5b72:	2000      	movs	r0, #0
    5b74:	2b00      	cmp	r3, #0
    5b76:	d00a      	beq.n	5b8e <__gedf2+0x6a>
    5b78:	e006      	b.n	5b88 <__gedf2+0x64>
    5b7a:	2d00      	cmp	r5, #0
    5b7c:	d102      	bne.n	5b84 <__gedf2+0x60>
    5b7e:	4658      	mov	r0, fp
    5b80:	4302      	orrs	r2, r0
    5b82:	d001      	beq.n	5b88 <__gedf2+0x64>
    5b84:	4299      	cmp	r1, r3
    5b86:	d018      	beq.n	5bba <__gedf2+0x96>
    5b88:	4248      	negs	r0, r1
    5b8a:	2101      	movs	r1, #1
    5b8c:	4308      	orrs	r0, r1
    5b8e:	bc3c      	pop	{r2, r3, r4, r5}
    5b90:	4690      	mov	r8, r2
    5b92:	4699      	mov	r9, r3
    5b94:	46a2      	mov	sl, r4
    5b96:	46ab      	mov	fp, r5
    5b98:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5b9a:	2800      	cmp	r0, #0
    5b9c:	d0f2      	beq.n	5b84 <__gedf2+0x60>
    5b9e:	2001      	movs	r0, #1
    5ba0:	3b01      	subs	r3, #1
    5ba2:	4318      	orrs	r0, r3
    5ba4:	e7f3      	b.n	5b8e <__gedf2+0x6a>
    5ba6:	0037      	movs	r7, r6
    5ba8:	4307      	orrs	r7, r0
    5baa:	d0d1      	beq.n	5b50 <__gedf2+0x2c>
    5bac:	2002      	movs	r0, #2
    5bae:	4240      	negs	r0, r0
    5bb0:	e7ed      	b.n	5b8e <__gedf2+0x6a>
    5bb2:	465f      	mov	r7, fp
    5bb4:	4317      	orrs	r7, r2
    5bb6:	d0ce      	beq.n	5b56 <__gedf2+0x32>
    5bb8:	e7f8      	b.n	5bac <__gedf2+0x88>
    5bba:	42ac      	cmp	r4, r5
    5bbc:	dce4      	bgt.n	5b88 <__gedf2+0x64>
    5bbe:	da03      	bge.n	5bc8 <__gedf2+0xa4>
    5bc0:	1e48      	subs	r0, r1, #1
    5bc2:	2101      	movs	r1, #1
    5bc4:	4308      	orrs	r0, r1
    5bc6:	e7e2      	b.n	5b8e <__gedf2+0x6a>
    5bc8:	455e      	cmp	r6, fp
    5bca:	d8dd      	bhi.n	5b88 <__gedf2+0x64>
    5bcc:	d006      	beq.n	5bdc <__gedf2+0xb8>
    5bce:	2000      	movs	r0, #0
    5bd0:	455e      	cmp	r6, fp
    5bd2:	d2dc      	bcs.n	5b8e <__gedf2+0x6a>
    5bd4:	2301      	movs	r3, #1
    5bd6:	1e48      	subs	r0, r1, #1
    5bd8:	4318      	orrs	r0, r3
    5bda:	e7d8      	b.n	5b8e <__gedf2+0x6a>
    5bdc:	45c4      	cmp	ip, r8
    5bde:	d8d3      	bhi.n	5b88 <__gedf2+0x64>
    5be0:	2000      	movs	r0, #0
    5be2:	45c4      	cmp	ip, r8
    5be4:	d3f6      	bcc.n	5bd4 <__gedf2+0xb0>
    5be6:	e7d2      	b.n	5b8e <__gedf2+0x6a>
    5be8:	000007ff 	.word	0x000007ff

00005bec <__ledf2>:
    5bec:	b5f0      	push	{r4, r5, r6, r7, lr}
    5bee:	464e      	mov	r6, r9
    5bf0:	4645      	mov	r5, r8
    5bf2:	46de      	mov	lr, fp
    5bf4:	4657      	mov	r7, sl
    5bf6:	005c      	lsls	r4, r3, #1
    5bf8:	b5e0      	push	{r5, r6, r7, lr}
    5bfa:	031f      	lsls	r7, r3, #12
    5bfc:	0fdb      	lsrs	r3, r3, #31
    5bfe:	4699      	mov	r9, r3
    5c00:	4b2a      	ldr	r3, [pc, #168]	; (5cac <__ledf2+0xc0>)
    5c02:	030e      	lsls	r6, r1, #12
    5c04:	004d      	lsls	r5, r1, #1
    5c06:	0fc9      	lsrs	r1, r1, #31
    5c08:	4684      	mov	ip, r0
    5c0a:	0b36      	lsrs	r6, r6, #12
    5c0c:	0d6d      	lsrs	r5, r5, #21
    5c0e:	468b      	mov	fp, r1
    5c10:	4690      	mov	r8, r2
    5c12:	0b3f      	lsrs	r7, r7, #12
    5c14:	0d64      	lsrs	r4, r4, #21
    5c16:	429d      	cmp	r5, r3
    5c18:	d020      	beq.n	5c5c <__ledf2+0x70>
    5c1a:	4b24      	ldr	r3, [pc, #144]	; (5cac <__ledf2+0xc0>)
    5c1c:	429c      	cmp	r4, r3
    5c1e:	d022      	beq.n	5c66 <__ledf2+0x7a>
    5c20:	2d00      	cmp	r5, #0
    5c22:	d112      	bne.n	5c4a <__ledf2+0x5e>
    5c24:	4330      	orrs	r0, r6
    5c26:	4243      	negs	r3, r0
    5c28:	4143      	adcs	r3, r0
    5c2a:	b2db      	uxtb	r3, r3
    5c2c:	2c00      	cmp	r4, #0
    5c2e:	d01f      	beq.n	5c70 <__ledf2+0x84>
    5c30:	2b00      	cmp	r3, #0
    5c32:	d00c      	beq.n	5c4e <__ledf2+0x62>
    5c34:	464b      	mov	r3, r9
    5c36:	2001      	movs	r0, #1
    5c38:	3b01      	subs	r3, #1
    5c3a:	4303      	orrs	r3, r0
    5c3c:	0018      	movs	r0, r3
    5c3e:	bc3c      	pop	{r2, r3, r4, r5}
    5c40:	4690      	mov	r8, r2
    5c42:	4699      	mov	r9, r3
    5c44:	46a2      	mov	sl, r4
    5c46:	46ab      	mov	fp, r5
    5c48:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5c4a:	2c00      	cmp	r4, #0
    5c4c:	d016      	beq.n	5c7c <__ledf2+0x90>
    5c4e:	45cb      	cmp	fp, r9
    5c50:	d017      	beq.n	5c82 <__ledf2+0x96>
    5c52:	465b      	mov	r3, fp
    5c54:	4259      	negs	r1, r3
    5c56:	2301      	movs	r3, #1
    5c58:	430b      	orrs	r3, r1
    5c5a:	e7ef      	b.n	5c3c <__ledf2+0x50>
    5c5c:	0031      	movs	r1, r6
    5c5e:	2302      	movs	r3, #2
    5c60:	4301      	orrs	r1, r0
    5c62:	d1eb      	bne.n	5c3c <__ledf2+0x50>
    5c64:	e7d9      	b.n	5c1a <__ledf2+0x2e>
    5c66:	0039      	movs	r1, r7
    5c68:	2302      	movs	r3, #2
    5c6a:	4311      	orrs	r1, r2
    5c6c:	d1e6      	bne.n	5c3c <__ledf2+0x50>
    5c6e:	e7d7      	b.n	5c20 <__ledf2+0x34>
    5c70:	433a      	orrs	r2, r7
    5c72:	d1dd      	bne.n	5c30 <__ledf2+0x44>
    5c74:	2300      	movs	r3, #0
    5c76:	2800      	cmp	r0, #0
    5c78:	d0e0      	beq.n	5c3c <__ledf2+0x50>
    5c7a:	e7ea      	b.n	5c52 <__ledf2+0x66>
    5c7c:	433a      	orrs	r2, r7
    5c7e:	d1e6      	bne.n	5c4e <__ledf2+0x62>
    5c80:	e7e7      	b.n	5c52 <__ledf2+0x66>
    5c82:	42a5      	cmp	r5, r4
    5c84:	dce5      	bgt.n	5c52 <__ledf2+0x66>
    5c86:	db05      	blt.n	5c94 <__ledf2+0xa8>
    5c88:	42be      	cmp	r6, r7
    5c8a:	d8e2      	bhi.n	5c52 <__ledf2+0x66>
    5c8c:	d007      	beq.n	5c9e <__ledf2+0xb2>
    5c8e:	2300      	movs	r3, #0
    5c90:	42be      	cmp	r6, r7
    5c92:	d2d3      	bcs.n	5c3c <__ledf2+0x50>
    5c94:	4659      	mov	r1, fp
    5c96:	2301      	movs	r3, #1
    5c98:	3901      	subs	r1, #1
    5c9a:	430b      	orrs	r3, r1
    5c9c:	e7ce      	b.n	5c3c <__ledf2+0x50>
    5c9e:	45c4      	cmp	ip, r8
    5ca0:	d8d7      	bhi.n	5c52 <__ledf2+0x66>
    5ca2:	2300      	movs	r3, #0
    5ca4:	45c4      	cmp	ip, r8
    5ca6:	d3f5      	bcc.n	5c94 <__ledf2+0xa8>
    5ca8:	e7c8      	b.n	5c3c <__ledf2+0x50>
    5caa:	46c0      	nop			; (mov r8, r8)
    5cac:	000007ff 	.word	0x000007ff

00005cb0 <__aeabi_i2d>:
    5cb0:	b570      	push	{r4, r5, r6, lr}
    5cb2:	2800      	cmp	r0, #0
    5cb4:	d030      	beq.n	5d18 <__aeabi_i2d+0x68>
    5cb6:	17c3      	asrs	r3, r0, #31
    5cb8:	18c4      	adds	r4, r0, r3
    5cba:	405c      	eors	r4, r3
    5cbc:	0fc5      	lsrs	r5, r0, #31
    5cbe:	0020      	movs	r0, r4
    5cc0:	f000 f838 	bl	5d34 <__clzsi2>
    5cc4:	4b17      	ldr	r3, [pc, #92]	; (5d24 <__aeabi_i2d+0x74>)
    5cc6:	4a18      	ldr	r2, [pc, #96]	; (5d28 <__aeabi_i2d+0x78>)
    5cc8:	1a1b      	subs	r3, r3, r0
    5cca:	1ad2      	subs	r2, r2, r3
    5ccc:	2a1f      	cmp	r2, #31
    5cce:	dd18      	ble.n	5d02 <__aeabi_i2d+0x52>
    5cd0:	4a16      	ldr	r2, [pc, #88]	; (5d2c <__aeabi_i2d+0x7c>)
    5cd2:	1ad2      	subs	r2, r2, r3
    5cd4:	4094      	lsls	r4, r2
    5cd6:	2200      	movs	r2, #0
    5cd8:	0324      	lsls	r4, r4, #12
    5cda:	055b      	lsls	r3, r3, #21
    5cdc:	0b24      	lsrs	r4, r4, #12
    5cde:	0d5b      	lsrs	r3, r3, #21
    5ce0:	2100      	movs	r1, #0
    5ce2:	0010      	movs	r0, r2
    5ce4:	0324      	lsls	r4, r4, #12
    5ce6:	0d0a      	lsrs	r2, r1, #20
    5ce8:	0b24      	lsrs	r4, r4, #12
    5cea:	0512      	lsls	r2, r2, #20
    5cec:	4322      	orrs	r2, r4
    5cee:	4c10      	ldr	r4, [pc, #64]	; (5d30 <__aeabi_i2d+0x80>)
    5cf0:	051b      	lsls	r3, r3, #20
    5cf2:	4022      	ands	r2, r4
    5cf4:	4313      	orrs	r3, r2
    5cf6:	005b      	lsls	r3, r3, #1
    5cf8:	07ed      	lsls	r5, r5, #31
    5cfa:	085b      	lsrs	r3, r3, #1
    5cfc:	432b      	orrs	r3, r5
    5cfe:	0019      	movs	r1, r3
    5d00:	bd70      	pop	{r4, r5, r6, pc}
    5d02:	0021      	movs	r1, r4
    5d04:	4091      	lsls	r1, r2
    5d06:	000a      	movs	r2, r1
    5d08:	210b      	movs	r1, #11
    5d0a:	1a08      	subs	r0, r1, r0
    5d0c:	40c4      	lsrs	r4, r0
    5d0e:	055b      	lsls	r3, r3, #21
    5d10:	0324      	lsls	r4, r4, #12
    5d12:	0b24      	lsrs	r4, r4, #12
    5d14:	0d5b      	lsrs	r3, r3, #21
    5d16:	e7e3      	b.n	5ce0 <__aeabi_i2d+0x30>
    5d18:	2500      	movs	r5, #0
    5d1a:	2300      	movs	r3, #0
    5d1c:	2400      	movs	r4, #0
    5d1e:	2200      	movs	r2, #0
    5d20:	e7de      	b.n	5ce0 <__aeabi_i2d+0x30>
    5d22:	46c0      	nop			; (mov r8, r8)
    5d24:	0000041e 	.word	0x0000041e
    5d28:	00000433 	.word	0x00000433
    5d2c:	00000413 	.word	0x00000413
    5d30:	800fffff 	.word	0x800fffff

00005d34 <__clzsi2>:
    5d34:	211c      	movs	r1, #28
    5d36:	2301      	movs	r3, #1
    5d38:	041b      	lsls	r3, r3, #16
    5d3a:	4298      	cmp	r0, r3
    5d3c:	d301      	bcc.n	5d42 <__clzsi2+0xe>
    5d3e:	0c00      	lsrs	r0, r0, #16
    5d40:	3910      	subs	r1, #16
    5d42:	0a1b      	lsrs	r3, r3, #8
    5d44:	4298      	cmp	r0, r3
    5d46:	d301      	bcc.n	5d4c <__clzsi2+0x18>
    5d48:	0a00      	lsrs	r0, r0, #8
    5d4a:	3908      	subs	r1, #8
    5d4c:	091b      	lsrs	r3, r3, #4
    5d4e:	4298      	cmp	r0, r3
    5d50:	d301      	bcc.n	5d56 <__clzsi2+0x22>
    5d52:	0900      	lsrs	r0, r0, #4
    5d54:	3904      	subs	r1, #4
    5d56:	a202      	add	r2, pc, #8	; (adr r2, 5d60 <__clzsi2+0x2c>)
    5d58:	5c10      	ldrb	r0, [r2, r0]
    5d5a:	1840      	adds	r0, r0, r1
    5d5c:	4770      	bx	lr
    5d5e:	46c0      	nop			; (mov r8, r8)
    5d60:	02020304 	.word	0x02020304
    5d64:	01010101 	.word	0x01010101
	...

00005d70 <__libc_init_array>:
    5d70:	b570      	push	{r4, r5, r6, lr}
    5d72:	2600      	movs	r6, #0
    5d74:	4d0c      	ldr	r5, [pc, #48]	; (5da8 <__libc_init_array+0x38>)
    5d76:	4c0d      	ldr	r4, [pc, #52]	; (5dac <__libc_init_array+0x3c>)
    5d78:	1b64      	subs	r4, r4, r5
    5d7a:	10a4      	asrs	r4, r4, #2
    5d7c:	42a6      	cmp	r6, r4
    5d7e:	d109      	bne.n	5d94 <__libc_init_array+0x24>
    5d80:	2600      	movs	r6, #0
    5d82:	f000 f8e5 	bl	5f50 <_init>
    5d86:	4d0a      	ldr	r5, [pc, #40]	; (5db0 <__libc_init_array+0x40>)
    5d88:	4c0a      	ldr	r4, [pc, #40]	; (5db4 <__libc_init_array+0x44>)
    5d8a:	1b64      	subs	r4, r4, r5
    5d8c:	10a4      	asrs	r4, r4, #2
    5d8e:	42a6      	cmp	r6, r4
    5d90:	d105      	bne.n	5d9e <__libc_init_array+0x2e>
    5d92:	bd70      	pop	{r4, r5, r6, pc}
    5d94:	00b3      	lsls	r3, r6, #2
    5d96:	58eb      	ldr	r3, [r5, r3]
    5d98:	4798      	blx	r3
    5d9a:	3601      	adds	r6, #1
    5d9c:	e7ee      	b.n	5d7c <__libc_init_array+0xc>
    5d9e:	00b3      	lsls	r3, r6, #2
    5da0:	58eb      	ldr	r3, [r5, r3]
    5da2:	4798      	blx	r3
    5da4:	3601      	adds	r6, #1
    5da6:	e7f2      	b.n	5d8e <__libc_init_array+0x1e>
    5da8:	00005f5c 	.word	0x00005f5c
    5dac:	00005f5c 	.word	0x00005f5c
    5db0:	00005f5c 	.word	0x00005f5c
    5db4:	00005f60 	.word	0x00005f60

00005db8 <memcpy>:
    5db8:	2300      	movs	r3, #0
    5dba:	b510      	push	{r4, lr}
    5dbc:	429a      	cmp	r2, r3
    5dbe:	d100      	bne.n	5dc2 <memcpy+0xa>
    5dc0:	bd10      	pop	{r4, pc}
    5dc2:	5ccc      	ldrb	r4, [r1, r3]
    5dc4:	54c4      	strb	r4, [r0, r3]
    5dc6:	3301      	adds	r3, #1
    5dc8:	e7f8      	b.n	5dbc <memcpy+0x4>

00005dca <memset>:
    5dca:	0003      	movs	r3, r0
    5dcc:	1882      	adds	r2, r0, r2
    5dce:	4293      	cmp	r3, r2
    5dd0:	d100      	bne.n	5dd4 <memset+0xa>
    5dd2:	4770      	bx	lr
    5dd4:	7019      	strb	r1, [r3, #0]
    5dd6:	3301      	adds	r3, #1
    5dd8:	e7f9      	b.n	5dce <memset+0x4>
    5dda:	0000      	movs	r0, r0
    5ddc:	682f2e2e 	.word	0x682f2e2e
    5de0:	702f6c70 	.word	0x702f6c70
    5de4:	2f74726f 	.word	0x2f74726f
    5de8:	5f6c7068 	.word	0x5f6c7068
    5dec:	6f697067 	.word	0x6f697067
    5df0:	7361625f 	.word	0x7361625f
    5df4:	00682e65 	.word	0x00682e65
    5df8:	682f2e2e 	.word	0x682f2e2e
    5dfc:	732f6c61 	.word	0x732f6c61
    5e00:	682f6372 	.word	0x682f6372
    5e04:	615f6c61 	.word	0x615f6c61
    5e08:	735f6364 	.word	0x735f6364
    5e0c:	2e636e79 	.word	0x2e636e79
    5e10:	00000063 	.word	0x00000063
    5e14:	682f2e2e 	.word	0x682f2e2e
    5e18:	732f6c61 	.word	0x732f6c61
    5e1c:	682f6372 	.word	0x682f6372
    5e20:	695f6c61 	.word	0x695f6c61
    5e24:	00632e6f 	.word	0x00632e6f
    5e28:	682f2e2e 	.word	0x682f2e2e
    5e2c:	732f6c61 	.word	0x732f6c61
    5e30:	682f6372 	.word	0x682f6372
    5e34:	705f6c61 	.word	0x705f6c61
    5e38:	632e6d77 	.word	0x632e6d77
    5e3c:	00000000 	.word	0x00000000
    5e40:	682f2e2e 	.word	0x682f2e2e
    5e44:	732f6c61 	.word	0x732f6c61
    5e48:	682f6372 	.word	0x682f6372
    5e4c:	755f6c61 	.word	0x755f6c61
    5e50:	74726173 	.word	0x74726173
    5e54:	6e79735f 	.word	0x6e79735f
    5e58:	00632e63 	.word	0x00632e63

00005e5c <_adcs>:
    5e5c:	05000000 19030000 00000000 00000000     ................
	...
    5e78:	682f2e2e 612f6c70 682f6364 615f6c70     ../hpl/adc/hpl_a
    5e88:	632e6364 00000000 682f2e2e 732f6c70     dc.c....../hpl/s
    5e98:	6f637265 70682f6d 65735f6c 6d6f6372     ercom/hpl_sercom
    5ea8:	0000632e                                .c..

00005eac <sercomspi_regs>:
	...
    5ec0:	682f2e2e 742f6c70 70682f63 63745f6c     ../hpl/tc/hpl_tc
    5ed0:	0000632e 54415453 00000045 00000072     .c..STATE...r...
    5ee0:	454c4449 00000000 09632509 25097525     IDLE.....%c.%u.%
    5ef0:	75250975 00000a0d 000051d8 0000519e     u.%u.....Q...Q..
    5f00:	000051ac 000051b8 000051c0 00005308     .Q...Q...Q...S..
    5f10:	000052ce 000052dc 000052e8 000052f0     .R...R...R...R..
    5f20:	20726d54 00637653 0000583c 0000583c     Tmr Svc.<X..<X..
    5f30:	0000583c 000058ca 00005894 000058be     <X...X...X...X..
    5f40:	0000583c 0000583c 000058ca 00005894     <X..<X...X...X..

00005f50 <_init>:
    5f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5f52:	46c0      	nop			; (mov r8, r8)
    5f54:	bcf8      	pop	{r3, r4, r5, r6, r7}
    5f56:	bc08      	pop	{r3}
    5f58:	469e      	mov	lr, r3
    5f5a:	4770      	bx	lr

00005f5c <__init_array_start>:
    5f5c:	000000e5 	.word	0x000000e5

00005f60 <_fini>:
    5f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5f62:	46c0      	nop			; (mov r8, r8)
    5f64:	bcf8      	pop	{r3, r4, r5, r6, r7}
    5f66:	bc08      	pop	{r3}
    5f68:	469e      	mov	lr, r3
    5f6a:	4770      	bx	lr

00005f6c <__fini_array_start>:
    5f6c:	000000bd 	.word	0x000000bd
